// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package ethbridgecontracts

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// MessagesChallengeABI is the input ABI used to generate the binding from.
const MessagesChallengeABI = "[{\"anonymous\":false,\"inputs\":[],\"name\":\"AsserterTimedOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"chainHashes\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"segmentHashes\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"}],\"name\":\"Bisected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ChallengerTimedOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"segmentIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"}],\"name\":\"Continued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"}],\"name\":\"InitiatedChallenge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OneStepProofCompleted\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_chainHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_segmentHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_chainLength\",\"type\":\"uint256\"}],\"name\":\"bisect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_segmentToChallenge\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_bisectionRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_bisectionHash\",\"type\":\"bytes32\"}],\"name\":\"chooseSegment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rollupAddress\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"_asserter\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"_challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_challengePeriodTicks\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_challengeState\",\"type\":\"bytes32\"}],\"name\":\"initializeBisection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_afterGlobalInbox\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_beforeVMInbox\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_kind\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inboxSeqNum\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_msgData\",\"type\":\"bytes\"}],\"name\":\"oneStepProof\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"timeoutChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// MessagesChallengeFuncSigs maps the 4-byte function signature to its string representation.
var MessagesChallengeFuncSigs = map[string]string{
	"500439e5": "bisect(bytes32[],bytes32[],uint256)",
	"79a9ad85": "chooseSegment(uint256,bytes,bytes32,bytes32)",
	"02ad1e4e": "initializeBisection(address,address,address,uint256,bytes32)",
	"77dec71e": "oneStepProof(bytes32,bytes32,uint8,uint256,uint256,address,uint256,bytes)",
	"ced5c1bf": "timeoutChallenge()",
}

// MessagesChallengeBin is the compiled bytecode used for deploying new contracts.
var MessagesChallengeBin = "0x608060405234801561001057600080fd5b50611d7b806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806302ad1e4e1461005c578063500439e5146100a057806377dec71e1461015e57806379a9ad8514610205578063ced5c1bf146102b5575b600080fd5b61009e600480360360a081101561007257600080fd5b506001600160a01b038135811691602081013582169160408201351690606081013590608001356102bd565b005b61009e600480360360608110156100b657600080fd5b810190602081018135600160201b8111156100d057600080fd5b8201836020820111156100e257600080fd5b803590602001918460208302840111600160201b8311171561010357600080fd5b919390929091602081019035600160201b81111561012057600080fd5b82018360208201111561013257600080fd5b803590602001918460208302840111600160201b8311171561015357600080fd5b9193509150356102d2565b61009e600480360361010081101561017557600080fd5b81359160208101359160ff604083013516916060810135916080820135916001600160a01b0360a0820135169160c08201359190810190610100810160e0820135600160201b8111156101c757600080fd5b8201836020820111156101d957600080fd5b803590602001918460018302840111600160201b831117156101fa57600080fd5b509092509050610758565b61009e6004803603608081101561021b57600080fd5b81359190810190604081016020820135600160201b81111561023c57600080fd5b82018360208201111561024e57600080fd5b803590602001918460018302840111600160201b8311171561026f57600080fd5b91908080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092955050823593505050602001356109b1565b61009e610c72565b6102c985858585610d52565b60065550505050565b60055460ff1660028111156102e357fe5b600114604051806040016040528060098152602001684249535f535441544560b81b815250906103915760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561035657818101518382015260200161033e565b50505050905090810190601f1680156103835780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5060035461039e43610e6d565b11156040518060400160405280600c81526020016b4249535f444541444c494e4560a01b815250906104115760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b5060015460408051808201909152600a8152692124a9afa9a2a72222a960b11b6020820152906001600160a01b0316331461048d5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b5060408051808201909152600d81526c2429afa124a9afa4a7282622a760991b60208201526000198501908386146105065760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b506105666105618787600081811061051a57fe5b9050602002013588888581811061052d57fe5b905060200201358787600081811061054157fe5b9050602002013588888781811061055457fe5b9050602002013587610e78565b610ebe565b606081604051908082528060200260200182016040528015610592578160200160208202803883390190505b5090506105f7878760008181106105a557fe5b90506020020135888860018181106105b957fe5b90506020020135878760008181106105cd57fe5b90506020020135888860018181106105e157fe5b905060200201356105f28888610f34565b610e78565b8160008151811061060457fe5b602090810291909101015260015b828110156106985761067988888381811061062957fe5b9050602002013589898460010181811061063f57fe5b9050602002013588888581811061065257fe5b9050602002013589898660010181811061066857fe5b905060200201356105f28989610f52565b82828151811061068557fe5b6020908102919091010152600101610612565b506106a281610f65565b6106aa610f74565b7f500c4a1bbd12a65d684bde95626a41abdd6a8c5d30f84c5c9b81e5bdb0cc0bd387878787876003546040518080602001806020018581526020018481526020018381038352898982818152602001925060200280828437600083820152601f01601f19169091018481038352878152602090810191508890880280828437600083820152604051601f909101601f19169092018290039a509098505050505050505050a150505050505050565b60055460ff16600281111561076957fe5b600114604051806040016040528060098152602001684249535f535441544560b81b815250906107da5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b506003546107e743610e6d565b11156040518060400160405280600c81526020016b4249535f444541444c494e4560a01b8152509061085a5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b5060015460408051808201909152600a8152692124a9afa9a2a72222a960b11b6020820152906001600160a01b031633146108d65760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b50600061090c8a6109078a888b8b8a8a8a6040518083838082843760405192018290039091209350610f9192505050565b610fff565b905060006109608a61090761095b8c8c8c8c8c8c8c8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061102b92505050565b611153565b9050610973610561838d8d856001610e78565b6040517f117efdf1fdd8be5a6ff0fb3c32333d7033bbd9523924bd0d9ca28f43540516f590600090a16109a4611273565b5050505050505050505050565b60055460ff1660028111156109c257fe5b60021460405180604001604052806009815260200168434f4e5f535441544560b81b81525090610a335760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b50600354610a4043610e6d565b11156040518060400160405280600c81526020016b434f4e5f444541444c494e4560a01b81525090610ab35760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b5060025460408051808201909152600a81526921a7a72fa9a2a72222a960b11b6020820152906001600160a01b03163314610b2f5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b5060065482146040518060400160405280600881526020016721a7a72fa82922ab60c11b81525090610ba25760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b50610bb2838383876001016112e7565b6040518060400160405280600981526020016821a7a72fa82927a7a360b91b81525090610c205760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b506006819055610c2e6113e8565b60035460408051868152602081019290925280517f1e1c1e4e68a25c69a078a396e73975691c071d69ef789015dc16a562957804e49281900390910190a150505050565b600354610c7e43610e6d565b11610cd0576040805162461bcd60e51b815260206004820152601760248201527f446561646c696e65206861736e27742065787069726564000000000000000000604482015290519081900360640190fd5b600160055460ff166002811115610ce357fe5b1415610d1f576040517f2b92a4b014281aa2424baba9ea60bf4f26833d1c1fbd873e51cd1a6caeef48f090600090a1610d1a6113fb565b610d50565b6040517f4e1f1f06cf69d199fcdb4d87a5a92d5248ca6b540e9fc2d3698927c5002a236a90600090a1610d50611273565b565b600060055460ff166002811115610d6557fe5b146040518060400160405280600f81526020016e4348414c5f494e49545f535441544560881b81525090610dda5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b50600080546001600160a01b038681166001600160a01b03199283161790925560018054868416908316178155600280549386169390921692909217905560048290556005805460ff19169091179055610e32611453565b60035460408051918252517fe070f23072cbc6c0fc7253b8d0120649d5f9d6e19a8aeab79eb50aa6360bcc679181900360200190a150505050565b6103e881025b919050565b60408051602080820197909752808201959095526060850193909352608084019190915260a0808401919091528151808403909101815260c09092019052805191012090565b6006548114604051806040016040528060088152602001672124a9afa82922ab60c11b81525090610f305760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561035657818101518382015260200161033e565b5050565b6000818381610f3f57fe5b06828481610f4957fe5b04019392505050565b6000818381610f5d57fe5b049392505050565b610f6e81611465565b60065550565b600580546002919060ff19166001835b0217905550610d50611453565b6040805160f89790971b6001600160f81b03191660208089019190915260609690961b6bffffffffffffffffffffffff191660218801526035870194909452605586019290925260758501526095808501919091528151808503909101815260b59093019052815191012090565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b611033611cf3565b60408051600680825260e08201909252606091816020015b611053611cf3565b81526020019060019003908161104b5790505090506110748860ff166115a3565b8160008151811061108157fe5b6020026020010181905250611095876115a3565b816001815181106110a257fe5b60200260200101819052506110b6866115a3565b816002815181106110c357fe5b60200260200101819052506110e0856001600160a01b03166115a3565b816003815181106110ed57fe5b6020026020010181905250611101846115a3565b8160048151811061110e57fe5b60200260200101819052506111268360008551611655565b8160058151811061113357fe5b6020026020010181905250611147816117d9565b98975050505050505050565b600061115d6118eb565b60ff16826060015160ff161415611180578151611179906118f0565b9050610e73565b611188611914565b60ff16826060015160ff1614156111a6576111798260200151611919565b6111ae611a16565b60ff16826060015160ff1614156111d057815160808301516111799190611a1b565b6111d8611a6c565b60ff16826060015160ff161415611211576111f1611cf3565b6111fe8360400151611a71565b905061120981611153565b915050610e73565b611219611bd3565b60ff16826060015160ff16141561123257508051610e73565b6040805162461bcd60e51b8152602060048201526011602482015270496e76616c6964207479706520636f646560781b604482015290519081900360640190fd5b600080546001546002546040805163396f51cf60e01b81526001600160a01b039384166004820152918316602483015251919092169263396f51cf926044808201939182900301818387803b1580156112cb57600080fd5b505af11580156112df573d6000803e3d6000fd5b503392505050ff5b600080838160205b885181116113da578089015193506020818a51036020018161130d57fe5b0491505b6000821180156113245750600286066001145b801561133257508160020a86115b1561134557600286046001019550611311565b6002860661139057838360405160200180838152602001828152602001925050506040516020818303038152906040528051906020012092506002868161138857fe5b0495506113d2565b82846040516020018083815260200182815260200192505050604051602081830303815290604052805190602001209250600286816113cb57fe5b0460010195505b6020016112ef565b505090941495945050505050565b600580546001919060ff19168280610f84565b600080546002546001546040805163396f51cf60e01b81526001600160a01b039384166004820152918316602483015251919092169263396f51cf926044808201939182900301818387803b1580156112cb57600080fd5b60045461145f43610e6d565b01600355565b6000815b600181511115611586576060600282516001018161148357fe5b046040519080825280602002602001820160405280156114ad578160200160208202803883390190505b50905060005b815181101561157e578251816002026001011015611546578281600202815181106114da57fe5b60200260200101518382600202600101815181106114f457fe5b602002602001015160405160200180838152602001828152602001925050506040516020818303038152906040528051906020012082828151811061153557fe5b602002602001018181525050611576565b82816002028151811061155557fe5b602002602001015182828151811061156957fe5b6020026020010181815250505b6001016114b3565b509050611469565b8060008151811061159357fe5b6020026020010151915050919050565b6115ab611cf3565b6040805160a0810182528381528151606081018352600080825260208281018290528451828152808201865293949085019390830191611601565b6115ee611cf3565b8152602001906001900390816115e65790505b5090528152604080516000808252602082810190935291909201919061163d565b61162a611cf3565b8152602001906001900390816116225790505b50815260006020820152600160409091015292915050565b61165d611cf3565b60208204611669611cf3565b611671611bd8565b60408051600280825260608281019093529293509091816020015b611694611cf3565b81526020019060019003908161168c57905050905060005b83811015611715576116d16116cc89602084028a0163ffffffff611c1f16565b6115a3565b826000815181106116de57fe5b602002602001018190525082826001815181106116f757fe5b602002602001018190525061170b82611a71565b92506001016116ac565b50602085061561178b57600061173788601f198989010163ffffffff611c1f16565b9050602086066020036008021b61174d816115a3565b8260008151811061175a57fe5b6020026020010181905250828260018151811061177357fe5b602002602001018190525061178782611a71565b9250505b611794856115a3565b816000815181106117a157fe5b602002602001018190525081816001815181106117ba57fe5b60200260200101819052506117ce81611a71565b979650505050505050565b6117e1611cf3565b6117eb8251611c3b565b61183c576040805162461bcd60e51b815260206004820152601a60248201527f5475706c65206d75737420686176652076616c69642073697a65000000000000604482015290519081900360640190fd5b600160005b83518110156118735783818151811061185657fe5b602002602001015160800151820191508080600101915050611841565b506040805160a08101825260008082528251606081018452818152602081810183905284518381528082018652939490850193919290830191906118cd565b6118ba611cf3565b8152602001906001900390816118b25790505b50905281526020810194909452600360408501526060909301525090565b600090565b60408051602080820193909352815180820384018152908201909152805191012090565b600190565b600060028260400151511061192a57fe5b60408201515161198f5761193c611914565b8251602080850151604080516001600160f81b031960f896871b8116828601529490951b909316602185015260228085019190915282518085039091018152604290930190915281519101209050610e73565b611997611914565b82600001516119bd84604001516000815181106119b057fe5b6020026020010151611153565b8460200151604051602001808560ff1660ff1660f81b81526001018460ff1660ff1660f81b8152600101838152602001828152602001945050505050604051602081830303815290604052805190602001209050919050565b600290565b6000611a25611a6c565b8383604051602001808460ff1660ff1660f81b8152600101838152602001828152602001935050505060405160208183030381529060405280519060200120905092915050565b600390565b611a79611cf3565b600882511115611ac7576040805162461bcd60e51b8152602060048201526014602482015273092dcecc2d8d2c840e8eae0d8ca40d8cadccee8d60631b604482015290519081900360640190fd5b60608251604051908082528060200260200182016040528015611af4578160200160208202803883390190505b508051909150600160005b82811015611b5757611b168682815181106119b057fe5b848281518110611b2257fe5b602002602001018181525050858181518110611b3a57fe5b602002602001015160800151820191508080600101915050611aff565b506000835184604051602001808360ff1660ff1660f81b8152600101828051906020019060200280838360005b83811015611b9c578181015183820152602001611b84565b5050505090500192505050604051602081830303815290604052805190602001209050611bc98183611c42565b9695505050505050565b606490565b611be0611cf3565b60408051600080825260208201909252611c1a91611c14565b611c01611cf3565b815260200190600190039081611bf95790505b506117d9565b905090565b60008160200183511015611c3257600080fd5b50016020015190565b6008101590565b611c4a611cf3565b6040805160a0810182528481528151606081018352600080825260208281018290528451828152808201865293949085019390830191611ca0565b611c8d611cf3565b815260200190600190039081611c855790505b50905281526040805160008082526020828101909352919092019190611cdc565b611cc9611cf3565b815260200190600190039081611cc15790505b508152600260208201526040019290925250919050565b6040518060a0016040528060008152602001611d0d611d27565b815260606020820181905260006040830181905291015290565b604080516060808201835260008083526020830152918101919091529056fea265627a7a723158206078f193003999a59853266ca3433a60686487efcdb25437112a45a810de61f164736f6c63430005110032"

// DeployMessagesChallenge deploys a new Ethereum contract, binding an instance of MessagesChallenge to it.
func DeployMessagesChallenge(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MessagesChallenge, error) {
	parsed, err := abi.JSON(strings.NewReader(MessagesChallengeABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(MessagesChallengeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MessagesChallenge{MessagesChallengeCaller: MessagesChallengeCaller{contract: contract}, MessagesChallengeTransactor: MessagesChallengeTransactor{contract: contract}, MessagesChallengeFilterer: MessagesChallengeFilterer{contract: contract}}, nil
}

// MessagesChallenge is an auto generated Go binding around an Ethereum contract.
type MessagesChallenge struct {
	MessagesChallengeCaller     // Read-only binding to the contract
	MessagesChallengeTransactor // Write-only binding to the contract
	MessagesChallengeFilterer   // Log filterer for contract events
}

// MessagesChallengeCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessagesChallengeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessagesChallengeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessagesChallengeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessagesChallengeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessagesChallengeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessagesChallengeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessagesChallengeSession struct {
	Contract     *MessagesChallenge // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// MessagesChallengeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessagesChallengeCallerSession struct {
	Contract *MessagesChallengeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// MessagesChallengeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessagesChallengeTransactorSession struct {
	Contract     *MessagesChallengeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// MessagesChallengeRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessagesChallengeRaw struct {
	Contract *MessagesChallenge // Generic contract binding to access the raw methods on
}

// MessagesChallengeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessagesChallengeCallerRaw struct {
	Contract *MessagesChallengeCaller // Generic read-only contract binding to access the raw methods on
}

// MessagesChallengeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessagesChallengeTransactorRaw struct {
	Contract *MessagesChallengeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessagesChallenge creates a new instance of MessagesChallenge, bound to a specific deployed contract.
func NewMessagesChallenge(address common.Address, backend bind.ContractBackend) (*MessagesChallenge, error) {
	contract, err := bindMessagesChallenge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessagesChallenge{MessagesChallengeCaller: MessagesChallengeCaller{contract: contract}, MessagesChallengeTransactor: MessagesChallengeTransactor{contract: contract}, MessagesChallengeFilterer: MessagesChallengeFilterer{contract: contract}}, nil
}

// NewMessagesChallengeCaller creates a new read-only instance of MessagesChallenge, bound to a specific deployed contract.
func NewMessagesChallengeCaller(address common.Address, caller bind.ContractCaller) (*MessagesChallengeCaller, error) {
	contract, err := bindMessagesChallenge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessagesChallengeCaller{contract: contract}, nil
}

// NewMessagesChallengeTransactor creates a new write-only instance of MessagesChallenge, bound to a specific deployed contract.
func NewMessagesChallengeTransactor(address common.Address, transactor bind.ContractTransactor) (*MessagesChallengeTransactor, error) {
	contract, err := bindMessagesChallenge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessagesChallengeTransactor{contract: contract}, nil
}

// NewMessagesChallengeFilterer creates a new log filterer instance of MessagesChallenge, bound to a specific deployed contract.
func NewMessagesChallengeFilterer(address common.Address, filterer bind.ContractFilterer) (*MessagesChallengeFilterer, error) {
	contract, err := bindMessagesChallenge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessagesChallengeFilterer{contract: contract}, nil
}

// bindMessagesChallenge binds a generic wrapper to an already deployed contract.
func bindMessagesChallenge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(MessagesChallengeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessagesChallenge *MessagesChallengeRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _MessagesChallenge.Contract.MessagesChallengeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessagesChallenge *MessagesChallengeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.MessagesChallengeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessagesChallenge *MessagesChallengeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.MessagesChallengeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessagesChallenge *MessagesChallengeCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _MessagesChallenge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessagesChallenge *MessagesChallengeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessagesChallenge *MessagesChallengeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.contract.Transact(opts, method, params...)
}

// Bisect is a paid mutator transaction binding the contract method 0x500439e5.
//
// Solidity: function bisect(bytes32[] _chainHashes, bytes32[] _segmentHashes, uint256 _chainLength) returns()
func (_MessagesChallenge *MessagesChallengeTransactor) Bisect(opts *bind.TransactOpts, _chainHashes [][32]byte, _segmentHashes [][32]byte, _chainLength *big.Int) (*types.Transaction, error) {
	return _MessagesChallenge.contract.Transact(opts, "bisect", _chainHashes, _segmentHashes, _chainLength)
}

// Bisect is a paid mutator transaction binding the contract method 0x500439e5.
//
// Solidity: function bisect(bytes32[] _chainHashes, bytes32[] _segmentHashes, uint256 _chainLength) returns()
func (_MessagesChallenge *MessagesChallengeSession) Bisect(_chainHashes [][32]byte, _segmentHashes [][32]byte, _chainLength *big.Int) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.Bisect(&_MessagesChallenge.TransactOpts, _chainHashes, _segmentHashes, _chainLength)
}

// Bisect is a paid mutator transaction binding the contract method 0x500439e5.
//
// Solidity: function bisect(bytes32[] _chainHashes, bytes32[] _segmentHashes, uint256 _chainLength) returns()
func (_MessagesChallenge *MessagesChallengeTransactorSession) Bisect(_chainHashes [][32]byte, _segmentHashes [][32]byte, _chainLength *big.Int) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.Bisect(&_MessagesChallenge.TransactOpts, _chainHashes, _segmentHashes, _chainLength)
}

// ChooseSegment is a paid mutator transaction binding the contract method 0x79a9ad85.
//
// Solidity: function chooseSegment(uint256 _segmentToChallenge, bytes _proof, bytes32 _bisectionRoot, bytes32 _bisectionHash) returns()
func (_MessagesChallenge *MessagesChallengeTransactor) ChooseSegment(opts *bind.TransactOpts, _segmentToChallenge *big.Int, _proof []byte, _bisectionRoot [32]byte, _bisectionHash [32]byte) (*types.Transaction, error) {
	return _MessagesChallenge.contract.Transact(opts, "chooseSegment", _segmentToChallenge, _proof, _bisectionRoot, _bisectionHash)
}

// ChooseSegment is a paid mutator transaction binding the contract method 0x79a9ad85.
//
// Solidity: function chooseSegment(uint256 _segmentToChallenge, bytes _proof, bytes32 _bisectionRoot, bytes32 _bisectionHash) returns()
func (_MessagesChallenge *MessagesChallengeSession) ChooseSegment(_segmentToChallenge *big.Int, _proof []byte, _bisectionRoot [32]byte, _bisectionHash [32]byte) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.ChooseSegment(&_MessagesChallenge.TransactOpts, _segmentToChallenge, _proof, _bisectionRoot, _bisectionHash)
}

// ChooseSegment is a paid mutator transaction binding the contract method 0x79a9ad85.
//
// Solidity: function chooseSegment(uint256 _segmentToChallenge, bytes _proof, bytes32 _bisectionRoot, bytes32 _bisectionHash) returns()
func (_MessagesChallenge *MessagesChallengeTransactorSession) ChooseSegment(_segmentToChallenge *big.Int, _proof []byte, _bisectionRoot [32]byte, _bisectionHash [32]byte) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.ChooseSegment(&_MessagesChallenge.TransactOpts, _segmentToChallenge, _proof, _bisectionRoot, _bisectionHash)
}

// InitializeBisection is a paid mutator transaction binding the contract method 0x02ad1e4e.
//
// Solidity: function initializeBisection(address _rollupAddress, address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeState) returns()
func (_MessagesChallenge *MessagesChallengeTransactor) InitializeBisection(opts *bind.TransactOpts, _rollupAddress common.Address, _asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeState [32]byte) (*types.Transaction, error) {
	return _MessagesChallenge.contract.Transact(opts, "initializeBisection", _rollupAddress, _asserter, _challenger, _challengePeriodTicks, _challengeState)
}

// InitializeBisection is a paid mutator transaction binding the contract method 0x02ad1e4e.
//
// Solidity: function initializeBisection(address _rollupAddress, address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeState) returns()
func (_MessagesChallenge *MessagesChallengeSession) InitializeBisection(_rollupAddress common.Address, _asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeState [32]byte) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.InitializeBisection(&_MessagesChallenge.TransactOpts, _rollupAddress, _asserter, _challenger, _challengePeriodTicks, _challengeState)
}

// InitializeBisection is a paid mutator transaction binding the contract method 0x02ad1e4e.
//
// Solidity: function initializeBisection(address _rollupAddress, address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeState) returns()
func (_MessagesChallenge *MessagesChallengeTransactorSession) InitializeBisection(_rollupAddress common.Address, _asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeState [32]byte) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.InitializeBisection(&_MessagesChallenge.TransactOpts, _rollupAddress, _asserter, _challenger, _challengePeriodTicks, _challengeState)
}

// OneStepProof is a paid mutator transaction binding the contract method 0x77dec71e.
//
// Solidity: function oneStepProof(bytes32 _afterGlobalInbox, bytes32 _beforeVMInbox, uint8 _kind, uint256 _blockNumber, uint256 _timestamp, address _sender, uint256 _inboxSeqNum, bytes _msgData) returns()
func (_MessagesChallenge *MessagesChallengeTransactor) OneStepProof(opts *bind.TransactOpts, _afterGlobalInbox [32]byte, _beforeVMInbox [32]byte, _kind uint8, _blockNumber *big.Int, _timestamp *big.Int, _sender common.Address, _inboxSeqNum *big.Int, _msgData []byte) (*types.Transaction, error) {
	return _MessagesChallenge.contract.Transact(opts, "oneStepProof", _afterGlobalInbox, _beforeVMInbox, _kind, _blockNumber, _timestamp, _sender, _inboxSeqNum, _msgData)
}

// OneStepProof is a paid mutator transaction binding the contract method 0x77dec71e.
//
// Solidity: function oneStepProof(bytes32 _afterGlobalInbox, bytes32 _beforeVMInbox, uint8 _kind, uint256 _blockNumber, uint256 _timestamp, address _sender, uint256 _inboxSeqNum, bytes _msgData) returns()
func (_MessagesChallenge *MessagesChallengeSession) OneStepProof(_afterGlobalInbox [32]byte, _beforeVMInbox [32]byte, _kind uint8, _blockNumber *big.Int, _timestamp *big.Int, _sender common.Address, _inboxSeqNum *big.Int, _msgData []byte) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.OneStepProof(&_MessagesChallenge.TransactOpts, _afterGlobalInbox, _beforeVMInbox, _kind, _blockNumber, _timestamp, _sender, _inboxSeqNum, _msgData)
}

// OneStepProof is a paid mutator transaction binding the contract method 0x77dec71e.
//
// Solidity: function oneStepProof(bytes32 _afterGlobalInbox, bytes32 _beforeVMInbox, uint8 _kind, uint256 _blockNumber, uint256 _timestamp, address _sender, uint256 _inboxSeqNum, bytes _msgData) returns()
func (_MessagesChallenge *MessagesChallengeTransactorSession) OneStepProof(_afterGlobalInbox [32]byte, _beforeVMInbox [32]byte, _kind uint8, _blockNumber *big.Int, _timestamp *big.Int, _sender common.Address, _inboxSeqNum *big.Int, _msgData []byte) (*types.Transaction, error) {
	return _MessagesChallenge.Contract.OneStepProof(&_MessagesChallenge.TransactOpts, _afterGlobalInbox, _beforeVMInbox, _kind, _blockNumber, _timestamp, _sender, _inboxSeqNum, _msgData)
}

// TimeoutChallenge is a paid mutator transaction binding the contract method 0xced5c1bf.
//
// Solidity: function timeoutChallenge() returns()
func (_MessagesChallenge *MessagesChallengeTransactor) TimeoutChallenge(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessagesChallenge.contract.Transact(opts, "timeoutChallenge")
}

// TimeoutChallenge is a paid mutator transaction binding the contract method 0xced5c1bf.
//
// Solidity: function timeoutChallenge() returns()
func (_MessagesChallenge *MessagesChallengeSession) TimeoutChallenge() (*types.Transaction, error) {
	return _MessagesChallenge.Contract.TimeoutChallenge(&_MessagesChallenge.TransactOpts)
}

// TimeoutChallenge is a paid mutator transaction binding the contract method 0xced5c1bf.
//
// Solidity: function timeoutChallenge() returns()
func (_MessagesChallenge *MessagesChallengeTransactorSession) TimeoutChallenge() (*types.Transaction, error) {
	return _MessagesChallenge.Contract.TimeoutChallenge(&_MessagesChallenge.TransactOpts)
}

// MessagesChallengeAsserterTimedOutIterator is returned from FilterAsserterTimedOut and is used to iterate over the raw logs and unpacked data for AsserterTimedOut events raised by the MessagesChallenge contract.
type MessagesChallengeAsserterTimedOutIterator struct {
	Event *MessagesChallengeAsserterTimedOut // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessagesChallengeAsserterTimedOutIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessagesChallengeAsserterTimedOut)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessagesChallengeAsserterTimedOut)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessagesChallengeAsserterTimedOutIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessagesChallengeAsserterTimedOutIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessagesChallengeAsserterTimedOut represents a AsserterTimedOut event raised by the MessagesChallenge contract.
type MessagesChallengeAsserterTimedOut struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterAsserterTimedOut is a free log retrieval operation binding the contract event 0x2b92a4b014281aa2424baba9ea60bf4f26833d1c1fbd873e51cd1a6caeef48f0.
//
// Solidity: event AsserterTimedOut()
func (_MessagesChallenge *MessagesChallengeFilterer) FilterAsserterTimedOut(opts *bind.FilterOpts) (*MessagesChallengeAsserterTimedOutIterator, error) {

	logs, sub, err := _MessagesChallenge.contract.FilterLogs(opts, "AsserterTimedOut")
	if err != nil {
		return nil, err
	}
	return &MessagesChallengeAsserterTimedOutIterator{contract: _MessagesChallenge.contract, event: "AsserterTimedOut", logs: logs, sub: sub}, nil
}

// WatchAsserterTimedOut is a free log subscription operation binding the contract event 0x2b92a4b014281aa2424baba9ea60bf4f26833d1c1fbd873e51cd1a6caeef48f0.
//
// Solidity: event AsserterTimedOut()
func (_MessagesChallenge *MessagesChallengeFilterer) WatchAsserterTimedOut(opts *bind.WatchOpts, sink chan<- *MessagesChallengeAsserterTimedOut) (event.Subscription, error) {

	logs, sub, err := _MessagesChallenge.contract.WatchLogs(opts, "AsserterTimedOut")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessagesChallengeAsserterTimedOut)
				if err := _MessagesChallenge.contract.UnpackLog(event, "AsserterTimedOut", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAsserterTimedOut is a log parse operation binding the contract event 0x2b92a4b014281aa2424baba9ea60bf4f26833d1c1fbd873e51cd1a6caeef48f0.
//
// Solidity: event AsserterTimedOut()
func (_MessagesChallenge *MessagesChallengeFilterer) ParseAsserterTimedOut(log types.Log) (*MessagesChallengeAsserterTimedOut, error) {
	event := new(MessagesChallengeAsserterTimedOut)
	if err := _MessagesChallenge.contract.UnpackLog(event, "AsserterTimedOut", log); err != nil {
		return nil, err
	}
	return event, nil
}

// MessagesChallengeBisectedIterator is returned from FilterBisected and is used to iterate over the raw logs and unpacked data for Bisected events raised by the MessagesChallenge contract.
type MessagesChallengeBisectedIterator struct {
	Event *MessagesChallengeBisected // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessagesChallengeBisectedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessagesChallengeBisected)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessagesChallengeBisected)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessagesChallengeBisectedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessagesChallengeBisectedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessagesChallengeBisected represents a Bisected event raised by the MessagesChallenge contract.
type MessagesChallengeBisected struct {
	ChainHashes   [][32]byte
	SegmentHashes [][32]byte
	TotalLength   *big.Int
	DeadlineTicks *big.Int
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterBisected is a free log retrieval operation binding the contract event 0x500c4a1bbd12a65d684bde95626a41abdd6a8c5d30f84c5c9b81e5bdb0cc0bd3.
//
// Solidity: event Bisected(bytes32[] chainHashes, bytes32[] segmentHashes, uint256 totalLength, uint256 deadlineTicks)
func (_MessagesChallenge *MessagesChallengeFilterer) FilterBisected(opts *bind.FilterOpts) (*MessagesChallengeBisectedIterator, error) {

	logs, sub, err := _MessagesChallenge.contract.FilterLogs(opts, "Bisected")
	if err != nil {
		return nil, err
	}
	return &MessagesChallengeBisectedIterator{contract: _MessagesChallenge.contract, event: "Bisected", logs: logs, sub: sub}, nil
}

// WatchBisected is a free log subscription operation binding the contract event 0x500c4a1bbd12a65d684bde95626a41abdd6a8c5d30f84c5c9b81e5bdb0cc0bd3.
//
// Solidity: event Bisected(bytes32[] chainHashes, bytes32[] segmentHashes, uint256 totalLength, uint256 deadlineTicks)
func (_MessagesChallenge *MessagesChallengeFilterer) WatchBisected(opts *bind.WatchOpts, sink chan<- *MessagesChallengeBisected) (event.Subscription, error) {

	logs, sub, err := _MessagesChallenge.contract.WatchLogs(opts, "Bisected")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessagesChallengeBisected)
				if err := _MessagesChallenge.contract.UnpackLog(event, "Bisected", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBisected is a log parse operation binding the contract event 0x500c4a1bbd12a65d684bde95626a41abdd6a8c5d30f84c5c9b81e5bdb0cc0bd3.
//
// Solidity: event Bisected(bytes32[] chainHashes, bytes32[] segmentHashes, uint256 totalLength, uint256 deadlineTicks)
func (_MessagesChallenge *MessagesChallengeFilterer) ParseBisected(log types.Log) (*MessagesChallengeBisected, error) {
	event := new(MessagesChallengeBisected)
	if err := _MessagesChallenge.contract.UnpackLog(event, "Bisected", log); err != nil {
		return nil, err
	}
	return event, nil
}

// MessagesChallengeChallengerTimedOutIterator is returned from FilterChallengerTimedOut and is used to iterate over the raw logs and unpacked data for ChallengerTimedOut events raised by the MessagesChallenge contract.
type MessagesChallengeChallengerTimedOutIterator struct {
	Event *MessagesChallengeChallengerTimedOut // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessagesChallengeChallengerTimedOutIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessagesChallengeChallengerTimedOut)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessagesChallengeChallengerTimedOut)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessagesChallengeChallengerTimedOutIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessagesChallengeChallengerTimedOutIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessagesChallengeChallengerTimedOut represents a ChallengerTimedOut event raised by the MessagesChallenge contract.
type MessagesChallengeChallengerTimedOut struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterChallengerTimedOut is a free log retrieval operation binding the contract event 0x4e1f1f06cf69d199fcdb4d87a5a92d5248ca6b540e9fc2d3698927c5002a236a.
//
// Solidity: event ChallengerTimedOut()
func (_MessagesChallenge *MessagesChallengeFilterer) FilterChallengerTimedOut(opts *bind.FilterOpts) (*MessagesChallengeChallengerTimedOutIterator, error) {

	logs, sub, err := _MessagesChallenge.contract.FilterLogs(opts, "ChallengerTimedOut")
	if err != nil {
		return nil, err
	}
	return &MessagesChallengeChallengerTimedOutIterator{contract: _MessagesChallenge.contract, event: "ChallengerTimedOut", logs: logs, sub: sub}, nil
}

// WatchChallengerTimedOut is a free log subscription operation binding the contract event 0x4e1f1f06cf69d199fcdb4d87a5a92d5248ca6b540e9fc2d3698927c5002a236a.
//
// Solidity: event ChallengerTimedOut()
func (_MessagesChallenge *MessagesChallengeFilterer) WatchChallengerTimedOut(opts *bind.WatchOpts, sink chan<- *MessagesChallengeChallengerTimedOut) (event.Subscription, error) {

	logs, sub, err := _MessagesChallenge.contract.WatchLogs(opts, "ChallengerTimedOut")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessagesChallengeChallengerTimedOut)
				if err := _MessagesChallenge.contract.UnpackLog(event, "ChallengerTimedOut", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChallengerTimedOut is a log parse operation binding the contract event 0x4e1f1f06cf69d199fcdb4d87a5a92d5248ca6b540e9fc2d3698927c5002a236a.
//
// Solidity: event ChallengerTimedOut()
func (_MessagesChallenge *MessagesChallengeFilterer) ParseChallengerTimedOut(log types.Log) (*MessagesChallengeChallengerTimedOut, error) {
	event := new(MessagesChallengeChallengerTimedOut)
	if err := _MessagesChallenge.contract.UnpackLog(event, "ChallengerTimedOut", log); err != nil {
		return nil, err
	}
	return event, nil
}

// MessagesChallengeContinuedIterator is returned from FilterContinued and is used to iterate over the raw logs and unpacked data for Continued events raised by the MessagesChallenge contract.
type MessagesChallengeContinuedIterator struct {
	Event *MessagesChallengeContinued // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessagesChallengeContinuedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessagesChallengeContinued)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessagesChallengeContinued)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessagesChallengeContinuedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessagesChallengeContinuedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessagesChallengeContinued represents a Continued event raised by the MessagesChallenge contract.
type MessagesChallengeContinued struct {
	SegmentIndex  *big.Int
	DeadlineTicks *big.Int
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterContinued is a free log retrieval operation binding the contract event 0x1e1c1e4e68a25c69a078a396e73975691c071d69ef789015dc16a562957804e4.
//
// Solidity: event Continued(uint256 segmentIndex, uint256 deadlineTicks)
func (_MessagesChallenge *MessagesChallengeFilterer) FilterContinued(opts *bind.FilterOpts) (*MessagesChallengeContinuedIterator, error) {

	logs, sub, err := _MessagesChallenge.contract.FilterLogs(opts, "Continued")
	if err != nil {
		return nil, err
	}
	return &MessagesChallengeContinuedIterator{contract: _MessagesChallenge.contract, event: "Continued", logs: logs, sub: sub}, nil
}

// WatchContinued is a free log subscription operation binding the contract event 0x1e1c1e4e68a25c69a078a396e73975691c071d69ef789015dc16a562957804e4.
//
// Solidity: event Continued(uint256 segmentIndex, uint256 deadlineTicks)
func (_MessagesChallenge *MessagesChallengeFilterer) WatchContinued(opts *bind.WatchOpts, sink chan<- *MessagesChallengeContinued) (event.Subscription, error) {

	logs, sub, err := _MessagesChallenge.contract.WatchLogs(opts, "Continued")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessagesChallengeContinued)
				if err := _MessagesChallenge.contract.UnpackLog(event, "Continued", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseContinued is a log parse operation binding the contract event 0x1e1c1e4e68a25c69a078a396e73975691c071d69ef789015dc16a562957804e4.
//
// Solidity: event Continued(uint256 segmentIndex, uint256 deadlineTicks)
func (_MessagesChallenge *MessagesChallengeFilterer) ParseContinued(log types.Log) (*MessagesChallengeContinued, error) {
	event := new(MessagesChallengeContinued)
	if err := _MessagesChallenge.contract.UnpackLog(event, "Continued", log); err != nil {
		return nil, err
	}
	return event, nil
}

// MessagesChallengeInitiatedChallengeIterator is returned from FilterInitiatedChallenge and is used to iterate over the raw logs and unpacked data for InitiatedChallenge events raised by the MessagesChallenge contract.
type MessagesChallengeInitiatedChallengeIterator struct {
	Event *MessagesChallengeInitiatedChallenge // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessagesChallengeInitiatedChallengeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessagesChallengeInitiatedChallenge)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessagesChallengeInitiatedChallenge)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessagesChallengeInitiatedChallengeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessagesChallengeInitiatedChallengeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessagesChallengeInitiatedChallenge represents a InitiatedChallenge event raised by the MessagesChallenge contract.
type MessagesChallengeInitiatedChallenge struct {
	DeadlineTicks *big.Int
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterInitiatedChallenge is a free log retrieval operation binding the contract event 0xe070f23072cbc6c0fc7253b8d0120649d5f9d6e19a8aeab79eb50aa6360bcc67.
//
// Solidity: event InitiatedChallenge(uint256 deadlineTicks)
func (_MessagesChallenge *MessagesChallengeFilterer) FilterInitiatedChallenge(opts *bind.FilterOpts) (*MessagesChallengeInitiatedChallengeIterator, error) {

	logs, sub, err := _MessagesChallenge.contract.FilterLogs(opts, "InitiatedChallenge")
	if err != nil {
		return nil, err
	}
	return &MessagesChallengeInitiatedChallengeIterator{contract: _MessagesChallenge.contract, event: "InitiatedChallenge", logs: logs, sub: sub}, nil
}

// WatchInitiatedChallenge is a free log subscription operation binding the contract event 0xe070f23072cbc6c0fc7253b8d0120649d5f9d6e19a8aeab79eb50aa6360bcc67.
//
// Solidity: event InitiatedChallenge(uint256 deadlineTicks)
func (_MessagesChallenge *MessagesChallengeFilterer) WatchInitiatedChallenge(opts *bind.WatchOpts, sink chan<- *MessagesChallengeInitiatedChallenge) (event.Subscription, error) {

	logs, sub, err := _MessagesChallenge.contract.WatchLogs(opts, "InitiatedChallenge")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessagesChallengeInitiatedChallenge)
				if err := _MessagesChallenge.contract.UnpackLog(event, "InitiatedChallenge", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitiatedChallenge is a log parse operation binding the contract event 0xe070f23072cbc6c0fc7253b8d0120649d5f9d6e19a8aeab79eb50aa6360bcc67.
//
// Solidity: event InitiatedChallenge(uint256 deadlineTicks)
func (_MessagesChallenge *MessagesChallengeFilterer) ParseInitiatedChallenge(log types.Log) (*MessagesChallengeInitiatedChallenge, error) {
	event := new(MessagesChallengeInitiatedChallenge)
	if err := _MessagesChallenge.contract.UnpackLog(event, "InitiatedChallenge", log); err != nil {
		return nil, err
	}
	return event, nil
}

// MessagesChallengeOneStepProofCompletedIterator is returned from FilterOneStepProofCompleted and is used to iterate over the raw logs and unpacked data for OneStepProofCompleted events raised by the MessagesChallenge contract.
type MessagesChallengeOneStepProofCompletedIterator struct {
	Event *MessagesChallengeOneStepProofCompleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessagesChallengeOneStepProofCompletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessagesChallengeOneStepProofCompleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessagesChallengeOneStepProofCompleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessagesChallengeOneStepProofCompletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessagesChallengeOneStepProofCompletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessagesChallengeOneStepProofCompleted represents a OneStepProofCompleted event raised by the MessagesChallenge contract.
type MessagesChallengeOneStepProofCompleted struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOneStepProofCompleted is a free log retrieval operation binding the contract event 0x117efdf1fdd8be5a6ff0fb3c32333d7033bbd9523924bd0d9ca28f43540516f5.
//
// Solidity: event OneStepProofCompleted()
func (_MessagesChallenge *MessagesChallengeFilterer) FilterOneStepProofCompleted(opts *bind.FilterOpts) (*MessagesChallengeOneStepProofCompletedIterator, error) {

	logs, sub, err := _MessagesChallenge.contract.FilterLogs(opts, "OneStepProofCompleted")
	if err != nil {
		return nil, err
	}
	return &MessagesChallengeOneStepProofCompletedIterator{contract: _MessagesChallenge.contract, event: "OneStepProofCompleted", logs: logs, sub: sub}, nil
}

// WatchOneStepProofCompleted is a free log subscription operation binding the contract event 0x117efdf1fdd8be5a6ff0fb3c32333d7033bbd9523924bd0d9ca28f43540516f5.
//
// Solidity: event OneStepProofCompleted()
func (_MessagesChallenge *MessagesChallengeFilterer) WatchOneStepProofCompleted(opts *bind.WatchOpts, sink chan<- *MessagesChallengeOneStepProofCompleted) (event.Subscription, error) {

	logs, sub, err := _MessagesChallenge.contract.WatchLogs(opts, "OneStepProofCompleted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessagesChallengeOneStepProofCompleted)
				if err := _MessagesChallenge.contract.UnpackLog(event, "OneStepProofCompleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOneStepProofCompleted is a log parse operation binding the contract event 0x117efdf1fdd8be5a6ff0fb3c32333d7033bbd9523924bd0d9ca28f43540516f5.
//
// Solidity: event OneStepProofCompleted()
func (_MessagesChallenge *MessagesChallengeFilterer) ParseOneStepProofCompleted(log types.Log) (*MessagesChallengeOneStepProofCompleted, error) {
	event := new(MessagesChallengeOneStepProofCompleted)
	if err := _MessagesChallenge.contract.UnpackLog(event, "OneStepProofCompleted", log); err != nil {
		return nil, err
	}
	return event, nil
}
