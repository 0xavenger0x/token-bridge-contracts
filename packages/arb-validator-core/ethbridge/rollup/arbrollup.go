// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package rollup

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// ArbRollupABI is the input ABI used to generate the binding from.
const ArbRollupABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"logsAccHash\",\"type\":\"bytes32[]\"}],\"name\":\"ConfirmedAssertion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"ConfirmedValidAssertion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[8]\",\"name\":\"fields\",\"type\":\"bytes32[8]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inboxCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"importedMessageCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[4]\",\"name\":\"timeBounds\",\"type\":\"uint128[4]\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numArbGas\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numSteps\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didInboxInsn\",\"type\":\"bool\"}],\"name\":\"RollupAsserted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"}],\"name\":\"RollupChallengeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asserter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"}],\"name\":\"RollupChallengeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"initVMHash\",\"type\":\"bytes32\"}],\"name\":\"RollupCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"RollupPruned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"toNodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeMoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"RollupStakeRefunded\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeFactory\",\"outputs\":[{\"internalType\":\"contractIChallengeFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"initalProtoStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"branches\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"deadlineTicks\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"challengeNodeData\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"logsAcc\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"vmProtoStateHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"messageCounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"messages\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"stakerAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"stakerProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakerProofOffsets\",\"type\":\"uint256[]\"}],\"name\":\"confirm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"forwardContractMessage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakeRequired\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalInbox\",\"outputs\":[{\"internalType\":\"contractIGlobalInbox\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_vmState\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"_gracePeriodTicks\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_arbGasSpeedLimitPerTick\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"_maxExecutionSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint64[2]\",\"name\":\"_maxTimeBoundsWidth\",\"type\":\"uint64[2]\"},{\"internalType\":\"uint128\",\"name\":\"_stakeRequirement\",\"type\":\"uint128\"},{\"internalType\":\"addresspayable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_challengeFactoryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_globalInboxAddress\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakerAddress\",\"type\":\"address\"}],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"isValidLeaf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestConfirmed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[9]\",\"name\":\"_fields\",\"type\":\"bytes32[9]\"},{\"internalType\":\"uint256\",\"name\":\"_beforeInboxCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_prevDeadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_prevChildType\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"_numSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint128[4]\",\"name\":\"_timeBounds\",\"type\":\"uint128[4]\"},{\"internalType\":\"uint256\",\"name\":\"_importedMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_didInboxInsn\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"_numArbGas\",\"type\":\"uint64\"},{\"internalType\":\"bytes32[]\",\"name\":\"_stakerProof\",\"type\":\"bytes32[]\"}],\"name\":\"makeAssertion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof1\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof2\",\"type\":\"bytes32[]\"}],\"name\":\"moveStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"addresspayable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerShutdown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof1\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof2\",\"type\":\"bytes32[]\"}],\"name\":\"placeStake\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"fromNodes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"leafProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"leafProofLengths\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"latestConfProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"latestConfirmedProofLengths\",\"type\":\"uint256[]\"}],\"name\":\"pruneLeaves\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakeConfirmed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"latestConfirmedProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"stakerProof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakeMooted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakeOld\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"disputableNodeHashVal\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"childType\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"vmProtoStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakePassedDeadline\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resolveChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_arbContract\",\"type\":\"address\"}],\"name\":\"spawnCallProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"asserterAddress\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"challengerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"prevNode\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"stakerNodeTypes\",\"type\":\"uint256[2]\"},{\"internalType\":\"bytes32[2]\",\"name\":\"vmProtoHashes\",\"type\":\"bytes32[2]\"},{\"internalType\":\"bytes32[]\",\"name\":\"asserterProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"challengerProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"asserterNodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"challengerDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"challengerPeriodTicks\",\"type\":\"uint128\"}],\"name\":\"startChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vmParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gracePeriodTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arbGasSpeedLimitPerTick\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"maxExecutionSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxBlockBoundsWidth\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxTimestampBoundsWidth\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ArbRollupFuncSigs maps the 4-byte function signature to its string representation.
var ArbRollupFuncSigs = map[string]string{
	"ffa1ad74": "VERSION()",
	"5dbaf68b": "challengeFactory()",
	"1a072771": "confirm(bytes32,uint256[],uint256[],bytes32[],bytes32[],bytes32[],uint256[],bytes,address[],bytes32[],uint256[])",
	"c5818317": "forwardContractMessage(address,bytes)",
	"d16c305d": "getStakeRequired()",
	"d489113a": "globalInbox()",
	"8e0f7167": "init(bytes32,uint128,uint128,uint64,uint64[2],uint128,address,address,address)",
	"6177fd18": "isStaked(address)",
	"57ca6d1b": "isValidLeaf(bytes32)",
	"65f7f80d": "latestConfirmed()",
	"a7067556": "makeAssertion(bytes32[9],uint256,uint256,uint32,uint64,uint128[4],uint256,bool,uint64,bytes32[])",
	"dbad0a39": "moveStake(bytes32[],bytes32[])",
	"8da5cb5b": "owner()",
	"cfa80707": "ownerShutdown()",
	"e0620d64": "placeStake(bytes32[],bytes32[])",
	"fcfd8d3f": "pruneLeaves(bytes32[],bytes32[],uint256[],bytes32[],uint256[])",
	"7cfaaf67": "recoverStakeConfirmed(bytes32[])",
	"33554032": "recoverStakeMooted(address,bytes32,bytes32[],bytes32[])",
	"113ec9d8": "recoverStakeOld(address,bytes32[])",
	"badb3f14": "recoverStakePassedDeadline(address,uint256,bytes32,uint256,bytes32,bytes32[])",
	"6bc3cd22": "resolveChallenge(address,address,uint256)",
	"f75e4866": "spawnCallProxy(address)",
	"bac5963f": "startChallenge(address,address,bytes32,uint256,uint256[2],bytes32[2],bytes32[],bytes32[],bytes32,bytes32,uint128)",
	"b7ff920e": "supportedContracts(address)",
	"bbc2cc00": "vmParams()",
}

// ArbRollupBin is the compiled bytecode used for deploying new contracts.
var ArbRollupBin = "0x608060405234801561001057600080fd5b5061559a806100206000396000f3fe6080604052600436106101665760003560e01c8063b7ff920e116100d1578063d16c305d1161008a578063e0620d6411610064578063e0620d6414610f90578063f75e48661461104e578063fcfd8d3f14611081578063ffa1ad741461133757610166565b8063d16c305d14610e7f578063d489113a14610eb0578063dbad0a3914610ec557610166565b8063b7ff920e14610b0b578063bac5963f14610b3e578063badb3f1414610cfd578063bbc2cc0014610da0578063c581831714610dec578063cfa8070714610e6a57610166565b806365f7f80d1161012357806365f7f80d146108c55780636bc3cd22146108ec5780637cfaaf671461092f5780638da5cb5b146109aa5780638e0f7167146109bf578063a706755614610a4057610166565b8063113ec9d81461016b5780631a072771146101f8578063335540321461074357806357ca6d1b146108235780635dbaf68b146108615780636177fd1814610892575b600080fd5b34801561017757600080fd5b506101f66004803603604081101561018e57600080fd5b6001600160a01b038235169190810190604081016020820135600160201b8111156101b857600080fd5b8201836020820111156101ca57600080fd5b803590602001918460208302840111600160201b831117156101eb57600080fd5b5090925090506113c1565b005b34801561020457600080fd5b506101f6600480360361016081101561021c57600080fd5b81359190810190604081016020820135600160201b81111561023d57600080fd5b82018360208201111561024f57600080fd5b803590602001918460208302840111600160201b8311171561027057600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156102bf57600080fd5b8201836020820111156102d157600080fd5b803590602001918460208302840111600160201b831117156102f257600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561034157600080fd5b82018360208201111561035357600080fd5b803590602001918460208302840111600160201b8311171561037457600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156103c357600080fd5b8201836020820111156103d557600080fd5b803590602001918460208302840111600160201b831117156103f657600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561044557600080fd5b82018360208201111561045757600080fd5b803590602001918460208302840111600160201b8311171561047857600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156104c757600080fd5b8201836020820111156104d957600080fd5b803590602001918460208302840111600160201b831117156104fa57600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561054957600080fd5b82018360208201111561055b57600080fd5b803590602001918460018302840111600160201b8311171561057c57600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b8111156105ce57600080fd5b8201836020820111156105e057600080fd5b803590602001918460208302840111600160201b8311171561060157600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561065057600080fd5b82018360208201111561066257600080fd5b803590602001918460208302840111600160201b8311171561068357600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156106d257600080fd5b8201836020820111156106e457600080fd5b803590602001918460208302840111600160201b8311171561070557600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295506114b2945050505050565b34801561074f57600080fd5b506101f66004803603608081101561076657600080fd5b6001600160a01b0382351691602081013591810190606081016040820135600160201b81111561079557600080fd5b8201836020820111156107a757600080fd5b803590602001918460208302840111600160201b831117156107c857600080fd5b919390929091602081019035600160201b8111156107e557600080fd5b8201836020820111156107f757600080fd5b803590602001918460208302840111600160201b8311171561081857600080fd5b509092509050611504565b34801561082f57600080fd5b5061084d6004803603602081101561084657600080fd5b503561165c565b604080519115158252519081900360200190f35b34801561086d57600080fd5b50610876611674565b604080516001600160a01b039092168252519081900360200190f35b34801561089e57600080fd5b5061084d600480360360208110156108b557600080fd5b50356001600160a01b0316611683565b3480156108d157600080fd5b506108da6116a0565b60408051918252519081900360200190f35b3480156108f857600080fd5b506101f66004803603606081101561090f57600080fd5b506001600160a01b038135811691602081013590911690604001356116a6565b34801561093b57600080fd5b506101f66004803603602081101561095257600080fd5b810190602081018135600160201b81111561096c57600080fd5b82018360208201111561097e57600080fd5b803590602001918460208302840111600160201b8311171561099f57600080fd5b509092509050611802565b3480156109b657600080fd5b50610876611843565b3480156109cb57600080fd5b506101f660048036036101408110156109e357600080fd5b508035906001600160801b03602082013581169160408101358216916001600160401b0360608301351691608081019160c082013516906001600160a01b0360e08201358116916101008101358216916101209091013516611852565b348015610a4c57600080fd5b506101f660048036036102a0811015610a6457600080fd5b610120820135906101408301359063ffffffff61016085013516906001600160401b036101808601358116916101a0870191610220880135916102408901351515916102608a013516908901896102a08101610280820135600160201b811115610acd57600080fd5b820183602082011115610adf57600080fd5b803590602001918460208302840111600160201b83111715610b0057600080fd5b5090925090506118be565b348015610b1757600080fd5b5061087660048036036020811015610b2e57600080fd5b50356001600160a01b0316611aa8565b348015610b4a57600080fd5b506101f660048036036101a0811015610b6257600080fd5b6040805180820182526001600160a01b0384358116946020810135909116938382013593606083013593918301929160c083019160808401906002908390839080828437600092019190915250506040805180820182529295949381810193925090600290839083908082843760009201919091525091949392602081019250359050600160201b811115610bf657600080fd5b820183602082011115610c0857600080fd5b803590602001918460208302840111600160201b83111715610c2957600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b811115610c7857600080fd5b820183602082011115610c8a57600080fd5b803590602001918460208302840111600160201b83111715610cab57600080fd5b91908080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525092955050823593505050602081013590604001356001600160801b0316611ac3565b348015610d0957600080fd5b506101f6600480360360c0811015610d2057600080fd5b6001600160a01b03823516916020810135916040820135916060810135916080820135919081019060c0810160a0820135600160201b811115610d6257600080fd5b820183602082011115610d7457600080fd5b803590602001918460208302840111600160201b83111715610d9557600080fd5b509092509050611ef5565b348015610dac57600080fd5b50610db5612070565b6040805195865260208601949094526001600160401b03928316858501529082166060850152166080830152519081900360a00190f35b6101f660048036036040811015610e0257600080fd5b6001600160a01b038235169190810190604081016020820135600160201b811115610e2c57600080fd5b820183602082011115610e3e57600080fd5b803590602001918460018302840111600160201b83111715610e5f57600080fd5b50909250905061209b565b348015610e7657600080fd5b506101f6612215565b348015610e8b57600080fd5b50610e94612294565b604080516001600160801b039092168252519081900360200190f35b348015610ebc57600080fd5b506108766122a3565b348015610ed157600080fd5b506101f660048036036040811015610ee857600080fd5b810190602081018135600160201b811115610f0257600080fd5b820183602082011115610f1457600080fd5b803590602001918460208302840111600160201b83111715610f3557600080fd5b919390929091602081019035600160201b811115610f5257600080fd5b820183602082011115610f6457600080fd5b803590602001918460208302840111600160201b83111715610f8557600080fd5b5090925090506122b2565b6101f660048036036040811015610fa657600080fd5b810190602081018135600160201b811115610fc057600080fd5b820183602082011115610fd257600080fd5b803590602001918460208302840111600160201b83111715610ff357600080fd5b919390929091602081019035600160201b81111561101057600080fd5b82018360208201111561102257600080fd5b803590602001918460208302840111600160201b8311171561104357600080fd5b5090925090506123c3565b34801561105a57600080fd5b506101f66004803603602081101561107157600080fd5b50356001600160a01b03166124d6565b34801561108d57600080fd5b506101f6600480360360a08110156110a457600080fd5b810190602081018135600160201b8111156110be57600080fd5b8201836020820111156110d057600080fd5b803590602001918460208302840111600160201b831117156110f157600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561114057600080fd5b82018360208201111561115257600080fd5b803590602001918460208302840111600160201b8311171561117357600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156111c257600080fd5b8201836020820111156111d457600080fd5b803590602001918460208302840111600160201b831117156111f557600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561124457600080fd5b82018360208201111561125657600080fd5b803590602001918460208302840111600160201b8311171561127757600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156112c657600080fd5b8201836020820111156112d857600080fd5b803590602001918460208302840111600160201b831117156112f957600080fd5b91908080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525092955061255f945050505050565b34801561134357600080fd5b5061134c612628565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561138657818101518382015260200161136e565b50505050905090810190601f1680156113b35780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b60408051808201909152600e81526d0a48a86ac9e9888be988a9c8ea8960931b60208201528161146f5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561143457818101518382015260200161141c565b50505050905090810190601f1680156114615780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b506114ad8383838080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061264b92505050565b505050565b6114f76040518061010001604052808d81526020018c81526020018b81526020018a8152602001898152602001888152602001878152602001868152508484846126ea565b5050505050505050505050565b600061150f33612a85565b90508282600081811061151e57fe5b905060200201358585600081811061153257fe5b9050602002013514158015611589575061154a6116a0565b61158787878780806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612b1592505050565b145b80156115d05750806115ce87858580806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612b1592505050565b145b604051806040016040528060148152602001732922a1a7ab2fa1a7a7232624a1aa2fa82927a7a360611b815250906116495760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5061165387612b2c565b50505050505050565b60008181526004602052604090205460ff165b919050565b6006546001600160a01b031681565b6001600160a01b0316600090815260086020526040902054151590565b60055490565b336000908152600a6020908152604091829020548251808401909352600f83526e2922a9afa1a420a62fa9a2a72222a960891b9183019190915260ff1661172e5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b50336000908152600a60205260408120805460ff1916905561174f84612bb5565b6007546040519192506001600160a01b0386169160026001600160801b039283160490911680156108fc02916000818181858888f1935050505015801561179a573d6000803e3d6000fd5b5060018101805460ff60801b191690556117b383612c3f565b604080513381526001600160a01b03808716602083015285168183015290517f468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f299181900360600190a150505050565b61183f3383838080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061264b92505050565b5050565b600b546001600160a01b031681565b61188a89898989896002806020026040519081016040528092919082600260200280828437600092019190915250889150612c809050565b6118948483612d93565b5050600b80546001600160a01b0319166001600160a01b0392909216919091179055505050505050565b6118c66152cf565b60408051610220810182528d3581526020808f0135908201528082018d9052908d01356060820152608081018b905260a081018d6003602002013581526020018a63ffffffff168152602001896001600160401b03168152602001886004806020026040519081016040528092919082600460200280828437600092019190915250505081526020810188905260808e810135604083015260a08f01356060830152018d6006602002013581526020018615158152602001856001600160401b031681526020018d60076009811061199a57fe5b602002013581526020018d6008600981106119b157fe5b6020020135905290506000806119c683612ec9565b9150915060006119d533612a85565b905082611a1582888880806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612b1592505050565b146040518060400160405280601181526020017026a0a5a2afa9aa20a5a2a92fa82927a7a360791b81525090611a8c5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b50611a9733836130b2565b505050505050505050505050505050565b600d602052600090815260409020546001600160a01b031681565b6000611ace8c612bb5565b90506000611adb8c612bb5565b60018301549091508a90611af7906001600160801b031661310b565b106040518060400160405280600d81526020016c53544b315f444541444c494e4560981b81525090611b6a5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5060018101548a90611b84906001600160801b031661310b565b106040518060400160405280600d81526020016c53544b325f444541444c494e4560981b81525090611bf75760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b50600182015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff1615611c775760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b50600181015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff1615611cf75760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b506020808a01518a5160408051808201909152600a8152692a2ca822afa7a92222a960b11b9381019390935211611d6f5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b508154611d97611d918d8d898e600060200201518e60005b6020020151613112565b89612b15565b146040518060400160405280600c81526020016b20a9a9a2a92a2fa82927a7a360a11b81525090611e095760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b508054611e3a611e348d8d611e27896001600160801b038a1661317a565b60208f01518e6001611d87565b88612b15565b146040518060400160405280600a81526020016921a420a62fa82927a7a360b11b81525090611eaa5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5060018281018054600160801b60ff60801b19918216811790925591830180549092161790556020890151611ee6908e908e90869088906131a6565b50505050505050505050505050565b6000611f0033612a85565b90506000611f118289898989613112565b90506000611f5282868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612b1592505050565b9050611f5d8161165c565b604051806040016040528060138152602001722922a1a7ab2fa222a0a22624a722afa622a0a360691b81525090611fd55760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b50611fdf8961310b565b431015604051806040016040528060138152602001725245434f565f444541444c494e455f54494d4560681b8152509061205a5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b506120648a612b2c565b50505050505050505050565b6001546002546003546001600160401b0380821691600160401b8104821691600160801b9091041685565b336000908152600c60205260409020546001600160a01b0316806120f05760405162461bcd60e51b815260040180806020018281038252602981526020018061553d6029913960400191505060405180910390fd5b60008054604080516396588a2760e01b81526001600160a01b0385811660048301528881166024830152915191909216926396588a279234926044808301939282900301818588803b15801561214557600080fd5b505af1158015612159573d6000803e3d6000fd5b50506000546040516384cb799760e01b81526001600160a01b03868116600483019081528a821660248401523460448401819052608060648501908152608485018b90529290941696506384cb799795508794508a93928a928a929160a401848480828437600081840152601f19601f8201169050808301925050509650505050505050600060405180830381600087803b1580156121f757600080fd5b505af115801561220b573d6000803e3d6000fd5b5050505050505050565b600b5460408051808201909152600a81526927a7262cafa7aba722a960b11b6020820152906001600160a01b031633146122905760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5033ff5b6007546001600160801b031690565b6000546001600160a01b031681565b60006122bd33612a85565b905060006122fe82878780806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612b1592505050565b9050600061233f82868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612b1592505050565b905061234a8161165c565b6040518060400160405280600981526020016826a7ab22afa622a0a360b91b815250906123b85760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5061165333836130b2565b60006124096123d06116a0565b868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612b1592505050565b9050600061244a82858580806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612b1592505050565b90506124558161165c565b6040518060400160405280600a815260200169282620a1a2afa622a0a360b11b815250906124c45760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b506124ce826132c4565b505050505050565b6000306040516124e59061535c565b6001600160a01b03909116815260405190819003602001906000f080158015612512573d6000803e3d6000fd5b506001600160a01b039081166000818152600c602090815260408083208054959097166001600160a01b03199586168117909755958252600d905293909320805490911690921790915550565b84518351811480156125715750808251145b6125bb576040805162461bcd60e51b81526020600482015260166024820152750d2dce0eae840d8cadccee8d040dad2e6e8dac2e8c6d60531b604482015290519081900360640190fd5b600080805b8381101561261d576126108982815181106125d757fe5b60200260200101518683815181106125eb57fe5b60200260200101518984815181106125ff57fe5b60200260200101518b8a8888613472565b90935091506001016125c0565b505050505050505050565b604051806040016040528060078152602001660646576656c6f760cc1b81525081565b600061265633612a85565b90506126606116a0565b61266a8284612b15565b146040518060400160405280601081526020016f2922a1a7ab2fa820aa242fa82927a7a360811b815250906126e05760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b506114ad83612b2c565b60208401515160408501518051600019830190811061270557fe5b60200260200101516127164361310b565b101560405180604001604052806009815260200168434f4e465f54494d4560b81b815250906127865760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b506060600061279c876127976116a0565b61363b565b8151919350915060005b818110156127f6578381815181106127ba57fe5b60200260200101517f89cc5e236414c34f1206c0c14d8ac5b0e5444b669b309aaca16fe3d27749f50e60405160405180910390a26001016127a6565b506000612820838a60400151600188038151811061281057fe5b60200260200101518a8a8a6136f8565b9050600081116040518060400160405280600f81526020016e21a7a7232fa420a9afa9aa20a5a2a960891b8152509061289a5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b506128a483613872565b6000805460e08b015160c08c015160405163072fd2bb60e01b81526060600482019081528351606483015283516001600160a01b039095169563072fd2bb958b938392602482019260448301926084019160208a0191908190849084905b8381101561291a578181015183820152602001612902565b50505050905090810190601f1680156129475780820380516001836020036101000a031916815260200191505b508481038352865181528651602091820191808901910280838360005b8381101561297c578181015183820152602001612964565b50505050905001848103825285818151815260200191508051906020019060200280838360005b838110156129bb5781810151838201526020016129a3565b505050509050019650505050505050600060405180830381600087803b1580156129e457600080fd5b505af11580156129f8573d6000803e3d6000fd5b50505050600082111561261d57608089015160408051602080825283518183015283517fded5fa103431438087188a5f8c6a4c3ea90996bbd63be7b1b3fa0a425b37fdd59493839290830191818601910280838360005b83811015612a67578181015183820152602001612a4f565b505050509050019250505060405180910390a1505050505050505050565b6001600160a01b0381166000908152600860209081526040808320548151808301909252600a82526924a72b2fa9aa20a5a2a960b11b9282019290925281612b0e5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5092915050565b6000612b258383600085516138ad565b9392505050565b612b3581612c3f565b6007546040516001600160a01b038316916001600160801b031680156108fc02916000818181858888f19350505050158015612b75573d6000803e3d6000fd5b50604080516001600160a01b038316815290517f953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c9181900360200190a150565b6001600160a01b038116600090815260086020908152604080832080548251808401909352600a83526924a72b2fa9aa20a5a2a960b11b9383019390935291612b0e5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b6001600160a01b03166000908152600860205260408120908155600101805470ffffffffffffffffffffffffffffffffff1916905560098054600019019055565b600080546001600160a01b0319166001600160a01b038316178155612cae87612ca7613917565b6000613938565b90506000612cbf8180808086613112565b60058190556000818152600460209081526040918290208054600160ff1990911681179091556001600160801b038b81169091558916600255600380548851898401516001600160401b03918216600160401b0267ffffffffffffffff199093168c8316176fffffffffffffffff000000000000000019169290921767ffffffffffffffff60801b1916600160801b919092160217905581518b815291519293507f4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d92918290030190a15050505050505050565b60065460408051808201909152600a815269494e49545f545749434560b01b6020820152906001600160a01b031615612e0d5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5060408051808201909152600c81526b494e49545f4e4f4e5a45524f60a01b60208201526001600160a01b038216612e865760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b50600680546001600160a01b0319166001600160a01b0392909216919091179055600780546001600160801b0319166001600160801b0392909216919091179055565b600080600080612ed88561396f565b91509150612ee58261165c565b6040518060400160405280600981526020016826a0a5a2afa622a0a360b91b81525090612f535760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b50612f5d856139bd565b6000805460408051630220168160e01b8152306004820152815184936001600160a01b03169263022016819260248082019391829003018186803b158015612fa457600080fd5b505afa158015612fb8573d6000803e3d6000fd5b505050506040513d6040811015612fce57600080fd5b50805160209091015160408901519193509150612ff290829063ffffffff613c5d16565b87610120015111156040518060400160405280601081526020016f135052d157d35154d4d051d157d0d39560821b8152509061306f5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b50600061307f8886868686613c9f565b6000868152600460205260409020805460ff1916905590506130a48886838686613da8565b939550929350505050915091565b6001600160a01b0382166000818152600860209081526040918290208490558151928352820183905280517fbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f49281900390910190a15050565b6103e80290565b6040805160208082018490528183018790526060820186905260808083018690528351808403909101815260a08301845280519082012060c0830189905260e08084019190915283518084039091018152610100909201909252805191012095945050505050565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b6006546040805163432ed0e160e11b81526001600160a01b03888116600483015287811660248301526001600160801b038716604483015260648201869052608482018590529151600093929092169163865da1c29160a48082019260209290919082900301818787803b15801561321d57600080fd5b505af1158015613231573d6000803e3d6000fd5b505050506040513d602081101561324757600080fd5b50516001600160a01b038082166000818152600a6020908152604091829020805460ff1916600117905581518b85168152938a16908401528281018690526060830191909152519192507f6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f919081900360800190a1505050505050565b60078054604080518082019091529182526614d512d7d0535560ca1b60208301526001600160801b0316341461333b5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5033600090815260086020908152604091829020548251808401909352600c83526b105314911657d4d51052d15160a21b91830191909152156133bf5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b50604080516060810182528281526001600160801b03438116602080840191825260008486018181523380835260088452918790209551865592516001958601805494511515600160801b0260ff60801b19929096166001600160801b031990951694909417169390931790915560098054909301909255825190815290810183905281517fcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88929181900390910190a150565b6000806000871180156134855750600088115b6040518060400160405280600e81526020016d28292aa722afa82927a7a32622a760911b815250906134f85760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5083870183890160006135096116a0565b6135158d8a89866138ad565b14905080801561354b575087868151811061352c57fe5b602002602001015189888151811061354057fe5b602002602001015114155b6040518060400160405280600e81526020016d141495539157d0d3d391931250d560921b815250906135be5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5060006135cd8d8b8a876138ad565b90506135d88161165c565b1561362957600081815260046020908152604091829020805460ff19169055815183815291517f3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f44909509281900390910190a15b50919b909a5098505050505050505050565b6060600061364884613edb565b6020808501515160c0860151516040805182815282850281019094019052909181801561367f578160200160208202803883390190505b50935061368a615369565b86516136969087613f2d565b90506000805b848110156136e7576136af898483613f67565b909350915081156136df578260800151876001856000015103815181106136d257fe5b6020026020010181815250505b60010161369c565b505060800151925050509250929050565b825160095460408051808201909152600a81526910d210d2d7d0d3d5539560b21b602082015260009291821461376f5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b50825181600101146040518060400160405280600c81526020016b4348434b5f4f46465345545360a01b815250906137e85760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5060008080805b8481101561386357600089828151811061380557fe5b602002602001015190506138478c8a8d84898d888151811061382357fe5b60200260200101518e896001018151811061383a57fe5b6020026020010151614036565b92508215613856576001909301925b60601b93506001016137ef565b50909998505050505050505050565b60058190556040805182815290517f9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f639181900360200190a150565b600084835b8381101561390b57818682815181106138c757fe5b6020026020010151604051602001808381526020018281526020019250505060405160208183030381529060405280519060200120915080806001019150506138b2565b5090505b949350505050565b60408051600080825260208201909252613932816001614193565b91505090565b6040805160208082019590955280820193909352606080840192909252805180840390920182526080909201909152805191012090565b600080600061398b846000015185602001518660400151613938565b905060006139b2856060015186608001518760a001518860c0015163ffffffff1686613112565b935090915050915091565b80516139c8906141b2565b1580156139dd575080516139db906141b8565b155b6040518060400160405280600881526020016726a0a5a2afa92aa760c11b81525090613a4a5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5060035460e082015160408051808201909152600981526804d414b455f535445560bc1b6020820152916001600160401b0390811691161115613ace5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b506003546101008201518051600160401b9092046001600160401b03169091016001600160801b031690600160200201516001600160801b03161115613b1357600080fd5b6003546101008201516060810151600160801b9092046001600160401b03169091016001600160801b031690600260200201516001600160801b03161115613b5a57600080fd5b613b688161010001516141bc565b604051806040016040528060098152602001684d414b455f54494d4560b81b81525090613bd65760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b506101208101511580613beb5750806101a001515b6040518060400160405280600d81526020016c4d414b455f4d4553534147455360981b8152509061183f5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b6000612b2583836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250614220565b6040805160a081018252600154815260025460208201526003546001600160401b0380821693830193909352600160401b810483166060830152600160801b9004909116608082015260009081908190613cfa90894361427a565b915091506000613d1489898489898c6001600001546142d1565b90506000613d2a8a8a858b60016000015461431b565b90506000613d418b8b868c6001600001548a614380565b90506000613d508c8c87614410565b6000948552600460205260408086208054600160ff1991821681179092559587528187208054871682179055938652808620805486168517905581865290942080549093169091179091555098975050505050505050565b7fccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc604051806101000160405280868152602001848152602001876101400151815260200187610160015181526020018761018001518152602001876101e00151815260200187610200015181526020018581525082876101200151886101000151896101c001518a60e001518b6101a001516040518088600860200280838360005b83811015613e62578181015183820152602001613e4a565b5050505090500187815260200186815260200185600460200280838360005b83811015613e99578181015183820152602001613e81565b5050506001600160401b039788169390910192835250509290931660208301521515604080830191909152519081900360600195509350505050a15050505050565b60208101515160c08201515160a0830151518114613ef857600080fd5b8083608001515114613f0957600080fd5b8183604001515114613f1a57600080fd5b808203836060015151146114ad57600080fd5b613f35615369565b6040518060a0016040528060008152602001600081526020016000815260200184815260200183815250905092915050565b613f6f615369565b60008085602001518481518110613f8257fe5b60200260200101519050600060038214905060008115613fca57613faf8888600001518960400151614458565b60608a01526040890191909152875160010188529050613ff9565b8760600151876020015181518110613fde57fe5b60200260200101519050866020018051809190600101815250505b61402587608001518960400151888151811061401157fe5b602002602001015183868b60600151613112565b608088015250949694955050505050565b6000836bffffffffffffffffffffffff19168560601b6bffffffffffffffffffffffff1916116040518060400160405280600a81526020016921a421a5afa7a92222a960b11b815250906140cb5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b5060006140d786612bb5565b600181015490915060009088906140f6906001600160801b031661310b565b109050801561418657815461410d8b8b88886138ad565b146040518060400160405280601181526020017021a421a5afa9aa20a5a2a92fa82927a7a360791b815250906141845760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b505b9998505050505050505050565b600061419d615397565b6141a784846144e2565b905061390f81614501565b60011490565b1590565b805160009042906001600160801b031643108015906141e8575060208301516001600160801b03164311155b8015614201575060408301516001600160801b03168110155b8015612b25575060608301516001600160801b03168111159392505050565b600081848411156142725760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561143457818101518382015260200161141c565b505050900390565b60008060008560200151856101c001516001600160401b03168161429a57fe5b049050600086600001516142ad8661310b565b01905085608001518110156142c3575060808501515b909690870195509350505050565b6000806142f1896101400151878b61012001518c60400151018803613938565b9050614186888861430d84614306600161310b565b880161317a565b61431561456d565b88613112565b6000806143458760200151886101400151614334613917565b8a61016001518b6101200151614572565b9050600061435e82614357600161310b565b860161317a565b905061437487878361436e6145b8565b89613112565b98975050505050505050565b60008061439c88600001518961010001518a61016001516145bd565b905060006143ce8961018001518a6101a001518b6101c001516000801b8d6101e001516000801b8f610200015161462e565b905060006143e18a60e001518484614691565b905061440289896143f484898b0161317a565b6143fc6146d9565b8b613112565b9a9950505050505050505050565b600061390f838361442b876101e0015188610200015161317a565b6144336146de565b6144538961018001518a61014001518b61012001518c6040015101613938565b613112565b60008060008060006144868860e00151878a60c001518a8151811061447957fe5b60200260200101516146e3565b9150915060006144ad838a608001518a815181106144a057fe5b602002602001015161317a565b905060008960a0015189815181106144c157fe5b60200260200101519050828282965096509650505050505b93509350939050565b6144ea615397565b60006144f5846147a6565b905061390f8184614866565b606081015160009060ff16600214614556576040805162461bcd60e51b815260206004820152601360248201527209aeae6e840c4ca40a0e4ca92dac2ceca90e6d606b1b604482015290519081900360640190fd5b8151608083015161456791906148ea565b92915050565b600090565b60408051602080820197909752808201959095526060850193909352608084019190915260a0808401919091528151808403909101815260c09092019052805191012090565b600190565b81516020808401516040808601516060968701518251808601999099526001600160801b0319608096871b81168a85015293861b841660508a015290851b83169688019690965294831b166070860152818501929092528251808503909101815260a0909301909152815191012090565b6040805160208082019990995296151560f81b8782015260c09590951b6001600160c01b031916604187015260498601939093526069850191909152608984015260a9808401919091528151808403909101815260c99092019052805191012090565b6040805160c09490941b6001600160c01b0319166020808601919091526028850193909352604880850192909252805180850390920182526068909301909252815191012090565b600290565b600390565b60008080806146f0615397565b8660005b87811015614796576147068a83614924565b919650909350915084614759576040805162461bcd60e51b8152602060048201526016602482015275496e76616c6964206f7574707574206d65737361676560501b604482015290519081900360640190fd5b8361476384614a62565b604080516020808201949094528082019290925280518083038201815260609092019052805191012093506001016146f4565b5091989197509095505050505050565b60006008825111156147f6576040805162461bcd60e51b8152602060048201526014602482015273092dcecc2d8d2c840e8eae0d8ca40d8cadccee8d60631b604482015290519081900360640190fd5b6000825183604051602001808360ff1660ff1660f81b8152600101828051906020019060200280838360005b8381101561483a578181015183820152602001614822565b505050509050019250505060405160208183030381529060405280519060200120905080915050919050565b61486e615397565b6040805160a08101825284815281516080810183526000808252602082810182905282850182905260608301829052808401929092528351818152918201845291928301916148d3565b6148c0615397565b8152602001906001900390816148b85790505b508152600260208201526040019290925250919050565b60408051600360f81b6020808301919091526021820194909452604180820193909352815180820390930183526061019052805191012090565b60008061492f615397565b8451841061494f576000846149446000614b5a565b925092509250614a5b565b600080859050600087828151811061496357fe5b016020015160019092019160f81c9050600061497d6153cb565b60ff83166149b15761498f8a85614bdf565b9196509450915084846149a184614b5a565b9750975097505050505050614a5b565b60ff8316600114156149d9576149c78a85614c32565b9196509450905084846149a183614d92565b60ff8316600214156149ef576149a18a85614df9565b600360ff841610801590614a065750600c60ff8416105b15614a415760021983016060614a1d828d88614e9e565b919850965090508686614a2f83614f58565b99509950995050505050505050614a5b565b600080614a4e6000614b5a565b9199509750955050505050505b9250925092565b606081015160009060ff16614a83578151614a7c90615047565b905061166f565b606082015160ff1660011415614ab6576020808301518051604082015160608301519290930151614a7c9391929061506b565b606082015160ff1660021415614acf57614a7c82614501565b600360ff16826060015160ff1610158015614af357506060820151600c60ff909116105b15614b0157614a7c82615113565b606082015160ff1660641415614b195750805161166f565b6040805162461bcd60e51b8152602060048201526011602482015270496e76616c6964207479706520636f646560781b604482015290519081900360640190fd5b614b62615397565b6040805160a0810182528381528151608081018352600080825260208281018290528285018290526060830182905280840192909252835181815291820184529192830191614bc7565b614bb4615397565b815260200190600190039081614bac5790505b50815260006020820152600160409091015292915050565b6000806000808551905084811080614bf957506020858203105b15614c0e575060009250839150829050614a5b565b600160208601614c24888863ffffffff61513116565b935093509350509250925092565b600080614c3d6153cb565b60008490506000868281518110614c5057fe5b602001015160f81c60f81b60f81c905081806001019250506000878381518110614c7657fe5b016020015160019384019360f89190911c915060009060ff84161415614cfc576000614ca0615397565b614caa8b87614924565b909750909250905081614cee57505060408051608081018252600080825260208201819052918101829052606081018290529097508896509450614a5b9350505050565b614cf781614a62565b925050505b6000614d0e8a8663ffffffff61513116565b90506020850194508360ff1660011415614d5a576040805160808101825260ff90941684526020840191909152600190830181905260608301919091529550919350909150614a5b9050565b6040805160808101825260ff949094168452602084019190915260009083018190526060830152506001989297509550909350505050565b614d9a615397565b6040805160a0810182526000808252602080830186905283518281529081018452919283019190614de1565b614dce615397565b815260200190600190039081614dc65790505b50815260016020820181905260409091015292915050565b600080614e04615397565b614e0c615397565b8551600090819087811080614e2357506040888203105b15614e3b576000888596509650965050505050614a5b565b6000614e4d8a8a63ffffffff61513116565b9050602089019850614e5f8a8a614bdf565b909a50945092508215614e8a57614e768185614866565b600198508997509550614a5b945050505050565b600089869750975097505050505050614a5b565b60008060606000849050600060608860ff16604051908082528060200260200182016040528015614ee957816020015b614ed6615397565b815260200190600190039081614ece5790505b50905060005b8960ff168160ff161015614f4657614f078985614924565b8451859060ff8616908110614f1857fe5b60209081029190910101529450925082614f3e57506000955086945092506144d9915050565b600101614eef565b50600199929850965090945050505050565b614f60615397565b614f6a825161514d565b614fbb576040805162461bcd60e51b815260206004820152601a60248201527f5475706c65206d75737420686176652076616c69642073697a65000000000000604482015290519081900360640190fd5b600160005b8351811015614ff257838181518110614fd557fe5b602002602001015160800151820191508080600101915050614fc0565b506040805160a08101825260008082528251608080820185528282526020808301849052828601849052606080840194909452840191909152928201869052945160030160ff16948101949094528301525090565b60408051602080820193909352815180820384018152908201909152805191012090565b600083156150c5575060408051600160f81b6020808301919091526001600160f81b031960f888901b166021830152602282018590526042808301859052835180840390910181526062909201909252805191012061390f565b5060408051600160f81b6020808301919091526001600160f81b031960f888901b16602183015260228083018590528351808403909101815260429092019092528051910120949350505050565b600061511d615397565b61512683615154565b9050612b2581614501565b6000816020018351101561514457600080fd5b50016020015190565b6008101590565b61515c615397565b615165826151ca565b6151ab576040805162461bcd60e51b81526020600482015260126024820152714d757374206265205475706c65207479706560701b604482015290519081900360640190fd5b60606151ba83604001516151d9565b9050612b258184608001516144e2565b600061456782606001516152b1565b6060600882511115615229576040805162461bcd60e51b8152602060048201526014602482015273092dcecc2d8d2c840e8eae0d8ca40d8cadccee8d60631b604482015290519081900360640190fd5b60608251604051908082528060200260200182016040528015615256578160200160208202803883390190505b50805190915060005b818110156152a857600061528586838151811061527857fe5b6020026020010151614a62565b90508084838151811061529457fe5b60209081029190910101525060010161525f565b50909392505050565b6000600c60ff8316108015614567575050600360ff91909116101590565b6040805161022081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e0810191909152610100810161531d6153f2565b815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e082018190526101009091015290565b61012c8061541183390190565b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915290565b6040518060a00160405280600081526020016153b16153cb565b815260606020820181905260006040830181905291015290565b60408051608081018252600080825260208201819052918101829052606081019190915290565b6040518060800160405280600490602082028038833950919291505056fe608060405234801561001057600080fd5b5060405161012c38038061012c8339818101604052602081101561003357600080fd5b5051600080546001600160a01b039092166001600160a01b031990921691909117905560c8806100646000396000f3fe608060408181526000805463c581831760e01b90935233608481815260a49384523660c48190526001600160a01b039095169463c5818317943494929060e4848480828437600081840152601f19601f8201169050808301925050509450505050506000604051808303818588803b158015607957600080fd5b505af1158015608c573d6000803e3d6000fd5b505050505000fea265627a7a723158201c0afa7d42a549becb25deca6f89c79f53ebcf88e5f3e5b326c2253af0ab4f9664736f6c634300051100324e6f6e20696e7465726661636520636f6e74726163742063616e27742073656e64206d657373616765a265627a7a72315820ceeea40895a74276804f6df7fa507a3b43ea4372bff6e8ac3ec9b196e4cf46b864736f6c63430005110032"

// DeployArbRollup deploys a new Ethereum contract, binding an instance of ArbRollup to it.
func DeployArbRollup(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ArbRollup, error) {
	parsed, err := abi.JSON(strings.NewReader(ArbRollupABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ArbRollupBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ArbRollup{ArbRollupCaller: ArbRollupCaller{contract: contract}, ArbRollupTransactor: ArbRollupTransactor{contract: contract}, ArbRollupFilterer: ArbRollupFilterer{contract: contract}}, nil
}

// ArbRollup is an auto generated Go binding around an Ethereum contract.
type ArbRollup struct {
	ArbRollupCaller     // Read-only binding to the contract
	ArbRollupTransactor // Write-only binding to the contract
	ArbRollupFilterer   // Log filterer for contract events
}

// ArbRollupCaller is an auto generated read-only Go binding around an Ethereum contract.
type ArbRollupCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbRollupTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ArbRollupTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbRollupFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ArbRollupFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbRollupSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ArbRollupSession struct {
	Contract     *ArbRollup        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ArbRollupCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ArbRollupCallerSession struct {
	Contract *ArbRollupCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// ArbRollupTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ArbRollupTransactorSession struct {
	Contract     *ArbRollupTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// ArbRollupRaw is an auto generated low-level Go binding around an Ethereum contract.
type ArbRollupRaw struct {
	Contract *ArbRollup // Generic contract binding to access the raw methods on
}

// ArbRollupCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ArbRollupCallerRaw struct {
	Contract *ArbRollupCaller // Generic read-only contract binding to access the raw methods on
}

// ArbRollupTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ArbRollupTransactorRaw struct {
	Contract *ArbRollupTransactor // Generic write-only contract binding to access the raw methods on
}

// NewArbRollup creates a new instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollup(address common.Address, backend bind.ContractBackend) (*ArbRollup, error) {
	contract, err := bindArbRollup(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ArbRollup{ArbRollupCaller: ArbRollupCaller{contract: contract}, ArbRollupTransactor: ArbRollupTransactor{contract: contract}, ArbRollupFilterer: ArbRollupFilterer{contract: contract}}, nil
}

// NewArbRollupCaller creates a new read-only instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollupCaller(address common.Address, caller bind.ContractCaller) (*ArbRollupCaller, error) {
	contract, err := bindArbRollup(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ArbRollupCaller{contract: contract}, nil
}

// NewArbRollupTransactor creates a new write-only instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollupTransactor(address common.Address, transactor bind.ContractTransactor) (*ArbRollupTransactor, error) {
	contract, err := bindArbRollup(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ArbRollupTransactor{contract: contract}, nil
}

// NewArbRollupFilterer creates a new log filterer instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollupFilterer(address common.Address, filterer bind.ContractFilterer) (*ArbRollupFilterer, error) {
	contract, err := bindArbRollup(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ArbRollupFilterer{contract: contract}, nil
}

// bindArbRollup binds a generic wrapper to an already deployed contract.
func bindArbRollup(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ArbRollupABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ArbRollup *ArbRollupRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ArbRollup.Contract.ArbRollupCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ArbRollup *ArbRollupRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbRollup.Contract.ArbRollupTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ArbRollup *ArbRollupRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ArbRollup.Contract.ArbRollupTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ArbRollup *ArbRollupCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ArbRollup.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ArbRollup *ArbRollupTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbRollup.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ArbRollup *ArbRollupTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ArbRollup.Contract.contract.Transact(opts, method, params...)
}

// VERSION is a free data retrieval call binding the contract method 0xffa1ad74.
//
// Solidity: function VERSION() view returns(string)
func (_ArbRollup *ArbRollupCaller) VERSION(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "VERSION")
	return *ret0, err
}

// VERSION is a free data retrieval call binding the contract method 0xffa1ad74.
//
// Solidity: function VERSION() view returns(string)
func (_ArbRollup *ArbRollupSession) VERSION() (string, error) {
	return _ArbRollup.Contract.VERSION(&_ArbRollup.CallOpts)
}

// VERSION is a free data retrieval call binding the contract method 0xffa1ad74.
//
// Solidity: function VERSION() view returns(string)
func (_ArbRollup *ArbRollupCallerSession) VERSION() (string, error) {
	return _ArbRollup.Contract.VERSION(&_ArbRollup.CallOpts)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() view returns(address)
func (_ArbRollup *ArbRollupCaller) ChallengeFactory(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "challengeFactory")
	return *ret0, err
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() view returns(address)
func (_ArbRollup *ArbRollupSession) ChallengeFactory() (common.Address, error) {
	return _ArbRollup.Contract.ChallengeFactory(&_ArbRollup.CallOpts)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() view returns(address)
func (_ArbRollup *ArbRollupCallerSession) ChallengeFactory() (common.Address, error) {
	return _ArbRollup.Contract.ChallengeFactory(&_ArbRollup.CallOpts)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() view returns(uint128)
func (_ArbRollup *ArbRollupCaller) GetStakeRequired(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "getStakeRequired")
	return *ret0, err
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() view returns(uint128)
func (_ArbRollup *ArbRollupSession) GetStakeRequired() (*big.Int, error) {
	return _ArbRollup.Contract.GetStakeRequired(&_ArbRollup.CallOpts)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() view returns(uint128)
func (_ArbRollup *ArbRollupCallerSession) GetStakeRequired() (*big.Int, error) {
	return _ArbRollup.Contract.GetStakeRequired(&_ArbRollup.CallOpts)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() view returns(address)
func (_ArbRollup *ArbRollupCaller) GlobalInbox(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "globalInbox")
	return *ret0, err
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() view returns(address)
func (_ArbRollup *ArbRollupSession) GlobalInbox() (common.Address, error) {
	return _ArbRollup.Contract.GlobalInbox(&_ArbRollup.CallOpts)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() view returns(address)
func (_ArbRollup *ArbRollupCallerSession) GlobalInbox() (common.Address, error) {
	return _ArbRollup.Contract.GlobalInbox(&_ArbRollup.CallOpts)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) view returns(bool)
func (_ArbRollup *ArbRollupCaller) IsStaked(opts *bind.CallOpts, _stakerAddress common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "isStaked", _stakerAddress)
	return *ret0, err
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) view returns(bool)
func (_ArbRollup *ArbRollupSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _ArbRollup.Contract.IsStaked(&_ArbRollup.CallOpts, _stakerAddress)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) view returns(bool)
func (_ArbRollup *ArbRollupCallerSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _ArbRollup.Contract.IsStaked(&_ArbRollup.CallOpts, _stakerAddress)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) view returns(bool)
func (_ArbRollup *ArbRollupCaller) IsValidLeaf(opts *bind.CallOpts, leaf [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "isValidLeaf", leaf)
	return *ret0, err
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) view returns(bool)
func (_ArbRollup *ArbRollupSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _ArbRollup.Contract.IsValidLeaf(&_ArbRollup.CallOpts, leaf)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) view returns(bool)
func (_ArbRollup *ArbRollupCallerSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _ArbRollup.Contract.IsValidLeaf(&_ArbRollup.CallOpts, leaf)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() view returns(bytes32)
func (_ArbRollup *ArbRollupCaller) LatestConfirmed(opts *bind.CallOpts) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "latestConfirmed")
	return *ret0, err
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() view returns(bytes32)
func (_ArbRollup *ArbRollupSession) LatestConfirmed() ([32]byte, error) {
	return _ArbRollup.Contract.LatestConfirmed(&_ArbRollup.CallOpts)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() view returns(bytes32)
func (_ArbRollup *ArbRollupCallerSession) LatestConfirmed() ([32]byte, error) {
	return _ArbRollup.Contract.LatestConfirmed(&_ArbRollup.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ArbRollup *ArbRollupCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ArbRollup *ArbRollupSession) Owner() (common.Address, error) {
	return _ArbRollup.Contract.Owner(&_ArbRollup.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ArbRollup *ArbRollupCallerSession) Owner() (common.Address, error) {
	return _ArbRollup.Contract.Owner(&_ArbRollup.CallOpts)
}

// SupportedContracts is a free data retrieval call binding the contract method 0xb7ff920e.
//
// Solidity: function supportedContracts(address ) view returns(address)
func (_ArbRollup *ArbRollupCaller) SupportedContracts(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "supportedContracts", arg0)
	return *ret0, err
}

// SupportedContracts is a free data retrieval call binding the contract method 0xb7ff920e.
//
// Solidity: function supportedContracts(address ) view returns(address)
func (_ArbRollup *ArbRollupSession) SupportedContracts(arg0 common.Address) (common.Address, error) {
	return _ArbRollup.Contract.SupportedContracts(&_ArbRollup.CallOpts, arg0)
}

// SupportedContracts is a free data retrieval call binding the contract method 0xb7ff920e.
//
// Solidity: function supportedContracts(address ) view returns(address)
func (_ArbRollup *ArbRollupCallerSession) SupportedContracts(arg0 common.Address) (common.Address, error) {
	return _ArbRollup.Contract.SupportedContracts(&_ArbRollup.CallOpts, arg0)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() view returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_ArbRollup *ArbRollupCaller) VmParams(opts *bind.CallOpts) (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	ret := new(struct {
		GracePeriodTicks        *big.Int
		ArbGasSpeedLimitPerTick *big.Int
		MaxExecutionSteps       uint64
		MaxBlockBoundsWidth     uint64
		MaxTimestampBoundsWidth uint64
	})
	out := ret
	err := _ArbRollup.contract.Call(opts, out, "vmParams")
	return *ret, err
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() view returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_ArbRollup *ArbRollupSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	return _ArbRollup.Contract.VmParams(&_ArbRollup.CallOpts)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() view returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_ArbRollup *ArbRollupCallerSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	return _ArbRollup.Contract.VmParams(&_ArbRollup.CallOpts)
}

// Confirm is a paid mutator transaction binding the contract method 0x1a072771.
//
// Solidity: function confirm(bytes32 initalProtoStateHash, uint256[] branches, uint256[] deadlineTicks, bytes32[] challengeNodeData, bytes32[] logsAcc, bytes32[] vmProtoStateHashes, uint256[] messageCounts, bytes messages, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactor) Confirm(opts *bind.TransactOpts, initalProtoStateHash [32]byte, branches []*big.Int, deadlineTicks []*big.Int, challengeNodeData [][32]byte, logsAcc [][32]byte, vmProtoStateHashes [][32]byte, messageCounts []*big.Int, messages []byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "confirm", initalProtoStateHash, branches, deadlineTicks, challengeNodeData, logsAcc, vmProtoStateHashes, messageCounts, messages, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// Confirm is a paid mutator transaction binding the contract method 0x1a072771.
//
// Solidity: function confirm(bytes32 initalProtoStateHash, uint256[] branches, uint256[] deadlineTicks, bytes32[] challengeNodeData, bytes32[] logsAcc, bytes32[] vmProtoStateHashes, uint256[] messageCounts, bytes messages, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupSession) Confirm(initalProtoStateHash [32]byte, branches []*big.Int, deadlineTicks []*big.Int, challengeNodeData [][32]byte, logsAcc [][32]byte, vmProtoStateHashes [][32]byte, messageCounts []*big.Int, messages []byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.Confirm(&_ArbRollup.TransactOpts, initalProtoStateHash, branches, deadlineTicks, challengeNodeData, logsAcc, vmProtoStateHashes, messageCounts, messages, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// Confirm is a paid mutator transaction binding the contract method 0x1a072771.
//
// Solidity: function confirm(bytes32 initalProtoStateHash, uint256[] branches, uint256[] deadlineTicks, bytes32[] challengeNodeData, bytes32[] logsAcc, bytes32[] vmProtoStateHashes, uint256[] messageCounts, bytes messages, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactorSession) Confirm(initalProtoStateHash [32]byte, branches []*big.Int, deadlineTicks []*big.Int, challengeNodeData [][32]byte, logsAcc [][32]byte, vmProtoStateHashes [][32]byte, messageCounts []*big.Int, messages []byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.Confirm(&_ArbRollup.TransactOpts, initalProtoStateHash, branches, deadlineTicks, challengeNodeData, logsAcc, vmProtoStateHashes, messageCounts, messages, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) payable returns()
func (_ArbRollup *ArbRollupTransactor) ForwardContractMessage(opts *bind.TransactOpts, _sender common.Address, _data []byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "forwardContractMessage", _sender, _data)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) payable returns()
func (_ArbRollup *ArbRollupSession) ForwardContractMessage(_sender common.Address, _data []byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.ForwardContractMessage(&_ArbRollup.TransactOpts, _sender, _data)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) payable returns()
func (_ArbRollup *ArbRollupTransactorSession) ForwardContractMessage(_sender common.Address, _data []byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.ForwardContractMessage(&_ArbRollup.TransactOpts, _sender, _data)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_ArbRollup *ArbRollupTransactor) Init(opts *bind.TransactOpts, _vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "init", _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_ArbRollup *ArbRollupSession) Init(_vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.Init(&_ArbRollup.TransactOpts, _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_ArbRollup *ArbRollupTransactorSession) Init(_vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.Init(&_ArbRollup.TransactOpts, _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// MakeAssertion is a paid mutator transaction binding the contract method 0xa7067556.
//
// Solidity: function makeAssertion(bytes32[9] _fields, uint256 _beforeInboxCount, uint256 _prevDeadlineTicks, uint32 _prevChildType, uint64 _numSteps, uint128[4] _timeBounds, uint256 _importedMessageCount, bool _didInboxInsn, uint64 _numArbGas, bytes32[] _stakerProof) returns()
func (_ArbRollup *ArbRollupTransactor) MakeAssertion(opts *bind.TransactOpts, _fields [9][32]byte, _beforeInboxCount *big.Int, _prevDeadlineTicks *big.Int, _prevChildType uint32, _numSteps uint64, _timeBounds [4]*big.Int, _importedMessageCount *big.Int, _didInboxInsn bool, _numArbGas uint64, _stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "makeAssertion", _fields, _beforeInboxCount, _prevDeadlineTicks, _prevChildType, _numSteps, _timeBounds, _importedMessageCount, _didInboxInsn, _numArbGas, _stakerProof)
}

// MakeAssertion is a paid mutator transaction binding the contract method 0xa7067556.
//
// Solidity: function makeAssertion(bytes32[9] _fields, uint256 _beforeInboxCount, uint256 _prevDeadlineTicks, uint32 _prevChildType, uint64 _numSteps, uint128[4] _timeBounds, uint256 _importedMessageCount, bool _didInboxInsn, uint64 _numArbGas, bytes32[] _stakerProof) returns()
func (_ArbRollup *ArbRollupSession) MakeAssertion(_fields [9][32]byte, _beforeInboxCount *big.Int, _prevDeadlineTicks *big.Int, _prevChildType uint32, _numSteps uint64, _timeBounds [4]*big.Int, _importedMessageCount *big.Int, _didInboxInsn bool, _numArbGas uint64, _stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MakeAssertion(&_ArbRollup.TransactOpts, _fields, _beforeInboxCount, _prevDeadlineTicks, _prevChildType, _numSteps, _timeBounds, _importedMessageCount, _didInboxInsn, _numArbGas, _stakerProof)
}

// MakeAssertion is a paid mutator transaction binding the contract method 0xa7067556.
//
// Solidity: function makeAssertion(bytes32[9] _fields, uint256 _beforeInboxCount, uint256 _prevDeadlineTicks, uint32 _prevChildType, uint64 _numSteps, uint128[4] _timeBounds, uint256 _importedMessageCount, bool _didInboxInsn, uint64 _numArbGas, bytes32[] _stakerProof) returns()
func (_ArbRollup *ArbRollupTransactorSession) MakeAssertion(_fields [9][32]byte, _beforeInboxCount *big.Int, _prevDeadlineTicks *big.Int, _prevChildType uint32, _numSteps uint64, _timeBounds [4]*big.Int, _importedMessageCount *big.Int, _didInboxInsn bool, _numArbGas uint64, _stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MakeAssertion(&_ArbRollup.TransactOpts, _fields, _beforeInboxCount, _prevDeadlineTicks, _prevChildType, _numSteps, _timeBounds, _importedMessageCount, _didInboxInsn, _numArbGas, _stakerProof)
}

// MoveStake is a paid mutator transaction binding the contract method 0xdbad0a39.
//
// Solidity: function moveStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupTransactor) MoveStake(opts *bind.TransactOpts, proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "moveStake", proof1, proof2)
}

// MoveStake is a paid mutator transaction binding the contract method 0xdbad0a39.
//
// Solidity: function moveStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupSession) MoveStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MoveStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// MoveStake is a paid mutator transaction binding the contract method 0xdbad0a39.
//
// Solidity: function moveStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupTransactorSession) MoveStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MoveStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// OwnerShutdown is a paid mutator transaction binding the contract method 0xcfa80707.
//
// Solidity: function ownerShutdown() returns()
func (_ArbRollup *ArbRollupTransactor) OwnerShutdown(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "ownerShutdown")
}

// OwnerShutdown is a paid mutator transaction binding the contract method 0xcfa80707.
//
// Solidity: function ownerShutdown() returns()
func (_ArbRollup *ArbRollupSession) OwnerShutdown() (*types.Transaction, error) {
	return _ArbRollup.Contract.OwnerShutdown(&_ArbRollup.TransactOpts)
}

// OwnerShutdown is a paid mutator transaction binding the contract method 0xcfa80707.
//
// Solidity: function ownerShutdown() returns()
func (_ArbRollup *ArbRollupTransactorSession) OwnerShutdown() (*types.Transaction, error) {
	return _ArbRollup.Contract.OwnerShutdown(&_ArbRollup.TransactOpts)
}

// PlaceStake is a paid mutator transaction binding the contract method 0xe0620d64.
//
// Solidity: function placeStake(bytes32[] proof1, bytes32[] proof2) payable returns()
func (_ArbRollup *ArbRollupTransactor) PlaceStake(opts *bind.TransactOpts, proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "placeStake", proof1, proof2)
}

// PlaceStake is a paid mutator transaction binding the contract method 0xe0620d64.
//
// Solidity: function placeStake(bytes32[] proof1, bytes32[] proof2) payable returns()
func (_ArbRollup *ArbRollupSession) PlaceStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.PlaceStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// PlaceStake is a paid mutator transaction binding the contract method 0xe0620d64.
//
// Solidity: function placeStake(bytes32[] proof1, bytes32[] proof2) payable returns()
func (_ArbRollup *ArbRollupTransactorSession) PlaceStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.PlaceStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_ArbRollup *ArbRollupTransactor) PruneLeaves(opts *bind.TransactOpts, fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "pruneLeaves", fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_ArbRollup *ArbRollupSession) PruneLeaves(fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.PruneLeaves(&_ArbRollup.TransactOpts, fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_ArbRollup *ArbRollupTransactorSession) PruneLeaves(fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.PruneLeaves(&_ArbRollup.TransactOpts, fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// RecoverStakeConfirmed is a paid mutator transaction binding the contract method 0x7cfaaf67.
//
// Solidity: function recoverStakeConfirmed(bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakeConfirmed(opts *bind.TransactOpts, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakeConfirmed", proof)
}

// RecoverStakeConfirmed is a paid mutator transaction binding the contract method 0x7cfaaf67.
//
// Solidity: function recoverStakeConfirmed(bytes32[] proof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakeConfirmed(proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeConfirmed(&_ArbRollup.TransactOpts, proof)
}

// RecoverStakeConfirmed is a paid mutator transaction binding the contract method 0x7cfaaf67.
//
// Solidity: function recoverStakeConfirmed(bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakeConfirmed(proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeConfirmed(&_ArbRollup.TransactOpts, proof)
}

// RecoverStakeMooted is a paid mutator transaction binding the contract method 0x33554032.
//
// Solidity: function recoverStakeMooted(address stakerAddress, bytes32 node, bytes32[] latestConfirmedProof, bytes32[] stakerProof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakeMooted(opts *bind.TransactOpts, stakerAddress common.Address, node [32]byte, latestConfirmedProof [][32]byte, stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakeMooted", stakerAddress, node, latestConfirmedProof, stakerProof)
}

// RecoverStakeMooted is a paid mutator transaction binding the contract method 0x33554032.
//
// Solidity: function recoverStakeMooted(address stakerAddress, bytes32 node, bytes32[] latestConfirmedProof, bytes32[] stakerProof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakeMooted(stakerAddress common.Address, node [32]byte, latestConfirmedProof [][32]byte, stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeMooted(&_ArbRollup.TransactOpts, stakerAddress, node, latestConfirmedProof, stakerProof)
}

// RecoverStakeMooted is a paid mutator transaction binding the contract method 0x33554032.
//
// Solidity: function recoverStakeMooted(address stakerAddress, bytes32 node, bytes32[] latestConfirmedProof, bytes32[] stakerProof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakeMooted(stakerAddress common.Address, node [32]byte, latestConfirmedProof [][32]byte, stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeMooted(&_ArbRollup.TransactOpts, stakerAddress, node, latestConfirmedProof, stakerProof)
}

// RecoverStakeOld is a paid mutator transaction binding the contract method 0x113ec9d8.
//
// Solidity: function recoverStakeOld(address stakerAddress, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakeOld(opts *bind.TransactOpts, stakerAddress common.Address, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakeOld", stakerAddress, proof)
}

// RecoverStakeOld is a paid mutator transaction binding the contract method 0x113ec9d8.
//
// Solidity: function recoverStakeOld(address stakerAddress, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakeOld(stakerAddress common.Address, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeOld(&_ArbRollup.TransactOpts, stakerAddress, proof)
}

// RecoverStakeOld is a paid mutator transaction binding the contract method 0x113ec9d8.
//
// Solidity: function recoverStakeOld(address stakerAddress, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakeOld(stakerAddress common.Address, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeOld(&_ArbRollup.TransactOpts, stakerAddress, proof)
}

// RecoverStakePassedDeadline is a paid mutator transaction binding the contract method 0xbadb3f14.
//
// Solidity: function recoverStakePassedDeadline(address stakerAddress, uint256 deadlineTicks, bytes32 disputableNodeHashVal, uint256 childType, bytes32 vmProtoStateHash, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakePassedDeadline(opts *bind.TransactOpts, stakerAddress common.Address, deadlineTicks *big.Int, disputableNodeHashVal [32]byte, childType *big.Int, vmProtoStateHash [32]byte, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakePassedDeadline", stakerAddress, deadlineTicks, disputableNodeHashVal, childType, vmProtoStateHash, proof)
}

// RecoverStakePassedDeadline is a paid mutator transaction binding the contract method 0xbadb3f14.
//
// Solidity: function recoverStakePassedDeadline(address stakerAddress, uint256 deadlineTicks, bytes32 disputableNodeHashVal, uint256 childType, bytes32 vmProtoStateHash, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakePassedDeadline(stakerAddress common.Address, deadlineTicks *big.Int, disputableNodeHashVal [32]byte, childType *big.Int, vmProtoStateHash [32]byte, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakePassedDeadline(&_ArbRollup.TransactOpts, stakerAddress, deadlineTicks, disputableNodeHashVal, childType, vmProtoStateHash, proof)
}

// RecoverStakePassedDeadline is a paid mutator transaction binding the contract method 0xbadb3f14.
//
// Solidity: function recoverStakePassedDeadline(address stakerAddress, uint256 deadlineTicks, bytes32 disputableNodeHashVal, uint256 childType, bytes32 vmProtoStateHash, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakePassedDeadline(stakerAddress common.Address, deadlineTicks *big.Int, disputableNodeHashVal [32]byte, childType *big.Int, vmProtoStateHash [32]byte, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakePassedDeadline(&_ArbRollup.TransactOpts, stakerAddress, deadlineTicks, disputableNodeHashVal, childType, vmProtoStateHash, proof)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_ArbRollup *ArbRollupTransactor) ResolveChallenge(opts *bind.TransactOpts, winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "resolveChallenge", winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_ArbRollup *ArbRollupSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ResolveChallenge(&_ArbRollup.TransactOpts, winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_ArbRollup *ArbRollupTransactorSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ResolveChallenge(&_ArbRollup.TransactOpts, winner, loser, arg2)
}

// SpawnCallProxy is a paid mutator transaction binding the contract method 0xf75e4866.
//
// Solidity: function spawnCallProxy(address _arbContract) returns()
func (_ArbRollup *ArbRollupTransactor) SpawnCallProxy(opts *bind.TransactOpts, _arbContract common.Address) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "spawnCallProxy", _arbContract)
}

// SpawnCallProxy is a paid mutator transaction binding the contract method 0xf75e4866.
//
// Solidity: function spawnCallProxy(address _arbContract) returns()
func (_ArbRollup *ArbRollupSession) SpawnCallProxy(_arbContract common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.SpawnCallProxy(&_ArbRollup.TransactOpts, _arbContract)
}

// SpawnCallProxy is a paid mutator transaction binding the contract method 0xf75e4866.
//
// Solidity: function spawnCallProxy(address _arbContract) returns()
func (_ArbRollup *ArbRollupTransactorSession) SpawnCallProxy(_arbContract common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.SpawnCallProxy(&_ArbRollup.TransactOpts, _arbContract)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_ArbRollup *ArbRollupTransactor) StartChallenge(opts *bind.TransactOpts, asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "startChallenge", asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_ArbRollup *ArbRollupSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.StartChallenge(&_ArbRollup.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_ArbRollup *ArbRollupTransactorSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.StartChallenge(&_ArbRollup.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// ArbRollupConfirmedAssertionIterator is returned from FilterConfirmedAssertion and is used to iterate over the raw logs and unpacked data for ConfirmedAssertion events raised by the ArbRollup contract.
type ArbRollupConfirmedAssertionIterator struct {
	Event *ArbRollupConfirmedAssertion // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupConfirmedAssertionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupConfirmedAssertion)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupConfirmedAssertion)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupConfirmedAssertionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupConfirmedAssertionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupConfirmedAssertion represents a ConfirmedAssertion event raised by the ArbRollup contract.
type ArbRollupConfirmedAssertion struct {
	LogsAccHash [][32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterConfirmedAssertion is a free log retrieval operation binding the contract event 0xded5fa103431438087188a5f8c6a4c3ea90996bbd63be7b1b3fa0a425b37fdd5.
//
// Solidity: event ConfirmedAssertion(bytes32[] logsAccHash)
func (_ArbRollup *ArbRollupFilterer) FilterConfirmedAssertion(opts *bind.FilterOpts) (*ArbRollupConfirmedAssertionIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "ConfirmedAssertion")
	if err != nil {
		return nil, err
	}
	return &ArbRollupConfirmedAssertionIterator{contract: _ArbRollup.contract, event: "ConfirmedAssertion", logs: logs, sub: sub}, nil
}

// WatchConfirmedAssertion is a free log subscription operation binding the contract event 0xded5fa103431438087188a5f8c6a4c3ea90996bbd63be7b1b3fa0a425b37fdd5.
//
// Solidity: event ConfirmedAssertion(bytes32[] logsAccHash)
func (_ArbRollup *ArbRollupFilterer) WatchConfirmedAssertion(opts *bind.WatchOpts, sink chan<- *ArbRollupConfirmedAssertion) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "ConfirmedAssertion")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupConfirmedAssertion)
				if err := _ArbRollup.contract.UnpackLog(event, "ConfirmedAssertion", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseConfirmedAssertion is a log parse operation binding the contract event 0xded5fa103431438087188a5f8c6a4c3ea90996bbd63be7b1b3fa0a425b37fdd5.
//
// Solidity: event ConfirmedAssertion(bytes32[] logsAccHash)
func (_ArbRollup *ArbRollupFilterer) ParseConfirmedAssertion(log types.Log) (*ArbRollupConfirmedAssertion, error) {
	event := new(ArbRollupConfirmedAssertion)
	if err := _ArbRollup.contract.UnpackLog(event, "ConfirmedAssertion", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupConfirmedValidAssertionIterator is returned from FilterConfirmedValidAssertion and is used to iterate over the raw logs and unpacked data for ConfirmedValidAssertion events raised by the ArbRollup contract.
type ArbRollupConfirmedValidAssertionIterator struct {
	Event *ArbRollupConfirmedValidAssertion // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupConfirmedValidAssertionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupConfirmedValidAssertion)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupConfirmedValidAssertion)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupConfirmedValidAssertionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupConfirmedValidAssertionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupConfirmedValidAssertion represents a ConfirmedValidAssertion event raised by the ArbRollup contract.
type ArbRollupConfirmedValidAssertion struct {
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterConfirmedValidAssertion is a free log retrieval operation binding the contract event 0x89cc5e236414c34f1206c0c14d8ac5b0e5444b669b309aaca16fe3d27749f50e.
//
// Solidity: event ConfirmedValidAssertion(bytes32 indexed nodeHash)
func (_ArbRollup *ArbRollupFilterer) FilterConfirmedValidAssertion(opts *bind.FilterOpts, nodeHash [][32]byte) (*ArbRollupConfirmedValidAssertionIterator, error) {

	var nodeHashRule []interface{}
	for _, nodeHashItem := range nodeHash {
		nodeHashRule = append(nodeHashRule, nodeHashItem)
	}

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "ConfirmedValidAssertion", nodeHashRule)
	if err != nil {
		return nil, err
	}
	return &ArbRollupConfirmedValidAssertionIterator{contract: _ArbRollup.contract, event: "ConfirmedValidAssertion", logs: logs, sub: sub}, nil
}

// WatchConfirmedValidAssertion is a free log subscription operation binding the contract event 0x89cc5e236414c34f1206c0c14d8ac5b0e5444b669b309aaca16fe3d27749f50e.
//
// Solidity: event ConfirmedValidAssertion(bytes32 indexed nodeHash)
func (_ArbRollup *ArbRollupFilterer) WatchConfirmedValidAssertion(opts *bind.WatchOpts, sink chan<- *ArbRollupConfirmedValidAssertion, nodeHash [][32]byte) (event.Subscription, error) {

	var nodeHashRule []interface{}
	for _, nodeHashItem := range nodeHash {
		nodeHashRule = append(nodeHashRule, nodeHashItem)
	}

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "ConfirmedValidAssertion", nodeHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupConfirmedValidAssertion)
				if err := _ArbRollup.contract.UnpackLog(event, "ConfirmedValidAssertion", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseConfirmedValidAssertion is a log parse operation binding the contract event 0x89cc5e236414c34f1206c0c14d8ac5b0e5444b669b309aaca16fe3d27749f50e.
//
// Solidity: event ConfirmedValidAssertion(bytes32 indexed nodeHash)
func (_ArbRollup *ArbRollupFilterer) ParseConfirmedValidAssertion(log types.Log) (*ArbRollupConfirmedValidAssertion, error) {
	event := new(ArbRollupConfirmedValidAssertion)
	if err := _ArbRollup.contract.UnpackLog(event, "ConfirmedValidAssertion", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupAssertedIterator is returned from FilterRollupAsserted and is used to iterate over the raw logs and unpacked data for RollupAsserted events raised by the ArbRollup contract.
type ArbRollupRollupAssertedIterator struct {
	Event *ArbRollupRollupAsserted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupAssertedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupAsserted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupAsserted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupAssertedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupAssertedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupAsserted represents a RollupAsserted event raised by the ArbRollup contract.
type ArbRollupRollupAsserted struct {
	Fields               [8][32]byte
	InboxCount           *big.Int
	ImportedMessageCount *big.Int
	TimeBounds           [4]*big.Int
	NumArbGas            uint64
	NumSteps             uint64
	DidInboxInsn         bool
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterRollupAsserted is a free log retrieval operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_ArbRollup *ArbRollupFilterer) FilterRollupAsserted(opts *bind.FilterOpts) (*ArbRollupRollupAssertedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupAssertedIterator{contract: _ArbRollup.contract, event: "RollupAsserted", logs: logs, sub: sub}, nil
}

// WatchRollupAsserted is a free log subscription operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_ArbRollup *ArbRollupFilterer) WatchRollupAsserted(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupAsserted) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupAsserted)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupAsserted is a log parse operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_ArbRollup *ArbRollupFilterer) ParseRollupAsserted(log types.Log) (*ArbRollupRollupAsserted, error) {
	event := new(ArbRollupRollupAsserted)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupChallengeCompletedIterator is returned from FilterRollupChallengeCompleted and is used to iterate over the raw logs and unpacked data for RollupChallengeCompleted events raised by the ArbRollup contract.
type ArbRollupRollupChallengeCompletedIterator struct {
	Event *ArbRollupRollupChallengeCompleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupChallengeCompletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupChallengeCompleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupChallengeCompleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupChallengeCompletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupChallengeCompletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupChallengeCompleted represents a RollupChallengeCompleted event raised by the ArbRollup contract.
type ArbRollupRollupChallengeCompleted struct {
	ChallengeContract common.Address
	Winner            common.Address
	Loser             common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeCompleted is a free log retrieval operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_ArbRollup *ArbRollupFilterer) FilterRollupChallengeCompleted(opts *bind.FilterOpts) (*ArbRollupRollupChallengeCompletedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupChallengeCompletedIterator{contract: _ArbRollup.contract, event: "RollupChallengeCompleted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeCompleted is a free log subscription operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_ArbRollup *ArbRollupFilterer) WatchRollupChallengeCompleted(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupChallengeCompleted) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupChallengeCompleted)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeCompleted is a log parse operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_ArbRollup *ArbRollupFilterer) ParseRollupChallengeCompleted(log types.Log) (*ArbRollupRollupChallengeCompleted, error) {
	event := new(ArbRollupRollupChallengeCompleted)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupChallengeStartedIterator is returned from FilterRollupChallengeStarted and is used to iterate over the raw logs and unpacked data for RollupChallengeStarted events raised by the ArbRollup contract.
type ArbRollupRollupChallengeStartedIterator struct {
	Event *ArbRollupRollupChallengeStarted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupChallengeStartedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupChallengeStarted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupChallengeStarted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupChallengeStartedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupChallengeStartedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupChallengeStarted represents a RollupChallengeStarted event raised by the ArbRollup contract.
type ArbRollupRollupChallengeStarted struct {
	Asserter          common.Address
	Challenger        common.Address
	ChallengeType     *big.Int
	ChallengeContract common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeStarted is a free log retrieval operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_ArbRollup *ArbRollupFilterer) FilterRollupChallengeStarted(opts *bind.FilterOpts) (*ArbRollupRollupChallengeStartedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupChallengeStartedIterator{contract: _ArbRollup.contract, event: "RollupChallengeStarted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeStarted is a free log subscription operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_ArbRollup *ArbRollupFilterer) WatchRollupChallengeStarted(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupChallengeStarted) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupChallengeStarted)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeStarted is a log parse operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_ArbRollup *ArbRollupFilterer) ParseRollupChallengeStarted(log types.Log) (*ArbRollupRollupChallengeStarted, error) {
	event := new(ArbRollupRollupChallengeStarted)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupConfirmedIterator is returned from FilterRollupConfirmed and is used to iterate over the raw logs and unpacked data for RollupConfirmed events raised by the ArbRollup contract.
type ArbRollupRollupConfirmedIterator struct {
	Event *ArbRollupRollupConfirmed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupConfirmedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupConfirmed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupConfirmed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupConfirmedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupConfirmedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupConfirmed represents a RollupConfirmed event raised by the ArbRollup contract.
type ArbRollupRollupConfirmed struct {
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupConfirmed is a free log retrieval operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupConfirmed(opts *bind.FilterOpts) (*ArbRollupRollupConfirmedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupConfirmedIterator{contract: _ArbRollup.contract, event: "RollupConfirmed", logs: logs, sub: sub}, nil
}

// WatchRollupConfirmed is a free log subscription operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupConfirmed(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupConfirmed) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupConfirmed)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupConfirmed is a log parse operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupConfirmed(log types.Log) (*ArbRollupRollupConfirmed, error) {
	event := new(ArbRollupRollupConfirmed)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupCreatedIterator is returned from FilterRollupCreated and is used to iterate over the raw logs and unpacked data for RollupCreated events raised by the ArbRollup contract.
type ArbRollupRollupCreatedIterator struct {
	Event *ArbRollupRollupCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupCreated represents a RollupCreated event raised by the ArbRollup contract.
type ArbRollupRollupCreated struct {
	InitVMHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupCreated is a free log retrieval operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupCreated(opts *bind.FilterOpts) (*ArbRollupRollupCreatedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupCreatedIterator{contract: _ArbRollup.contract, event: "RollupCreated", logs: logs, sub: sub}, nil
}

// WatchRollupCreated is a free log subscription operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupCreated(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupCreated) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupCreated)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupCreated is a log parse operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupCreated(log types.Log) (*ArbRollupRollupCreated, error) {
	event := new(ArbRollupRollupCreated)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupPrunedIterator is returned from FilterRollupPruned and is used to iterate over the raw logs and unpacked data for RollupPruned events raised by the ArbRollup contract.
type ArbRollupRollupPrunedIterator struct {
	Event *ArbRollupRollupPruned // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupPrunedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupPruned)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupPruned)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupPrunedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupPrunedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupPruned represents a RollupPruned event raised by the ArbRollup contract.
type ArbRollupRollupPruned struct {
	Leaf [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRollupPruned is a free log retrieval operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_ArbRollup *ArbRollupFilterer) FilterRollupPruned(opts *bind.FilterOpts) (*ArbRollupRollupPrunedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupPrunedIterator{contract: _ArbRollup.contract, event: "RollupPruned", logs: logs, sub: sub}, nil
}

// WatchRollupPruned is a free log subscription operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_ArbRollup *ArbRollupFilterer) WatchRollupPruned(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupPruned) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupPruned)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupPruned", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupPruned is a log parse operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_ArbRollup *ArbRollupFilterer) ParseRollupPruned(log types.Log) (*ArbRollupRollupPruned, error) {
	event := new(ArbRollupRollupPruned)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupPruned", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupStakeCreatedIterator is returned from FilterRollupStakeCreated and is used to iterate over the raw logs and unpacked data for RollupStakeCreated events raised by the ArbRollup contract.
type ArbRollupRollupStakeCreatedIterator struct {
	Event *ArbRollupRollupStakeCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupStakeCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupStakeCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupStakeCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupStakeCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupStakeCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupStakeCreated represents a RollupStakeCreated event raised by the ArbRollup contract.
type ArbRollupRollupStakeCreated struct {
	Staker   common.Address
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeCreated is a free log retrieval operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupStakeCreated(opts *bind.FilterOpts) (*ArbRollupRollupStakeCreatedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupStakeCreatedIterator{contract: _ArbRollup.contract, event: "RollupStakeCreated", logs: logs, sub: sub}, nil
}

// WatchRollupStakeCreated is a free log subscription operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupStakeCreated(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupStakeCreated) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupStakeCreated)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeCreated is a log parse operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupStakeCreated(log types.Log) (*ArbRollupRollupStakeCreated, error) {
	event := new(ArbRollupRollupStakeCreated)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupStakeMovedIterator is returned from FilterRollupStakeMoved and is used to iterate over the raw logs and unpacked data for RollupStakeMoved events raised by the ArbRollup contract.
type ArbRollupRollupStakeMovedIterator struct {
	Event *ArbRollupRollupStakeMoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupStakeMovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupStakeMoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupStakeMoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupStakeMovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupStakeMovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupStakeMoved represents a RollupStakeMoved event raised by the ArbRollup contract.
type ArbRollupRollupStakeMoved struct {
	Staker     common.Address
	ToNodeHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeMoved is a free log retrieval operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupStakeMoved(opts *bind.FilterOpts) (*ArbRollupRollupStakeMovedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupStakeMovedIterator{contract: _ArbRollup.contract, event: "RollupStakeMoved", logs: logs, sub: sub}, nil
}

// WatchRollupStakeMoved is a free log subscription operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupStakeMoved(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupStakeMoved) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupStakeMoved)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeMoved is a log parse operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupStakeMoved(log types.Log) (*ArbRollupRollupStakeMoved, error) {
	event := new(ArbRollupRollupStakeMoved)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupStakeRefundedIterator is returned from FilterRollupStakeRefunded and is used to iterate over the raw logs and unpacked data for RollupStakeRefunded events raised by the ArbRollup contract.
type ArbRollupRollupStakeRefundedIterator struct {
	Event *ArbRollupRollupStakeRefunded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupStakeRefundedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupStakeRefunded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupStakeRefunded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupStakeRefundedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupStakeRefundedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupStakeRefunded represents a RollupStakeRefunded event raised by the ArbRollup contract.
type ArbRollupRollupStakeRefunded struct {
	Staker common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeRefunded is a free log retrieval operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_ArbRollup *ArbRollupFilterer) FilterRollupStakeRefunded(opts *bind.FilterOpts) (*ArbRollupRollupStakeRefundedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupStakeRefundedIterator{contract: _ArbRollup.contract, event: "RollupStakeRefunded", logs: logs, sub: sub}, nil
}

// WatchRollupStakeRefunded is a free log subscription operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_ArbRollup *ArbRollupFilterer) WatchRollupStakeRefunded(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupStakeRefunded) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupStakeRefunded)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeRefunded is a log parse operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_ArbRollup *ArbRollupFilterer) ParseRollupStakeRefunded(log types.Log) (*ArbRollupRollupStakeRefunded, error) {
	event := new(ArbRollupRollupStakeRefunded)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbVMContractProxyABI is the input ABI used to generate the binding from.
const ArbVMContractProxyABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_arbChain\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]"

// ArbVMContractProxyBin is the compiled bytecode used for deploying new contracts.
var ArbVMContractProxyBin = "0x608060405234801561001057600080fd5b5060405161012c38038061012c8339818101604052602081101561003357600080fd5b5051600080546001600160a01b039092166001600160a01b031990921691909117905560c8806100646000396000f3fe608060408181526000805463c581831760e01b90935233608481815260a49384523660c48190526001600160a01b039095169463c5818317943494929060e4848480828437600081840152601f19601f8201169050808301925050509450505050506000604051808303818588803b158015607957600080fd5b505af1158015608c573d6000803e3d6000fd5b505050505000fea265627a7a723158201c0afa7d42a549becb25deca6f89c79f53ebcf88e5f3e5b326c2253af0ab4f9664736f6c63430005110032"

// DeployArbVMContractProxy deploys a new Ethereum contract, binding an instance of ArbVMContractProxy to it.
func DeployArbVMContractProxy(auth *bind.TransactOpts, backend bind.ContractBackend, _arbChain common.Address) (common.Address, *types.Transaction, *ArbVMContractProxy, error) {
	parsed, err := abi.JSON(strings.NewReader(ArbVMContractProxyABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ArbVMContractProxyBin), backend, _arbChain)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ArbVMContractProxy{ArbVMContractProxyCaller: ArbVMContractProxyCaller{contract: contract}, ArbVMContractProxyTransactor: ArbVMContractProxyTransactor{contract: contract}, ArbVMContractProxyFilterer: ArbVMContractProxyFilterer{contract: contract}}, nil
}

// ArbVMContractProxy is an auto generated Go binding around an Ethereum contract.
type ArbVMContractProxy struct {
	ArbVMContractProxyCaller     // Read-only binding to the contract
	ArbVMContractProxyTransactor // Write-only binding to the contract
	ArbVMContractProxyFilterer   // Log filterer for contract events
}

// ArbVMContractProxyCaller is an auto generated read-only Go binding around an Ethereum contract.
type ArbVMContractProxyCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbVMContractProxyTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ArbVMContractProxyTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbVMContractProxyFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ArbVMContractProxyFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbVMContractProxySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ArbVMContractProxySession struct {
	Contract     *ArbVMContractProxy // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ArbVMContractProxyCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ArbVMContractProxyCallerSession struct {
	Contract *ArbVMContractProxyCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// ArbVMContractProxyTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ArbVMContractProxyTransactorSession struct {
	Contract     *ArbVMContractProxyTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// ArbVMContractProxyRaw is an auto generated low-level Go binding around an Ethereum contract.
type ArbVMContractProxyRaw struct {
	Contract *ArbVMContractProxy // Generic contract binding to access the raw methods on
}

// ArbVMContractProxyCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ArbVMContractProxyCallerRaw struct {
	Contract *ArbVMContractProxyCaller // Generic read-only contract binding to access the raw methods on
}

// ArbVMContractProxyTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ArbVMContractProxyTransactorRaw struct {
	Contract *ArbVMContractProxyTransactor // Generic write-only contract binding to access the raw methods on
}

// NewArbVMContractProxy creates a new instance of ArbVMContractProxy, bound to a specific deployed contract.
func NewArbVMContractProxy(address common.Address, backend bind.ContractBackend) (*ArbVMContractProxy, error) {
	contract, err := bindArbVMContractProxy(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ArbVMContractProxy{ArbVMContractProxyCaller: ArbVMContractProxyCaller{contract: contract}, ArbVMContractProxyTransactor: ArbVMContractProxyTransactor{contract: contract}, ArbVMContractProxyFilterer: ArbVMContractProxyFilterer{contract: contract}}, nil
}

// NewArbVMContractProxyCaller creates a new read-only instance of ArbVMContractProxy, bound to a specific deployed contract.
func NewArbVMContractProxyCaller(address common.Address, caller bind.ContractCaller) (*ArbVMContractProxyCaller, error) {
	contract, err := bindArbVMContractProxy(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ArbVMContractProxyCaller{contract: contract}, nil
}

// NewArbVMContractProxyTransactor creates a new write-only instance of ArbVMContractProxy, bound to a specific deployed contract.
func NewArbVMContractProxyTransactor(address common.Address, transactor bind.ContractTransactor) (*ArbVMContractProxyTransactor, error) {
	contract, err := bindArbVMContractProxy(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ArbVMContractProxyTransactor{contract: contract}, nil
}

// NewArbVMContractProxyFilterer creates a new log filterer instance of ArbVMContractProxy, bound to a specific deployed contract.
func NewArbVMContractProxyFilterer(address common.Address, filterer bind.ContractFilterer) (*ArbVMContractProxyFilterer, error) {
	contract, err := bindArbVMContractProxy(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ArbVMContractProxyFilterer{contract: contract}, nil
}

// bindArbVMContractProxy binds a generic wrapper to an already deployed contract.
func bindArbVMContractProxy(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ArbVMContractProxyABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ArbVMContractProxy *ArbVMContractProxyRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ArbVMContractProxy.Contract.ArbVMContractProxyCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ArbVMContractProxy *ArbVMContractProxyRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbVMContractProxy.Contract.ArbVMContractProxyTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ArbVMContractProxy *ArbVMContractProxyRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ArbVMContractProxy.Contract.ArbVMContractProxyTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ArbVMContractProxy *ArbVMContractProxyCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ArbVMContractProxy.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ArbVMContractProxy *ArbVMContractProxyTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbVMContractProxy.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ArbVMContractProxy *ArbVMContractProxyTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ArbVMContractProxy.Contract.contract.Transact(opts, method, params...)
}

// Fallback is a paid mutator transaction binding the contract fallback function.
//
// Solidity: fallback() payable returns()
func (_ArbVMContractProxy *ArbVMContractProxyTransactor) Fallback(opts *bind.TransactOpts, calldata []byte) (*types.Transaction, error) {
	return _ArbVMContractProxy.contract.RawTransact(opts, calldata)
}

// Fallback is a paid mutator transaction binding the contract fallback function.
//
// Solidity: fallback() payable returns()
func (_ArbVMContractProxy *ArbVMContractProxySession) Fallback(calldata []byte) (*types.Transaction, error) {
	return _ArbVMContractProxy.Contract.Fallback(&_ArbVMContractProxy.TransactOpts, calldata)
}

// Fallback is a paid mutator transaction binding the contract fallback function.
//
// Solidity: fallback() payable returns()
func (_ArbVMContractProxy *ArbVMContractProxyTransactorSession) Fallback(calldata []byte) (*types.Transaction, error) {
	return _ArbVMContractProxy.Contract.Fallback(&_ArbVMContractProxy.TransactOpts, calldata)
}

// BytesLibABI is the input ABI used to generate the binding from.
const BytesLibABI = "[]"

// BytesLibBin is the compiled bytecode used for deploying new contracts.
var BytesLibBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820df1cab9f5706f831964c6cfc36e8d53dfb187147670225cce9914aa402e7580164736f6c63430005110032"

// DeployBytesLib deploys a new Ethereum contract, binding an instance of BytesLib to it.
func DeployBytesLib(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BytesLib, error) {
	parsed, err := abi.JSON(strings.NewReader(BytesLibABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(BytesLibBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BytesLib{BytesLibCaller: BytesLibCaller{contract: contract}, BytesLibTransactor: BytesLibTransactor{contract: contract}, BytesLibFilterer: BytesLibFilterer{contract: contract}}, nil
}

// BytesLib is an auto generated Go binding around an Ethereum contract.
type BytesLib struct {
	BytesLibCaller     // Read-only binding to the contract
	BytesLibTransactor // Write-only binding to the contract
	BytesLibFilterer   // Log filterer for contract events
}

// BytesLibCaller is an auto generated read-only Go binding around an Ethereum contract.
type BytesLibCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BytesLibTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BytesLibTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BytesLibFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BytesLibFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BytesLibSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BytesLibSession struct {
	Contract     *BytesLib         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BytesLibCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BytesLibCallerSession struct {
	Contract *BytesLibCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// BytesLibTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BytesLibTransactorSession struct {
	Contract     *BytesLibTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// BytesLibRaw is an auto generated low-level Go binding around an Ethereum contract.
type BytesLibRaw struct {
	Contract *BytesLib // Generic contract binding to access the raw methods on
}

// BytesLibCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BytesLibCallerRaw struct {
	Contract *BytesLibCaller // Generic read-only contract binding to access the raw methods on
}

// BytesLibTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BytesLibTransactorRaw struct {
	Contract *BytesLibTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBytesLib creates a new instance of BytesLib, bound to a specific deployed contract.
func NewBytesLib(address common.Address, backend bind.ContractBackend) (*BytesLib, error) {
	contract, err := bindBytesLib(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BytesLib{BytesLibCaller: BytesLibCaller{contract: contract}, BytesLibTransactor: BytesLibTransactor{contract: contract}, BytesLibFilterer: BytesLibFilterer{contract: contract}}, nil
}

// NewBytesLibCaller creates a new read-only instance of BytesLib, bound to a specific deployed contract.
func NewBytesLibCaller(address common.Address, caller bind.ContractCaller) (*BytesLibCaller, error) {
	contract, err := bindBytesLib(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BytesLibCaller{contract: contract}, nil
}

// NewBytesLibTransactor creates a new write-only instance of BytesLib, bound to a specific deployed contract.
func NewBytesLibTransactor(address common.Address, transactor bind.ContractTransactor) (*BytesLibTransactor, error) {
	contract, err := bindBytesLib(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BytesLibTransactor{contract: contract}, nil
}

// NewBytesLibFilterer creates a new log filterer instance of BytesLib, bound to a specific deployed contract.
func NewBytesLibFilterer(address common.Address, filterer bind.ContractFilterer) (*BytesLibFilterer, error) {
	contract, err := bindBytesLib(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BytesLibFilterer{contract: contract}, nil
}

// bindBytesLib binds a generic wrapper to an already deployed contract.
func bindBytesLib(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BytesLibABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BytesLib *BytesLibRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BytesLib.Contract.BytesLibCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BytesLib *BytesLibRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BytesLib.Contract.BytesLibTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BytesLib *BytesLibRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BytesLib.Contract.BytesLibTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BytesLib *BytesLibCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BytesLib.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BytesLib *BytesLibTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BytesLib.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BytesLib *BytesLibTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BytesLib.Contract.contract.Transact(opts, method, params...)
}

// ChallengeUtilsABI is the input ABI used to generate the binding from.
const ChallengeUtilsABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"INVALID_EXECUTION_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVALID_INBOX_TOP_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVALID_MESSAGES_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VALID_CHILD_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ChallengeUtilsFuncSigs maps the 4-byte function signature to its string representation.
var ChallengeUtilsFuncSigs = map[string]string{
	"95312727": "INVALID_EXECUTION_TYPE()",
	"a697bcac": "INVALID_INBOX_TOP_TYPE()",
	"d7519b46": "INVALID_MESSAGES_TYPE()",
	"2e179be5": "VALID_CHILD_TYPE()",
}

// ChallengeUtilsBin is the compiled bytecode used for deploying new contracts.
var ChallengeUtilsBin = "0x60c9610025600b82828239805160001a60731461001857fe5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361060515760003560e01c80632e179be51460565780639531272714606e578063a697bcac146074578063d7519b4614607a575b600080fd5b605c6080565b60408051918252519081900360200190f35b605c6085565b605c608a565b605c608f565b600381565b600281565b600081565b60018156fea265627a7a72315820c280990b95818baaf8ee3caded0e9484dbb4af3ca80c8d1a575334ffdc8d07fa64736f6c63430005110032"

// DeployChallengeUtils deploys a new Ethereum contract, binding an instance of ChallengeUtils to it.
func DeployChallengeUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ChallengeUtils, error) {
	parsed, err := abi.JSON(strings.NewReader(ChallengeUtilsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ChallengeUtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ChallengeUtils{ChallengeUtilsCaller: ChallengeUtilsCaller{contract: contract}, ChallengeUtilsTransactor: ChallengeUtilsTransactor{contract: contract}, ChallengeUtilsFilterer: ChallengeUtilsFilterer{contract: contract}}, nil
}

// ChallengeUtils is an auto generated Go binding around an Ethereum contract.
type ChallengeUtils struct {
	ChallengeUtilsCaller     // Read-only binding to the contract
	ChallengeUtilsTransactor // Write-only binding to the contract
	ChallengeUtilsFilterer   // Log filterer for contract events
}

// ChallengeUtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type ChallengeUtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeUtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ChallengeUtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeUtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ChallengeUtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeUtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ChallengeUtilsSession struct {
	Contract     *ChallengeUtils   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ChallengeUtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ChallengeUtilsCallerSession struct {
	Contract *ChallengeUtilsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// ChallengeUtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ChallengeUtilsTransactorSession struct {
	Contract     *ChallengeUtilsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// ChallengeUtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type ChallengeUtilsRaw struct {
	Contract *ChallengeUtils // Generic contract binding to access the raw methods on
}

// ChallengeUtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ChallengeUtilsCallerRaw struct {
	Contract *ChallengeUtilsCaller // Generic read-only contract binding to access the raw methods on
}

// ChallengeUtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ChallengeUtilsTransactorRaw struct {
	Contract *ChallengeUtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewChallengeUtils creates a new instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtils(address common.Address, backend bind.ContractBackend) (*ChallengeUtils, error) {
	contract, err := bindChallengeUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtils{ChallengeUtilsCaller: ChallengeUtilsCaller{contract: contract}, ChallengeUtilsTransactor: ChallengeUtilsTransactor{contract: contract}, ChallengeUtilsFilterer: ChallengeUtilsFilterer{contract: contract}}, nil
}

// NewChallengeUtilsCaller creates a new read-only instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtilsCaller(address common.Address, caller bind.ContractCaller) (*ChallengeUtilsCaller, error) {
	contract, err := bindChallengeUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtilsCaller{contract: contract}, nil
}

// NewChallengeUtilsTransactor creates a new write-only instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*ChallengeUtilsTransactor, error) {
	contract, err := bindChallengeUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtilsTransactor{contract: contract}, nil
}

// NewChallengeUtilsFilterer creates a new log filterer instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*ChallengeUtilsFilterer, error) {
	contract, err := bindChallengeUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtilsFilterer{contract: contract}, nil
}

// bindChallengeUtils binds a generic wrapper to an already deployed contract.
func bindChallengeUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ChallengeUtilsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ChallengeUtils *ChallengeUtilsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ChallengeUtils.Contract.ChallengeUtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ChallengeUtils *ChallengeUtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.ChallengeUtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ChallengeUtils *ChallengeUtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.ChallengeUtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ChallengeUtils *ChallengeUtilsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ChallengeUtils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ChallengeUtils *ChallengeUtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ChallengeUtils *ChallengeUtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.contract.Transact(opts, method, params...)
}

// INVALIDEXECUTIONTYPE is a free data retrieval call binding the contract method 0x95312727.
//
// Solidity: function INVALID_EXECUTION_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCaller) INVALIDEXECUTIONTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ChallengeUtils.contract.Call(opts, out, "INVALID_EXECUTION_TYPE")
	return *ret0, err
}

// INVALIDEXECUTIONTYPE is a free data retrieval call binding the contract method 0x95312727.
//
// Solidity: function INVALID_EXECUTION_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsSession) INVALIDEXECUTIONTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDEXECUTIONTYPE(&_ChallengeUtils.CallOpts)
}

// INVALIDEXECUTIONTYPE is a free data retrieval call binding the contract method 0x95312727.
//
// Solidity: function INVALID_EXECUTION_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCallerSession) INVALIDEXECUTIONTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDEXECUTIONTYPE(&_ChallengeUtils.CallOpts)
}

// INVALIDINBOXTOPTYPE is a free data retrieval call binding the contract method 0xa697bcac.
//
// Solidity: function INVALID_INBOX_TOP_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCaller) INVALIDINBOXTOPTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ChallengeUtils.contract.Call(opts, out, "INVALID_INBOX_TOP_TYPE")
	return *ret0, err
}

// INVALIDINBOXTOPTYPE is a free data retrieval call binding the contract method 0xa697bcac.
//
// Solidity: function INVALID_INBOX_TOP_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsSession) INVALIDINBOXTOPTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDINBOXTOPTYPE(&_ChallengeUtils.CallOpts)
}

// INVALIDINBOXTOPTYPE is a free data retrieval call binding the contract method 0xa697bcac.
//
// Solidity: function INVALID_INBOX_TOP_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCallerSession) INVALIDINBOXTOPTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDINBOXTOPTYPE(&_ChallengeUtils.CallOpts)
}

// INVALIDMESSAGESTYPE is a free data retrieval call binding the contract method 0xd7519b46.
//
// Solidity: function INVALID_MESSAGES_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCaller) INVALIDMESSAGESTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ChallengeUtils.contract.Call(opts, out, "INVALID_MESSAGES_TYPE")
	return *ret0, err
}

// INVALIDMESSAGESTYPE is a free data retrieval call binding the contract method 0xd7519b46.
//
// Solidity: function INVALID_MESSAGES_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsSession) INVALIDMESSAGESTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDMESSAGESTYPE(&_ChallengeUtils.CallOpts)
}

// INVALIDMESSAGESTYPE is a free data retrieval call binding the contract method 0xd7519b46.
//
// Solidity: function INVALID_MESSAGES_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCallerSession) INVALIDMESSAGESTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDMESSAGESTYPE(&_ChallengeUtils.CallOpts)
}

// VALIDCHILDTYPE is a free data retrieval call binding the contract method 0x2e179be5.
//
// Solidity: function VALID_CHILD_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCaller) VALIDCHILDTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ChallengeUtils.contract.Call(opts, out, "VALID_CHILD_TYPE")
	return *ret0, err
}

// VALIDCHILDTYPE is a free data retrieval call binding the contract method 0x2e179be5.
//
// Solidity: function VALID_CHILD_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsSession) VALIDCHILDTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.VALIDCHILDTYPE(&_ChallengeUtils.CallOpts)
}

// VALIDCHILDTYPE is a free data retrieval call binding the contract method 0x2e179be5.
//
// Solidity: function VALID_CHILD_TYPE() view returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCallerSession) VALIDCHILDTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.VALIDCHILDTYPE(&_ChallengeUtils.CallOpts)
}

// IArbRollupABI is the input ABI used to generate the binding from.
const IArbRollupABI = "[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"forwardContractMessage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_vmState\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"_gracePeriodTicks\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_arbGasSpeedLimitPerTick\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"_maxExecutionSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint64[2]\",\"name\":\"_maxTimeBoundsWidth\",\"type\":\"uint64[2]\"},{\"internalType\":\"uint128\",\"name\":\"_stakeRequirement\",\"type\":\"uint128\"},{\"internalType\":\"addresspayable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_challengeFactoryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_globalInboxAddress\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IArbRollupFuncSigs maps the 4-byte function signature to its string representation.
var IArbRollupFuncSigs = map[string]string{
	"c5818317": "forwardContractMessage(address,bytes)",
	"8e0f7167": "init(bytes32,uint128,uint128,uint64,uint64[2],uint128,address,address,address)",
}

// IArbRollup is an auto generated Go binding around an Ethereum contract.
type IArbRollup struct {
	IArbRollupCaller     // Read-only binding to the contract
	IArbRollupTransactor // Write-only binding to the contract
	IArbRollupFilterer   // Log filterer for contract events
}

// IArbRollupCaller is an auto generated read-only Go binding around an Ethereum contract.
type IArbRollupCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IArbRollupTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IArbRollupTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IArbRollupFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IArbRollupFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IArbRollupSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IArbRollupSession struct {
	Contract     *IArbRollup       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IArbRollupCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IArbRollupCallerSession struct {
	Contract *IArbRollupCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// IArbRollupTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IArbRollupTransactorSession struct {
	Contract     *IArbRollupTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IArbRollupRaw is an auto generated low-level Go binding around an Ethereum contract.
type IArbRollupRaw struct {
	Contract *IArbRollup // Generic contract binding to access the raw methods on
}

// IArbRollupCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IArbRollupCallerRaw struct {
	Contract *IArbRollupCaller // Generic read-only contract binding to access the raw methods on
}

// IArbRollupTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IArbRollupTransactorRaw struct {
	Contract *IArbRollupTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIArbRollup creates a new instance of IArbRollup, bound to a specific deployed contract.
func NewIArbRollup(address common.Address, backend bind.ContractBackend) (*IArbRollup, error) {
	contract, err := bindIArbRollup(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IArbRollup{IArbRollupCaller: IArbRollupCaller{contract: contract}, IArbRollupTransactor: IArbRollupTransactor{contract: contract}, IArbRollupFilterer: IArbRollupFilterer{contract: contract}}, nil
}

// NewIArbRollupCaller creates a new read-only instance of IArbRollup, bound to a specific deployed contract.
func NewIArbRollupCaller(address common.Address, caller bind.ContractCaller) (*IArbRollupCaller, error) {
	contract, err := bindIArbRollup(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IArbRollupCaller{contract: contract}, nil
}

// NewIArbRollupTransactor creates a new write-only instance of IArbRollup, bound to a specific deployed contract.
func NewIArbRollupTransactor(address common.Address, transactor bind.ContractTransactor) (*IArbRollupTransactor, error) {
	contract, err := bindIArbRollup(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IArbRollupTransactor{contract: contract}, nil
}

// NewIArbRollupFilterer creates a new log filterer instance of IArbRollup, bound to a specific deployed contract.
func NewIArbRollupFilterer(address common.Address, filterer bind.ContractFilterer) (*IArbRollupFilterer, error) {
	contract, err := bindIArbRollup(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IArbRollupFilterer{contract: contract}, nil
}

// bindIArbRollup binds a generic wrapper to an already deployed contract.
func bindIArbRollup(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IArbRollupABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IArbRollup *IArbRollupRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IArbRollup.Contract.IArbRollupCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IArbRollup *IArbRollupRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IArbRollup.Contract.IArbRollupTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IArbRollup *IArbRollupRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IArbRollup.Contract.IArbRollupTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IArbRollup *IArbRollupCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IArbRollup.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IArbRollup *IArbRollupTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IArbRollup.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IArbRollup *IArbRollupTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IArbRollup.Contract.contract.Transact(opts, method, params...)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) payable returns()
func (_IArbRollup *IArbRollupTransactor) ForwardContractMessage(opts *bind.TransactOpts, _sender common.Address, _data []byte) (*types.Transaction, error) {
	return _IArbRollup.contract.Transact(opts, "forwardContractMessage", _sender, _data)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) payable returns()
func (_IArbRollup *IArbRollupSession) ForwardContractMessage(_sender common.Address, _data []byte) (*types.Transaction, error) {
	return _IArbRollup.Contract.ForwardContractMessage(&_IArbRollup.TransactOpts, _sender, _data)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) payable returns()
func (_IArbRollup *IArbRollupTransactorSession) ForwardContractMessage(_sender common.Address, _data []byte) (*types.Transaction, error) {
	return _IArbRollup.Contract.ForwardContractMessage(&_IArbRollup.TransactOpts, _sender, _data)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_IArbRollup *IArbRollupTransactor) Init(opts *bind.TransactOpts, _vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _IArbRollup.contract.Transact(opts, "init", _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_IArbRollup *IArbRollupSession) Init(_vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _IArbRollup.Contract.Init(&_IArbRollup.TransactOpts, _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_IArbRollup *IArbRollupTransactorSession) Init(_vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _IArbRollup.Contract.Init(&_IArbRollup.TransactOpts, _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// IChallengeFactoryABI is the input ABI used to generate the binding from.
const IChallengeFactoryABI = "[{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"_asserter\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"_challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_challengePeriodTicks\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_challengeHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"}],\"name\":\"createChallenge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asserter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"}],\"name\":\"generateCloneAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// IChallengeFactoryFuncSigs maps the 4-byte function signature to its string representation.
var IChallengeFactoryFuncSigs = map[string]string{
	"865da1c2": "createChallenge(address,address,uint256,bytes32,uint256)",
	"729406c8": "generateCloneAddress(address,address,uint256)",
}

// IChallengeFactory is an auto generated Go binding around an Ethereum contract.
type IChallengeFactory struct {
	IChallengeFactoryCaller     // Read-only binding to the contract
	IChallengeFactoryTransactor // Write-only binding to the contract
	IChallengeFactoryFilterer   // Log filterer for contract events
}

// IChallengeFactoryCaller is an auto generated read-only Go binding around an Ethereum contract.
type IChallengeFactoryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IChallengeFactoryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IChallengeFactoryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IChallengeFactoryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IChallengeFactoryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IChallengeFactorySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IChallengeFactorySession struct {
	Contract     *IChallengeFactory // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IChallengeFactoryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IChallengeFactoryCallerSession struct {
	Contract *IChallengeFactoryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// IChallengeFactoryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IChallengeFactoryTransactorSession struct {
	Contract     *IChallengeFactoryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// IChallengeFactoryRaw is an auto generated low-level Go binding around an Ethereum contract.
type IChallengeFactoryRaw struct {
	Contract *IChallengeFactory // Generic contract binding to access the raw methods on
}

// IChallengeFactoryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IChallengeFactoryCallerRaw struct {
	Contract *IChallengeFactoryCaller // Generic read-only contract binding to access the raw methods on
}

// IChallengeFactoryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IChallengeFactoryTransactorRaw struct {
	Contract *IChallengeFactoryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIChallengeFactory creates a new instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactory(address common.Address, backend bind.ContractBackend) (*IChallengeFactory, error) {
	contract, err := bindIChallengeFactory(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactory{IChallengeFactoryCaller: IChallengeFactoryCaller{contract: contract}, IChallengeFactoryTransactor: IChallengeFactoryTransactor{contract: contract}, IChallengeFactoryFilterer: IChallengeFactoryFilterer{contract: contract}}, nil
}

// NewIChallengeFactoryCaller creates a new read-only instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactoryCaller(address common.Address, caller bind.ContractCaller) (*IChallengeFactoryCaller, error) {
	contract, err := bindIChallengeFactory(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactoryCaller{contract: contract}, nil
}

// NewIChallengeFactoryTransactor creates a new write-only instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactoryTransactor(address common.Address, transactor bind.ContractTransactor) (*IChallengeFactoryTransactor, error) {
	contract, err := bindIChallengeFactory(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactoryTransactor{contract: contract}, nil
}

// NewIChallengeFactoryFilterer creates a new log filterer instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactoryFilterer(address common.Address, filterer bind.ContractFilterer) (*IChallengeFactoryFilterer, error) {
	contract, err := bindIChallengeFactory(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactoryFilterer{contract: contract}, nil
}

// bindIChallengeFactory binds a generic wrapper to an already deployed contract.
func bindIChallengeFactory(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IChallengeFactoryABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IChallengeFactory *IChallengeFactoryRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IChallengeFactory.Contract.IChallengeFactoryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IChallengeFactory *IChallengeFactoryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.IChallengeFactoryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IChallengeFactory *IChallengeFactoryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.IChallengeFactoryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IChallengeFactory *IChallengeFactoryCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IChallengeFactory.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IChallengeFactory *IChallengeFactoryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IChallengeFactory *IChallengeFactoryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.contract.Transact(opts, method, params...)
}

// GenerateCloneAddress is a free data retrieval call binding the contract method 0x729406c8.
//
// Solidity: function generateCloneAddress(address asserter, address challenger, uint256 challengeType) view returns(address)
func (_IChallengeFactory *IChallengeFactoryCaller) GenerateCloneAddress(opts *bind.CallOpts, asserter common.Address, challenger common.Address, challengeType *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _IChallengeFactory.contract.Call(opts, out, "generateCloneAddress", asserter, challenger, challengeType)
	return *ret0, err
}

// GenerateCloneAddress is a free data retrieval call binding the contract method 0x729406c8.
//
// Solidity: function generateCloneAddress(address asserter, address challenger, uint256 challengeType) view returns(address)
func (_IChallengeFactory *IChallengeFactorySession) GenerateCloneAddress(asserter common.Address, challenger common.Address, challengeType *big.Int) (common.Address, error) {
	return _IChallengeFactory.Contract.GenerateCloneAddress(&_IChallengeFactory.CallOpts, asserter, challenger, challengeType)
}

// GenerateCloneAddress is a free data retrieval call binding the contract method 0x729406c8.
//
// Solidity: function generateCloneAddress(address asserter, address challenger, uint256 challengeType) view returns(address)
func (_IChallengeFactory *IChallengeFactoryCallerSession) GenerateCloneAddress(asserter common.Address, challenger common.Address, challengeType *big.Int) (common.Address, error) {
	return _IChallengeFactory.Contract.GenerateCloneAddress(&_IChallengeFactory.CallOpts, asserter, challenger, challengeType)
}

// CreateChallenge is a paid mutator transaction binding the contract method 0x865da1c2.
//
// Solidity: function createChallenge(address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeHash, uint256 challengeType) returns(address)
func (_IChallengeFactory *IChallengeFactoryTransactor) CreateChallenge(opts *bind.TransactOpts, _asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeHash [32]byte, challengeType *big.Int) (*types.Transaction, error) {
	return _IChallengeFactory.contract.Transact(opts, "createChallenge", _asserter, _challenger, _challengePeriodTicks, _challengeHash, challengeType)
}

// CreateChallenge is a paid mutator transaction binding the contract method 0x865da1c2.
//
// Solidity: function createChallenge(address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeHash, uint256 challengeType) returns(address)
func (_IChallengeFactory *IChallengeFactorySession) CreateChallenge(_asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeHash [32]byte, challengeType *big.Int) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.CreateChallenge(&_IChallengeFactory.TransactOpts, _asserter, _challenger, _challengePeriodTicks, _challengeHash, challengeType)
}

// CreateChallenge is a paid mutator transaction binding the contract method 0x865da1c2.
//
// Solidity: function createChallenge(address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeHash, uint256 challengeType) returns(address)
func (_IChallengeFactory *IChallengeFactoryTransactorSession) CreateChallenge(_asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeHash [32]byte, challengeType *big.Int) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.CreateChallenge(&_IChallengeFactory.TransactOpts, _asserter, _challenger, _challengePeriodTicks, _challengeHash, challengeType)
}

// IGlobalInboxABI is the input ABI used to generate the binding from.
const IGlobalInboxABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"ContractTransactionMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"ERC20DepositMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc721\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"ERC721DepositMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"EthDepositMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"}],\"name\":\"TransactionMessageBatchDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seqNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"TransactionMessageDelivered\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositERC20Message\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc721\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositERC721Message\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"depositEthMessage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"forwardContractTransactionMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"forwardEthMessage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getInbox\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_messages\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"messageCounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"nodeHashes\",\"type\":\"bytes32[]\"}],\"name\":\"sendMessages\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seqNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"sendTransactionMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IGlobalInboxFuncSigs maps the 4-byte function signature to its string representation.
var IGlobalInboxFuncSigs = map[string]string{
	"bca22b76": "depositERC20Message(address,address,address,uint256)",
	"8b7010aa": "depositERC721Message(address,address,address,uint256)",
	"5bd21290": "depositEthMessage(address,address)",
	"84cb7997": "forwardContractTransactionMessage(address,address,uint256,bytes)",
	"96588a27": "forwardEthMessage(address,address)",
	"02201681": "getInbox(address)",
	"072fd2bb": "sendMessages(bytes,uint256[],bytes32[])",
	"8f5ed73e": "sendTransactionMessage(address,address,uint256,uint256,bytes)",
}

// IGlobalInbox is an auto generated Go binding around an Ethereum contract.
type IGlobalInbox struct {
	IGlobalInboxCaller     // Read-only binding to the contract
	IGlobalInboxTransactor // Write-only binding to the contract
	IGlobalInboxFilterer   // Log filterer for contract events
}

// IGlobalInboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type IGlobalInboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGlobalInboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IGlobalInboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGlobalInboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IGlobalInboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGlobalInboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IGlobalInboxSession struct {
	Contract     *IGlobalInbox     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IGlobalInboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IGlobalInboxCallerSession struct {
	Contract *IGlobalInboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IGlobalInboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IGlobalInboxTransactorSession struct {
	Contract     *IGlobalInboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IGlobalInboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type IGlobalInboxRaw struct {
	Contract *IGlobalInbox // Generic contract binding to access the raw methods on
}

// IGlobalInboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IGlobalInboxCallerRaw struct {
	Contract *IGlobalInboxCaller // Generic read-only contract binding to access the raw methods on
}

// IGlobalInboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IGlobalInboxTransactorRaw struct {
	Contract *IGlobalInboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIGlobalInbox creates a new instance of IGlobalInbox, bound to a specific deployed contract.
func NewIGlobalInbox(address common.Address, backend bind.ContractBackend) (*IGlobalInbox, error) {
	contract, err := bindIGlobalInbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IGlobalInbox{IGlobalInboxCaller: IGlobalInboxCaller{contract: contract}, IGlobalInboxTransactor: IGlobalInboxTransactor{contract: contract}, IGlobalInboxFilterer: IGlobalInboxFilterer{contract: contract}}, nil
}

// NewIGlobalInboxCaller creates a new read-only instance of IGlobalInbox, bound to a specific deployed contract.
func NewIGlobalInboxCaller(address common.Address, caller bind.ContractCaller) (*IGlobalInboxCaller, error) {
	contract, err := bindIGlobalInbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxCaller{contract: contract}, nil
}

// NewIGlobalInboxTransactor creates a new write-only instance of IGlobalInbox, bound to a specific deployed contract.
func NewIGlobalInboxTransactor(address common.Address, transactor bind.ContractTransactor) (*IGlobalInboxTransactor, error) {
	contract, err := bindIGlobalInbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxTransactor{contract: contract}, nil
}

// NewIGlobalInboxFilterer creates a new log filterer instance of IGlobalInbox, bound to a specific deployed contract.
func NewIGlobalInboxFilterer(address common.Address, filterer bind.ContractFilterer) (*IGlobalInboxFilterer, error) {
	contract, err := bindIGlobalInbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxFilterer{contract: contract}, nil
}

// bindIGlobalInbox binds a generic wrapper to an already deployed contract.
func bindIGlobalInbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IGlobalInboxABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IGlobalInbox *IGlobalInboxRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IGlobalInbox.Contract.IGlobalInboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IGlobalInbox *IGlobalInboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.IGlobalInboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IGlobalInbox *IGlobalInboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.IGlobalInboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IGlobalInbox *IGlobalInboxCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IGlobalInbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IGlobalInbox *IGlobalInboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IGlobalInbox *IGlobalInboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.contract.Transact(opts, method, params...)
}

// GetInbox is a free data retrieval call binding the contract method 0x02201681.
//
// Solidity: function getInbox(address account) view returns(bytes32, uint256)
func (_IGlobalInbox *IGlobalInboxCaller) GetInbox(opts *bind.CallOpts, account common.Address) ([32]byte, *big.Int, error) {
	var (
		ret0 = new([32]byte)
		ret1 = new(*big.Int)
	)
	out := &[]interface{}{
		ret0,
		ret1,
	}
	err := _IGlobalInbox.contract.Call(opts, out, "getInbox", account)
	return *ret0, *ret1, err
}

// GetInbox is a free data retrieval call binding the contract method 0x02201681.
//
// Solidity: function getInbox(address account) view returns(bytes32, uint256)
func (_IGlobalInbox *IGlobalInboxSession) GetInbox(account common.Address) ([32]byte, *big.Int, error) {
	return _IGlobalInbox.Contract.GetInbox(&_IGlobalInbox.CallOpts, account)
}

// GetInbox is a free data retrieval call binding the contract method 0x02201681.
//
// Solidity: function getInbox(address account) view returns(bytes32, uint256)
func (_IGlobalInbox *IGlobalInboxCallerSession) GetInbox(account common.Address) ([32]byte, *big.Int, error) {
	return _IGlobalInbox.Contract.GetInbox(&_IGlobalInbox.CallOpts, account)
}

// DepositERC20Message is a paid mutator transaction binding the contract method 0xbca22b76.
//
// Solidity: function depositERC20Message(address _chain, address _to, address _erc20, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) DepositERC20Message(opts *bind.TransactOpts, _chain common.Address, _to common.Address, _erc20 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "depositERC20Message", _chain, _to, _erc20, _value)
}

// DepositERC20Message is a paid mutator transaction binding the contract method 0xbca22b76.
//
// Solidity: function depositERC20Message(address _chain, address _to, address _erc20, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxSession) DepositERC20Message(_chain common.Address, _to common.Address, _erc20 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositERC20Message(&_IGlobalInbox.TransactOpts, _chain, _to, _erc20, _value)
}

// DepositERC20Message is a paid mutator transaction binding the contract method 0xbca22b76.
//
// Solidity: function depositERC20Message(address _chain, address _to, address _erc20, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) DepositERC20Message(_chain common.Address, _to common.Address, _erc20 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositERC20Message(&_IGlobalInbox.TransactOpts, _chain, _to, _erc20, _value)
}

// DepositERC721Message is a paid mutator transaction binding the contract method 0x8b7010aa.
//
// Solidity: function depositERC721Message(address _chain, address _to, address _erc721, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) DepositERC721Message(opts *bind.TransactOpts, _chain common.Address, _to common.Address, _erc721 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "depositERC721Message", _chain, _to, _erc721, _value)
}

// DepositERC721Message is a paid mutator transaction binding the contract method 0x8b7010aa.
//
// Solidity: function depositERC721Message(address _chain, address _to, address _erc721, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxSession) DepositERC721Message(_chain common.Address, _to common.Address, _erc721 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositERC721Message(&_IGlobalInbox.TransactOpts, _chain, _to, _erc721, _value)
}

// DepositERC721Message is a paid mutator transaction binding the contract method 0x8b7010aa.
//
// Solidity: function depositERC721Message(address _chain, address _to, address _erc721, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) DepositERC721Message(_chain common.Address, _to common.Address, _erc721 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositERC721Message(&_IGlobalInbox.TransactOpts, _chain, _to, _erc721, _value)
}

// DepositEthMessage is a paid mutator transaction binding the contract method 0x5bd21290.
//
// Solidity: function depositEthMessage(address _chain, address _to) payable returns()
func (_IGlobalInbox *IGlobalInboxTransactor) DepositEthMessage(opts *bind.TransactOpts, _chain common.Address, _to common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "depositEthMessage", _chain, _to)
}

// DepositEthMessage is a paid mutator transaction binding the contract method 0x5bd21290.
//
// Solidity: function depositEthMessage(address _chain, address _to) payable returns()
func (_IGlobalInbox *IGlobalInboxSession) DepositEthMessage(_chain common.Address, _to common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositEthMessage(&_IGlobalInbox.TransactOpts, _chain, _to)
}

// DepositEthMessage is a paid mutator transaction binding the contract method 0x5bd21290.
//
// Solidity: function depositEthMessage(address _chain, address _to) payable returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) DepositEthMessage(_chain common.Address, _to common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositEthMessage(&_IGlobalInbox.TransactOpts, _chain, _to)
}

// ForwardContractTransactionMessage is a paid mutator transaction binding the contract method 0x84cb7997.
//
// Solidity: function forwardContractTransactionMessage(address _to, address _from, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) ForwardContractTransactionMessage(opts *bind.TransactOpts, _to common.Address, _from common.Address, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "forwardContractTransactionMessage", _to, _from, _value, _data)
}

// ForwardContractTransactionMessage is a paid mutator transaction binding the contract method 0x84cb7997.
//
// Solidity: function forwardContractTransactionMessage(address _to, address _from, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxSession) ForwardContractTransactionMessage(_to common.Address, _from common.Address, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.ForwardContractTransactionMessage(&_IGlobalInbox.TransactOpts, _to, _from, _value, _data)
}

// ForwardContractTransactionMessage is a paid mutator transaction binding the contract method 0x84cb7997.
//
// Solidity: function forwardContractTransactionMessage(address _to, address _from, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) ForwardContractTransactionMessage(_to common.Address, _from common.Address, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.ForwardContractTransactionMessage(&_IGlobalInbox.TransactOpts, _to, _from, _value, _data)
}

// ForwardEthMessage is a paid mutator transaction binding the contract method 0x96588a27.
//
// Solidity: function forwardEthMessage(address _to, address _from) payable returns()
func (_IGlobalInbox *IGlobalInboxTransactor) ForwardEthMessage(opts *bind.TransactOpts, _to common.Address, _from common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "forwardEthMessage", _to, _from)
}

// ForwardEthMessage is a paid mutator transaction binding the contract method 0x96588a27.
//
// Solidity: function forwardEthMessage(address _to, address _from) payable returns()
func (_IGlobalInbox *IGlobalInboxSession) ForwardEthMessage(_to common.Address, _from common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.ForwardEthMessage(&_IGlobalInbox.TransactOpts, _to, _from)
}

// ForwardEthMessage is a paid mutator transaction binding the contract method 0x96588a27.
//
// Solidity: function forwardEthMessage(address _to, address _from) payable returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) ForwardEthMessage(_to common.Address, _from common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.ForwardEthMessage(&_IGlobalInbox.TransactOpts, _to, _from)
}

// SendMessages is a paid mutator transaction binding the contract method 0x072fd2bb.
//
// Solidity: function sendMessages(bytes _messages, uint256[] messageCounts, bytes32[] nodeHashes) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) SendMessages(opts *bind.TransactOpts, _messages []byte, messageCounts []*big.Int, nodeHashes [][32]byte) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "sendMessages", _messages, messageCounts, nodeHashes)
}

// SendMessages is a paid mutator transaction binding the contract method 0x072fd2bb.
//
// Solidity: function sendMessages(bytes _messages, uint256[] messageCounts, bytes32[] nodeHashes) returns()
func (_IGlobalInbox *IGlobalInboxSession) SendMessages(_messages []byte, messageCounts []*big.Int, nodeHashes [][32]byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.SendMessages(&_IGlobalInbox.TransactOpts, _messages, messageCounts, nodeHashes)
}

// SendMessages is a paid mutator transaction binding the contract method 0x072fd2bb.
//
// Solidity: function sendMessages(bytes _messages, uint256[] messageCounts, bytes32[] nodeHashes) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) SendMessages(_messages []byte, messageCounts []*big.Int, nodeHashes [][32]byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.SendMessages(&_IGlobalInbox.TransactOpts, _messages, messageCounts, nodeHashes)
}

// SendTransactionMessage is a paid mutator transaction binding the contract method 0x8f5ed73e.
//
// Solidity: function sendTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) SendTransactionMessage(opts *bind.TransactOpts, _chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "sendTransactionMessage", _chain, _to, _seqNumber, _value, _data)
}

// SendTransactionMessage is a paid mutator transaction binding the contract method 0x8f5ed73e.
//
// Solidity: function sendTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxSession) SendTransactionMessage(_chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.SendTransactionMessage(&_IGlobalInbox.TransactOpts, _chain, _to, _seqNumber, _value, _data)
}

// SendTransactionMessage is a paid mutator transaction binding the contract method 0x8f5ed73e.
//
// Solidity: function sendTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) SendTransactionMessage(_chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.SendTransactionMessage(&_IGlobalInbox.TransactOpts, _chain, _to, _seqNumber, _value, _data)
}

// IGlobalInboxContractTransactionMessageDeliveredIterator is returned from FilterContractTransactionMessageDelivered and is used to iterate over the raw logs and unpacked data for ContractTransactionMessageDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxContractTransactionMessageDeliveredIterator struct {
	Event *IGlobalInboxContractTransactionMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxContractTransactionMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxContractTransactionMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxContractTransactionMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxContractTransactionMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxContractTransactionMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxContractTransactionMessageDelivered represents a ContractTransactionMessageDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxContractTransactionMessageDelivered struct {
	Chain      common.Address
	To         common.Address
	From       common.Address
	Value      *big.Int
	Data       []byte
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterContractTransactionMessageDelivered is a free log retrieval operation binding the contract event 0x362b3acbdbf0277aefa83754ea8d39fc1c55d01d9351cf78969923f8cfee612c.
//
// Solidity: event ContractTransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, bytes data, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterContractTransactionMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalInboxContractTransactionMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "ContractTransactionMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxContractTransactionMessageDeliveredIterator{contract: _IGlobalInbox.contract, event: "ContractTransactionMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchContractTransactionMessageDelivered is a free log subscription operation binding the contract event 0x362b3acbdbf0277aefa83754ea8d39fc1c55d01d9351cf78969923f8cfee612c.
//
// Solidity: event ContractTransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, bytes data, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchContractTransactionMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxContractTransactionMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "ContractTransactionMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxContractTransactionMessageDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "ContractTransactionMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseContractTransactionMessageDelivered is a log parse operation binding the contract event 0x362b3acbdbf0277aefa83754ea8d39fc1c55d01d9351cf78969923f8cfee612c.
//
// Solidity: event ContractTransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, bytes data, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseContractTransactionMessageDelivered(log types.Log) (*IGlobalInboxContractTransactionMessageDelivered, error) {
	event := new(IGlobalInboxContractTransactionMessageDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "ContractTransactionMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalInboxERC20DepositMessageDeliveredIterator is returned from FilterERC20DepositMessageDelivered and is used to iterate over the raw logs and unpacked data for ERC20DepositMessageDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxERC20DepositMessageDeliveredIterator struct {
	Event *IGlobalInboxERC20DepositMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxERC20DepositMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxERC20DepositMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxERC20DepositMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxERC20DepositMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxERC20DepositMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxERC20DepositMessageDelivered represents a ERC20DepositMessageDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxERC20DepositMessageDelivered struct {
	Chain      common.Address
	To         common.Address
	From       common.Address
	Erc20      common.Address
	Value      *big.Int
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterERC20DepositMessageDelivered is a free log retrieval operation binding the contract event 0xb13d04085b4a9f87fecfccf9b72081bb8a273498d6b08b4bccf2940d555b5e60.
//
// Solidity: event ERC20DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc20, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterERC20DepositMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalInboxERC20DepositMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "ERC20DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxERC20DepositMessageDeliveredIterator{contract: _IGlobalInbox.contract, event: "ERC20DepositMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchERC20DepositMessageDelivered is a free log subscription operation binding the contract event 0xb13d04085b4a9f87fecfccf9b72081bb8a273498d6b08b4bccf2940d555b5e60.
//
// Solidity: event ERC20DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc20, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchERC20DepositMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxERC20DepositMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "ERC20DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxERC20DepositMessageDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "ERC20DepositMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC20DepositMessageDelivered is a log parse operation binding the contract event 0xb13d04085b4a9f87fecfccf9b72081bb8a273498d6b08b4bccf2940d555b5e60.
//
// Solidity: event ERC20DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc20, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseERC20DepositMessageDelivered(log types.Log) (*IGlobalInboxERC20DepositMessageDelivered, error) {
	event := new(IGlobalInboxERC20DepositMessageDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "ERC20DepositMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalInboxERC721DepositMessageDeliveredIterator is returned from FilterERC721DepositMessageDelivered and is used to iterate over the raw logs and unpacked data for ERC721DepositMessageDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxERC721DepositMessageDeliveredIterator struct {
	Event *IGlobalInboxERC721DepositMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxERC721DepositMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxERC721DepositMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxERC721DepositMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxERC721DepositMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxERC721DepositMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxERC721DepositMessageDelivered represents a ERC721DepositMessageDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxERC721DepositMessageDelivered struct {
	Chain      common.Address
	To         common.Address
	From       common.Address
	Erc721     common.Address
	Id         *big.Int
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterERC721DepositMessageDelivered is a free log retrieval operation binding the contract event 0x40baf11a4a4a4be2a155dbf303fbaec6fabd52e267268bd7e3de4b4ed8a2e095.
//
// Solidity: event ERC721DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc721, uint256 id, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterERC721DepositMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalInboxERC721DepositMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "ERC721DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxERC721DepositMessageDeliveredIterator{contract: _IGlobalInbox.contract, event: "ERC721DepositMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchERC721DepositMessageDelivered is a free log subscription operation binding the contract event 0x40baf11a4a4a4be2a155dbf303fbaec6fabd52e267268bd7e3de4b4ed8a2e095.
//
// Solidity: event ERC721DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc721, uint256 id, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchERC721DepositMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxERC721DepositMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "ERC721DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxERC721DepositMessageDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "ERC721DepositMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC721DepositMessageDelivered is a log parse operation binding the contract event 0x40baf11a4a4a4be2a155dbf303fbaec6fabd52e267268bd7e3de4b4ed8a2e095.
//
// Solidity: event ERC721DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc721, uint256 id, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseERC721DepositMessageDelivered(log types.Log) (*IGlobalInboxERC721DepositMessageDelivered, error) {
	event := new(IGlobalInboxERC721DepositMessageDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "ERC721DepositMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalInboxEthDepositMessageDeliveredIterator is returned from FilterEthDepositMessageDelivered and is used to iterate over the raw logs and unpacked data for EthDepositMessageDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxEthDepositMessageDeliveredIterator struct {
	Event *IGlobalInboxEthDepositMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxEthDepositMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxEthDepositMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxEthDepositMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxEthDepositMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxEthDepositMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxEthDepositMessageDelivered represents a EthDepositMessageDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxEthDepositMessageDelivered struct {
	Chain      common.Address
	To         common.Address
	From       common.Address
	Value      *big.Int
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterEthDepositMessageDelivered is a free log retrieval operation binding the contract event 0xfd0d0553177fec183128f048fbde54554a3a67302f7ebd7f735215a358290705.
//
// Solidity: event EthDepositMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterEthDepositMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalInboxEthDepositMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "EthDepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxEthDepositMessageDeliveredIterator{contract: _IGlobalInbox.contract, event: "EthDepositMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchEthDepositMessageDelivered is a free log subscription operation binding the contract event 0xfd0d0553177fec183128f048fbde54554a3a67302f7ebd7f735215a358290705.
//
// Solidity: event EthDepositMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchEthDepositMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxEthDepositMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "EthDepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxEthDepositMessageDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "EthDepositMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEthDepositMessageDelivered is a log parse operation binding the contract event 0xfd0d0553177fec183128f048fbde54554a3a67302f7ebd7f735215a358290705.
//
// Solidity: event EthDepositMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseEthDepositMessageDelivered(log types.Log) (*IGlobalInboxEthDepositMessageDelivered, error) {
	event := new(IGlobalInboxEthDepositMessageDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "EthDepositMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalInboxTransactionMessageBatchDeliveredIterator is returned from FilterTransactionMessageBatchDelivered and is used to iterate over the raw logs and unpacked data for TransactionMessageBatchDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxTransactionMessageBatchDeliveredIterator struct {
	Event *IGlobalInboxTransactionMessageBatchDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxTransactionMessageBatchDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxTransactionMessageBatchDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxTransactionMessageBatchDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxTransactionMessageBatchDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxTransactionMessageBatchDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxTransactionMessageBatchDelivered represents a TransactionMessageBatchDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxTransactionMessageBatchDelivered struct {
	Chain common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransactionMessageBatchDelivered is a free log retrieval operation binding the contract event 0x9cd591b0e52bcf1c506475ee03776192ea3d99f35150ef6651b339333b7372c4.
//
// Solidity: event TransactionMessageBatchDelivered(address indexed chain)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterTransactionMessageBatchDelivered(opts *bind.FilterOpts, chain []common.Address) (*IGlobalInboxTransactionMessageBatchDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "TransactionMessageBatchDelivered", chainRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxTransactionMessageBatchDeliveredIterator{contract: _IGlobalInbox.contract, event: "TransactionMessageBatchDelivered", logs: logs, sub: sub}, nil
}

// WatchTransactionMessageBatchDelivered is a free log subscription operation binding the contract event 0x9cd591b0e52bcf1c506475ee03776192ea3d99f35150ef6651b339333b7372c4.
//
// Solidity: event TransactionMessageBatchDelivered(address indexed chain)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchTransactionMessageBatchDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxTransactionMessageBatchDelivered, chain []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "TransactionMessageBatchDelivered", chainRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxTransactionMessageBatchDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "TransactionMessageBatchDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransactionMessageBatchDelivered is a log parse operation binding the contract event 0x9cd591b0e52bcf1c506475ee03776192ea3d99f35150ef6651b339333b7372c4.
//
// Solidity: event TransactionMessageBatchDelivered(address indexed chain)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseTransactionMessageBatchDelivered(log types.Log) (*IGlobalInboxTransactionMessageBatchDelivered, error) {
	event := new(IGlobalInboxTransactionMessageBatchDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "TransactionMessageBatchDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalInboxTransactionMessageDeliveredIterator is returned from FilterTransactionMessageDelivered and is used to iterate over the raw logs and unpacked data for TransactionMessageDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxTransactionMessageDeliveredIterator struct {
	Event *IGlobalInboxTransactionMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxTransactionMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxTransactionMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxTransactionMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxTransactionMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxTransactionMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxTransactionMessageDelivered represents a TransactionMessageDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxTransactionMessageDelivered struct {
	Chain     common.Address
	To        common.Address
	From      common.Address
	SeqNumber *big.Int
	Value     *big.Int
	Data      []byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterTransactionMessageDelivered is a free log retrieval operation binding the contract event 0xcf612c95e8993eca9c6e0be96b26b47022996db601dc12b4cf68ec37829d87b3.
//
// Solidity: event TransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 seqNumber, uint256 value, bytes data)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterTransactionMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalInboxTransactionMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "TransactionMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxTransactionMessageDeliveredIterator{contract: _IGlobalInbox.contract, event: "TransactionMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchTransactionMessageDelivered is a free log subscription operation binding the contract event 0xcf612c95e8993eca9c6e0be96b26b47022996db601dc12b4cf68ec37829d87b3.
//
// Solidity: event TransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 seqNumber, uint256 value, bytes data)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchTransactionMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxTransactionMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "TransactionMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxTransactionMessageDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "TransactionMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransactionMessageDelivered is a log parse operation binding the contract event 0xcf612c95e8993eca9c6e0be96b26b47022996db601dc12b4cf68ec37829d87b3.
//
// Solidity: event TransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 seqNumber, uint256 value, bytes data)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseTransactionMessageDelivered(log types.Log) (*IGlobalInboxTransactionMessageDelivered, error) {
	event := new(IGlobalInboxTransactionMessageDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "TransactionMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphABI is the input ABI used to generate the binding from.
const NodeGraphABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[8]\",\"name\":\"fields\",\"type\":\"bytes32[8]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inboxCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"importedMessageCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[4]\",\"name\":\"timeBounds\",\"type\":\"uint128[4]\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numArbGas\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numSteps\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didInboxInsn\",\"type\":\"bool\"}],\"name\":\"RollupAsserted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"initVMHash\",\"type\":\"bytes32\"}],\"name\":\"RollupCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"RollupPruned\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalInbox\",\"outputs\":[{\"internalType\":\"contractIGlobalInbox\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"isValidLeaf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestConfirmed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"fromNodes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"leafProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"leafProofLengths\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"latestConfProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"latestConfirmedProofLengths\",\"type\":\"uint256[]\"}],\"name\":\"pruneLeaves\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vmParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gracePeriodTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arbGasSpeedLimitPerTick\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"maxExecutionSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxBlockBoundsWidth\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxTimestampBoundsWidth\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// NodeGraphFuncSigs maps the 4-byte function signature to its string representation.
var NodeGraphFuncSigs = map[string]string{
	"d489113a": "globalInbox()",
	"57ca6d1b": "isValidLeaf(bytes32)",
	"65f7f80d": "latestConfirmed()",
	"fcfd8d3f": "pruneLeaves(bytes32[],bytes32[],uint256[],bytes32[],uint256[])",
	"bbc2cc00": "vmParams()",
}

// NodeGraphBin is the compiled bytecode used for deploying new contracts.
var NodeGraphBin = "0x608060405234801561001057600080fd5b5061077d806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806357ca6d1b1461005c57806365f7f80d1461008d578063bbc2cc00146100a7578063d489113a146100e7578063fcfd8d3f1461010b575b600080fd5b6100796004803603602081101561007257600080fd5b50356103b6565b604080519115158252519081900360200190f35b6100956103cb565b60408051918252519081900360200190f35b6100af6103d1565b60408051958652602086019490945267ffffffffffffffff928316858501529082166060850152166080830152519081900360a00190f35b6100ef610402565b604080516001600160a01b039092168252519081900360200190f35b6103b4600480360360a081101561012157600080fd5b810190602081018135600160201b81111561013b57600080fd5b82018360208201111561014d57600080fd5b803590602001918460208302840111600160201b8311171561016e57600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156101bd57600080fd5b8201836020820111156101cf57600080fd5b803590602001918460208302840111600160201b831117156101f057600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561023f57600080fd5b82018360208201111561025157600080fd5b803590602001918460208302840111600160201b8311171561027257600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156102c157600080fd5b8201836020820111156102d357600080fd5b803590602001918460208302840111600160201b831117156102f457600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561034357600080fd5b82018360208201111561035557600080fd5b803590602001918460208302840111600160201b8311171561037657600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550610411945050505050565b005b60009081526004602052604090205460ff1690565b60055490565b60015460025460035467ffffffffffffffff80821691680100000000000000008104821691600160801b9091041685565b6000546001600160a01b031681565b84518351811480156104235750808251145b61046d576040805162461bcd60e51b81526020600482015260166024820152750d2dce0eae840d8cadccee8d040dad2e6e8dac2e8c6d60531b604482015290519081900360640190fd5b600080805b838110156104cf576104c289828151811061048957fe5b602002602001015186838151811061049d57fe5b60200260200101518984815181106104b157fe5b60200260200101518b8a88886104da565b9093509150600101610472565b505050505050505050565b6000806000871180156104ed5750600088115b6040518060400160405280600e81526020016d28292aa722afa82927a7a32622a760911b8152509061059d5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561056257818101518382015260200161054a565b50505050905090810190601f16801561058f5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5083870183890160006105ae6103cb565b6105ba8d8a89866106e0565b1490508080156105f057508786815181106105d157fe5b60200260200101518988815181106105e557fe5b602002602001015114155b6040518060400160405280600e81526020016d141495539157d0d3d391931250d560921b815250906106635760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561056257818101518382015260200161054a565b5060006106728d8b8a876106e0565b905061067d816103b6565b156106ce57600081815260046020908152604091829020805460ff19169055815183815291517f3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f44909509281900390910190a15b50919b909a5098505050505050505050565b600084835b8381101561073e57818682815181106106fa57fe5b6020026020010151604051602001808381526020018281526020019250505060405160208183030381529060405280519060200120915080806001019150506106e5565b509594505050505056fea265627a7a723158208d146069c49c644e03a77d73611ee2657571b471f5dfd8e642bf91688c3ce14664736f6c63430005110032"

// DeployNodeGraph deploys a new Ethereum contract, binding an instance of NodeGraph to it.
func DeployNodeGraph(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *NodeGraph, error) {
	parsed, err := abi.JSON(strings.NewReader(NodeGraphABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(NodeGraphBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &NodeGraph{NodeGraphCaller: NodeGraphCaller{contract: contract}, NodeGraphTransactor: NodeGraphTransactor{contract: contract}, NodeGraphFilterer: NodeGraphFilterer{contract: contract}}, nil
}

// NodeGraph is an auto generated Go binding around an Ethereum contract.
type NodeGraph struct {
	NodeGraphCaller     // Read-only binding to the contract
	NodeGraphTransactor // Write-only binding to the contract
	NodeGraphFilterer   // Log filterer for contract events
}

// NodeGraphCaller is an auto generated read-only Go binding around an Ethereum contract.
type NodeGraphCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphTransactor is an auto generated write-only Go binding around an Ethereum contract.
type NodeGraphTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type NodeGraphFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type NodeGraphSession struct {
	Contract     *NodeGraph        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// NodeGraphCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type NodeGraphCallerSession struct {
	Contract *NodeGraphCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// NodeGraphTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type NodeGraphTransactorSession struct {
	Contract     *NodeGraphTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// NodeGraphRaw is an auto generated low-level Go binding around an Ethereum contract.
type NodeGraphRaw struct {
	Contract *NodeGraph // Generic contract binding to access the raw methods on
}

// NodeGraphCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type NodeGraphCallerRaw struct {
	Contract *NodeGraphCaller // Generic read-only contract binding to access the raw methods on
}

// NodeGraphTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type NodeGraphTransactorRaw struct {
	Contract *NodeGraphTransactor // Generic write-only contract binding to access the raw methods on
}

// NewNodeGraph creates a new instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraph(address common.Address, backend bind.ContractBackend) (*NodeGraph, error) {
	contract, err := bindNodeGraph(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &NodeGraph{NodeGraphCaller: NodeGraphCaller{contract: contract}, NodeGraphTransactor: NodeGraphTransactor{contract: contract}, NodeGraphFilterer: NodeGraphFilterer{contract: contract}}, nil
}

// NewNodeGraphCaller creates a new read-only instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraphCaller(address common.Address, caller bind.ContractCaller) (*NodeGraphCaller, error) {
	contract, err := bindNodeGraph(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &NodeGraphCaller{contract: contract}, nil
}

// NewNodeGraphTransactor creates a new write-only instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraphTransactor(address common.Address, transactor bind.ContractTransactor) (*NodeGraphTransactor, error) {
	contract, err := bindNodeGraph(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &NodeGraphTransactor{contract: contract}, nil
}

// NewNodeGraphFilterer creates a new log filterer instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraphFilterer(address common.Address, filterer bind.ContractFilterer) (*NodeGraphFilterer, error) {
	contract, err := bindNodeGraph(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &NodeGraphFilterer{contract: contract}, nil
}

// bindNodeGraph binds a generic wrapper to an already deployed contract.
func bindNodeGraph(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(NodeGraphABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeGraph *NodeGraphRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _NodeGraph.Contract.NodeGraphCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeGraph *NodeGraphRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeGraph.Contract.NodeGraphTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeGraph *NodeGraphRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeGraph.Contract.NodeGraphTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeGraph *NodeGraphCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _NodeGraph.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeGraph *NodeGraphTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeGraph.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeGraph *NodeGraphTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeGraph.Contract.contract.Transact(opts, method, params...)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() view returns(address)
func (_NodeGraph *NodeGraphCaller) GlobalInbox(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _NodeGraph.contract.Call(opts, out, "globalInbox")
	return *ret0, err
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() view returns(address)
func (_NodeGraph *NodeGraphSession) GlobalInbox() (common.Address, error) {
	return _NodeGraph.Contract.GlobalInbox(&_NodeGraph.CallOpts)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() view returns(address)
func (_NodeGraph *NodeGraphCallerSession) GlobalInbox() (common.Address, error) {
	return _NodeGraph.Contract.GlobalInbox(&_NodeGraph.CallOpts)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) view returns(bool)
func (_NodeGraph *NodeGraphCaller) IsValidLeaf(opts *bind.CallOpts, leaf [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _NodeGraph.contract.Call(opts, out, "isValidLeaf", leaf)
	return *ret0, err
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) view returns(bool)
func (_NodeGraph *NodeGraphSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _NodeGraph.Contract.IsValidLeaf(&_NodeGraph.CallOpts, leaf)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) view returns(bool)
func (_NodeGraph *NodeGraphCallerSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _NodeGraph.Contract.IsValidLeaf(&_NodeGraph.CallOpts, leaf)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() view returns(bytes32)
func (_NodeGraph *NodeGraphCaller) LatestConfirmed(opts *bind.CallOpts) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _NodeGraph.contract.Call(opts, out, "latestConfirmed")
	return *ret0, err
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() view returns(bytes32)
func (_NodeGraph *NodeGraphSession) LatestConfirmed() ([32]byte, error) {
	return _NodeGraph.Contract.LatestConfirmed(&_NodeGraph.CallOpts)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() view returns(bytes32)
func (_NodeGraph *NodeGraphCallerSession) LatestConfirmed() ([32]byte, error) {
	return _NodeGraph.Contract.LatestConfirmed(&_NodeGraph.CallOpts)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() view returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_NodeGraph *NodeGraphCaller) VmParams(opts *bind.CallOpts) (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	ret := new(struct {
		GracePeriodTicks        *big.Int
		ArbGasSpeedLimitPerTick *big.Int
		MaxExecutionSteps       uint64
		MaxBlockBoundsWidth     uint64
		MaxTimestampBoundsWidth uint64
	})
	out := ret
	err := _NodeGraph.contract.Call(opts, out, "vmParams")
	return *ret, err
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() view returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_NodeGraph *NodeGraphSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	return _NodeGraph.Contract.VmParams(&_NodeGraph.CallOpts)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() view returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_NodeGraph *NodeGraphCallerSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	return _NodeGraph.Contract.VmParams(&_NodeGraph.CallOpts)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_NodeGraph *NodeGraphTransactor) PruneLeaves(opts *bind.TransactOpts, fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _NodeGraph.contract.Transact(opts, "pruneLeaves", fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_NodeGraph *NodeGraphSession) PruneLeaves(fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _NodeGraph.Contract.PruneLeaves(&_NodeGraph.TransactOpts, fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_NodeGraph *NodeGraphTransactorSession) PruneLeaves(fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _NodeGraph.Contract.PruneLeaves(&_NodeGraph.TransactOpts, fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// NodeGraphRollupAssertedIterator is returned from FilterRollupAsserted and is used to iterate over the raw logs and unpacked data for RollupAsserted events raised by the NodeGraph contract.
type NodeGraphRollupAssertedIterator struct {
	Event *NodeGraphRollupAsserted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupAssertedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupAsserted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupAsserted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupAssertedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupAssertedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupAsserted represents a RollupAsserted event raised by the NodeGraph contract.
type NodeGraphRollupAsserted struct {
	Fields               [8][32]byte
	InboxCount           *big.Int
	ImportedMessageCount *big.Int
	TimeBounds           [4]*big.Int
	NumArbGas            uint64
	NumSteps             uint64
	DidInboxInsn         bool
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterRollupAsserted is a free log retrieval operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_NodeGraph *NodeGraphFilterer) FilterRollupAsserted(opts *bind.FilterOpts) (*NodeGraphRollupAssertedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupAssertedIterator{contract: _NodeGraph.contract, event: "RollupAsserted", logs: logs, sub: sub}, nil
}

// WatchRollupAsserted is a free log subscription operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_NodeGraph *NodeGraphFilterer) WatchRollupAsserted(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupAsserted) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupAsserted)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupAsserted is a log parse operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_NodeGraph *NodeGraphFilterer) ParseRollupAsserted(log types.Log) (*NodeGraphRollupAsserted, error) {
	event := new(NodeGraphRollupAsserted)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphRollupConfirmedIterator is returned from FilterRollupConfirmed and is used to iterate over the raw logs and unpacked data for RollupConfirmed events raised by the NodeGraph contract.
type NodeGraphRollupConfirmedIterator struct {
	Event *NodeGraphRollupConfirmed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupConfirmedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupConfirmed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupConfirmed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupConfirmedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupConfirmedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupConfirmed represents a RollupConfirmed event raised by the NodeGraph contract.
type NodeGraphRollupConfirmed struct {
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupConfirmed is a free log retrieval operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_NodeGraph *NodeGraphFilterer) FilterRollupConfirmed(opts *bind.FilterOpts) (*NodeGraphRollupConfirmedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupConfirmedIterator{contract: _NodeGraph.contract, event: "RollupConfirmed", logs: logs, sub: sub}, nil
}

// WatchRollupConfirmed is a free log subscription operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_NodeGraph *NodeGraphFilterer) WatchRollupConfirmed(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupConfirmed) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupConfirmed)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupConfirmed is a log parse operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_NodeGraph *NodeGraphFilterer) ParseRollupConfirmed(log types.Log) (*NodeGraphRollupConfirmed, error) {
	event := new(NodeGraphRollupConfirmed)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphRollupCreatedIterator is returned from FilterRollupCreated and is used to iterate over the raw logs and unpacked data for RollupCreated events raised by the NodeGraph contract.
type NodeGraphRollupCreatedIterator struct {
	Event *NodeGraphRollupCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupCreated represents a RollupCreated event raised by the NodeGraph contract.
type NodeGraphRollupCreated struct {
	InitVMHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupCreated is a free log retrieval operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_NodeGraph *NodeGraphFilterer) FilterRollupCreated(opts *bind.FilterOpts) (*NodeGraphRollupCreatedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupCreatedIterator{contract: _NodeGraph.contract, event: "RollupCreated", logs: logs, sub: sub}, nil
}

// WatchRollupCreated is a free log subscription operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_NodeGraph *NodeGraphFilterer) WatchRollupCreated(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupCreated) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupCreated)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupCreated is a log parse operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_NodeGraph *NodeGraphFilterer) ParseRollupCreated(log types.Log) (*NodeGraphRollupCreated, error) {
	event := new(NodeGraphRollupCreated)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphRollupPrunedIterator is returned from FilterRollupPruned and is used to iterate over the raw logs and unpacked data for RollupPruned events raised by the NodeGraph contract.
type NodeGraphRollupPrunedIterator struct {
	Event *NodeGraphRollupPruned // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupPrunedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupPruned)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupPruned)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupPrunedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupPrunedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupPruned represents a RollupPruned event raised by the NodeGraph contract.
type NodeGraphRollupPruned struct {
	Leaf [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRollupPruned is a free log retrieval operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_NodeGraph *NodeGraphFilterer) FilterRollupPruned(opts *bind.FilterOpts) (*NodeGraphRollupPrunedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupPrunedIterator{contract: _NodeGraph.contract, event: "RollupPruned", logs: logs, sub: sub}, nil
}

// WatchRollupPruned is a free log subscription operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_NodeGraph *NodeGraphFilterer) WatchRollupPruned(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupPruned) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupPruned)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupPruned", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupPruned is a log parse operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_NodeGraph *NodeGraphFilterer) ParseRollupPruned(log types.Log) (*NodeGraphRollupPruned, error) {
	event := new(NodeGraphRollupPruned)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupPruned", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphUtilsABI is the input ABI used to generate the binding from.
const NodeGraphUtilsABI = "[]"

// NodeGraphUtilsBin is the compiled bytecode used for deploying new contracts.
var NodeGraphUtilsBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a723158203ef384c0f237007c01ee3a02522156ae6f9347c443ce636ec49b4e1ff850e18764736f6c63430005110032"

// DeployNodeGraphUtils deploys a new Ethereum contract, binding an instance of NodeGraphUtils to it.
func DeployNodeGraphUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *NodeGraphUtils, error) {
	parsed, err := abi.JSON(strings.NewReader(NodeGraphUtilsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(NodeGraphUtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &NodeGraphUtils{NodeGraphUtilsCaller: NodeGraphUtilsCaller{contract: contract}, NodeGraphUtilsTransactor: NodeGraphUtilsTransactor{contract: contract}, NodeGraphUtilsFilterer: NodeGraphUtilsFilterer{contract: contract}}, nil
}

// NodeGraphUtils is an auto generated Go binding around an Ethereum contract.
type NodeGraphUtils struct {
	NodeGraphUtilsCaller     // Read-only binding to the contract
	NodeGraphUtilsTransactor // Write-only binding to the contract
	NodeGraphUtilsFilterer   // Log filterer for contract events
}

// NodeGraphUtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type NodeGraphUtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphUtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type NodeGraphUtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphUtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type NodeGraphUtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphUtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type NodeGraphUtilsSession struct {
	Contract     *NodeGraphUtils   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// NodeGraphUtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type NodeGraphUtilsCallerSession struct {
	Contract *NodeGraphUtilsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// NodeGraphUtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type NodeGraphUtilsTransactorSession struct {
	Contract     *NodeGraphUtilsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// NodeGraphUtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type NodeGraphUtilsRaw struct {
	Contract *NodeGraphUtils // Generic contract binding to access the raw methods on
}

// NodeGraphUtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type NodeGraphUtilsCallerRaw struct {
	Contract *NodeGraphUtilsCaller // Generic read-only contract binding to access the raw methods on
}

// NodeGraphUtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type NodeGraphUtilsTransactorRaw struct {
	Contract *NodeGraphUtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewNodeGraphUtils creates a new instance of NodeGraphUtils, bound to a specific deployed contract.
func NewNodeGraphUtils(address common.Address, backend bind.ContractBackend) (*NodeGraphUtils, error) {
	contract, err := bindNodeGraphUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &NodeGraphUtils{NodeGraphUtilsCaller: NodeGraphUtilsCaller{contract: contract}, NodeGraphUtilsTransactor: NodeGraphUtilsTransactor{contract: contract}, NodeGraphUtilsFilterer: NodeGraphUtilsFilterer{contract: contract}}, nil
}

// NewNodeGraphUtilsCaller creates a new read-only instance of NodeGraphUtils, bound to a specific deployed contract.
func NewNodeGraphUtilsCaller(address common.Address, caller bind.ContractCaller) (*NodeGraphUtilsCaller, error) {
	contract, err := bindNodeGraphUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &NodeGraphUtilsCaller{contract: contract}, nil
}

// NewNodeGraphUtilsTransactor creates a new write-only instance of NodeGraphUtils, bound to a specific deployed contract.
func NewNodeGraphUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*NodeGraphUtilsTransactor, error) {
	contract, err := bindNodeGraphUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &NodeGraphUtilsTransactor{contract: contract}, nil
}

// NewNodeGraphUtilsFilterer creates a new log filterer instance of NodeGraphUtils, bound to a specific deployed contract.
func NewNodeGraphUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*NodeGraphUtilsFilterer, error) {
	contract, err := bindNodeGraphUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &NodeGraphUtilsFilterer{contract: contract}, nil
}

// bindNodeGraphUtils binds a generic wrapper to an already deployed contract.
func bindNodeGraphUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(NodeGraphUtilsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeGraphUtils *NodeGraphUtilsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _NodeGraphUtils.Contract.NodeGraphUtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeGraphUtils *NodeGraphUtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeGraphUtils.Contract.NodeGraphUtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeGraphUtils *NodeGraphUtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeGraphUtils.Contract.NodeGraphUtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeGraphUtils *NodeGraphUtilsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _NodeGraphUtils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeGraphUtils *NodeGraphUtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeGraphUtils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeGraphUtils *NodeGraphUtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeGraphUtils.Contract.contract.Transact(opts, method, params...)
}

// ProtocolABI is the input ABI used to generate the binding from.
const ProtocolABI = "[]"

// ProtocolBin is the compiled bytecode used for deploying new contracts.
var ProtocolBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a7231582022b61b378c3294b5283e6c47d99023735523c55fa274c55e808a082f5db25b7d64736f6c63430005110032"

// DeployProtocol deploys a new Ethereum contract, binding an instance of Protocol to it.
func DeployProtocol(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Protocol, error) {
	parsed, err := abi.JSON(strings.NewReader(ProtocolABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ProtocolBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Protocol{ProtocolCaller: ProtocolCaller{contract: contract}, ProtocolTransactor: ProtocolTransactor{contract: contract}, ProtocolFilterer: ProtocolFilterer{contract: contract}}, nil
}

// Protocol is an auto generated Go binding around an Ethereum contract.
type Protocol struct {
	ProtocolCaller     // Read-only binding to the contract
	ProtocolTransactor // Write-only binding to the contract
	ProtocolFilterer   // Log filterer for contract events
}

// ProtocolCaller is an auto generated read-only Go binding around an Ethereum contract.
type ProtocolCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ProtocolTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ProtocolTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ProtocolFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ProtocolFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ProtocolSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ProtocolSession struct {
	Contract     *Protocol         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ProtocolCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ProtocolCallerSession struct {
	Contract *ProtocolCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// ProtocolTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ProtocolTransactorSession struct {
	Contract     *ProtocolTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ProtocolRaw is an auto generated low-level Go binding around an Ethereum contract.
type ProtocolRaw struct {
	Contract *Protocol // Generic contract binding to access the raw methods on
}

// ProtocolCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ProtocolCallerRaw struct {
	Contract *ProtocolCaller // Generic read-only contract binding to access the raw methods on
}

// ProtocolTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ProtocolTransactorRaw struct {
	Contract *ProtocolTransactor // Generic write-only contract binding to access the raw methods on
}

// NewProtocol creates a new instance of Protocol, bound to a specific deployed contract.
func NewProtocol(address common.Address, backend bind.ContractBackend) (*Protocol, error) {
	contract, err := bindProtocol(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Protocol{ProtocolCaller: ProtocolCaller{contract: contract}, ProtocolTransactor: ProtocolTransactor{contract: contract}, ProtocolFilterer: ProtocolFilterer{contract: contract}}, nil
}

// NewProtocolCaller creates a new read-only instance of Protocol, bound to a specific deployed contract.
func NewProtocolCaller(address common.Address, caller bind.ContractCaller) (*ProtocolCaller, error) {
	contract, err := bindProtocol(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ProtocolCaller{contract: contract}, nil
}

// NewProtocolTransactor creates a new write-only instance of Protocol, bound to a specific deployed contract.
func NewProtocolTransactor(address common.Address, transactor bind.ContractTransactor) (*ProtocolTransactor, error) {
	contract, err := bindProtocol(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ProtocolTransactor{contract: contract}, nil
}

// NewProtocolFilterer creates a new log filterer instance of Protocol, bound to a specific deployed contract.
func NewProtocolFilterer(address common.Address, filterer bind.ContractFilterer) (*ProtocolFilterer, error) {
	contract, err := bindProtocol(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ProtocolFilterer{contract: contract}, nil
}

// bindProtocol binds a generic wrapper to an already deployed contract.
func bindProtocol(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ProtocolABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Protocol *ProtocolRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Protocol.Contract.ProtocolCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Protocol *ProtocolRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Protocol.Contract.ProtocolTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Protocol *ProtocolRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Protocol.Contract.ProtocolTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Protocol *ProtocolCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Protocol.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Protocol *ProtocolTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Protocol.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Protocol *ProtocolTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Protocol.Contract.contract.Transact(opts, method, params...)
}

// RollupTimeABI is the input ABI used to generate the binding from.
const RollupTimeABI = "[]"

// RollupTimeBin is the compiled bytecode used for deploying new contracts.
var RollupTimeBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820bc5e1c1239ee257a8886402d63fd0e30faaddb124d4cfd39eb5105366f8e112b64736f6c63430005110032"

// DeployRollupTime deploys a new Ethereum contract, binding an instance of RollupTime to it.
func DeployRollupTime(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *RollupTime, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupTimeABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(RollupTimeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &RollupTime{RollupTimeCaller: RollupTimeCaller{contract: contract}, RollupTimeTransactor: RollupTimeTransactor{contract: contract}, RollupTimeFilterer: RollupTimeFilterer{contract: contract}}, nil
}

// RollupTime is an auto generated Go binding around an Ethereum contract.
type RollupTime struct {
	RollupTimeCaller     // Read-only binding to the contract
	RollupTimeTransactor // Write-only binding to the contract
	RollupTimeFilterer   // Log filterer for contract events
}

// RollupTimeCaller is an auto generated read-only Go binding around an Ethereum contract.
type RollupTimeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupTimeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RollupTimeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupTimeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RollupTimeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupTimeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RollupTimeSession struct {
	Contract     *RollupTime       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RollupTimeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RollupTimeCallerSession struct {
	Contract *RollupTimeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// RollupTimeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RollupTimeTransactorSession struct {
	Contract     *RollupTimeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// RollupTimeRaw is an auto generated low-level Go binding around an Ethereum contract.
type RollupTimeRaw struct {
	Contract *RollupTime // Generic contract binding to access the raw methods on
}

// RollupTimeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RollupTimeCallerRaw struct {
	Contract *RollupTimeCaller // Generic read-only contract binding to access the raw methods on
}

// RollupTimeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RollupTimeTransactorRaw struct {
	Contract *RollupTimeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRollupTime creates a new instance of RollupTime, bound to a specific deployed contract.
func NewRollupTime(address common.Address, backend bind.ContractBackend) (*RollupTime, error) {
	contract, err := bindRollupTime(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &RollupTime{RollupTimeCaller: RollupTimeCaller{contract: contract}, RollupTimeTransactor: RollupTimeTransactor{contract: contract}, RollupTimeFilterer: RollupTimeFilterer{contract: contract}}, nil
}

// NewRollupTimeCaller creates a new read-only instance of RollupTime, bound to a specific deployed contract.
func NewRollupTimeCaller(address common.Address, caller bind.ContractCaller) (*RollupTimeCaller, error) {
	contract, err := bindRollupTime(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RollupTimeCaller{contract: contract}, nil
}

// NewRollupTimeTransactor creates a new write-only instance of RollupTime, bound to a specific deployed contract.
func NewRollupTimeTransactor(address common.Address, transactor bind.ContractTransactor) (*RollupTimeTransactor, error) {
	contract, err := bindRollupTime(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RollupTimeTransactor{contract: contract}, nil
}

// NewRollupTimeFilterer creates a new log filterer instance of RollupTime, bound to a specific deployed contract.
func NewRollupTimeFilterer(address common.Address, filterer bind.ContractFilterer) (*RollupTimeFilterer, error) {
	contract, err := bindRollupTime(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RollupTimeFilterer{contract: contract}, nil
}

// bindRollupTime binds a generic wrapper to an already deployed contract.
func bindRollupTime(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupTimeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupTime *RollupTimeRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupTime.Contract.RollupTimeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupTime *RollupTimeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupTime.Contract.RollupTimeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupTime *RollupTimeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupTime.Contract.RollupTimeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupTime *RollupTimeCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupTime.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupTime *RollupTimeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupTime.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupTime *RollupTimeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupTime.Contract.contract.Transact(opts, method, params...)
}

// RollupUtilsABI is the input ABI used to generate the binding from.
const RollupUtilsABI = "[]"

// RollupUtilsBin is the compiled bytecode used for deploying new contracts.
var RollupUtilsBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820e21b05f3f9f4593adff741942f2a08b1c86fd955d15dd316001b2b3c838de6cb64736f6c63430005110032"

// DeployRollupUtils deploys a new Ethereum contract, binding an instance of RollupUtils to it.
func DeployRollupUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *RollupUtils, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupUtilsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(RollupUtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &RollupUtils{RollupUtilsCaller: RollupUtilsCaller{contract: contract}, RollupUtilsTransactor: RollupUtilsTransactor{contract: contract}, RollupUtilsFilterer: RollupUtilsFilterer{contract: contract}}, nil
}

// RollupUtils is an auto generated Go binding around an Ethereum contract.
type RollupUtils struct {
	RollupUtilsCaller     // Read-only binding to the contract
	RollupUtilsTransactor // Write-only binding to the contract
	RollupUtilsFilterer   // Log filterer for contract events
}

// RollupUtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type RollupUtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupUtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RollupUtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupUtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RollupUtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupUtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RollupUtilsSession struct {
	Contract     *RollupUtils      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RollupUtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RollupUtilsCallerSession struct {
	Contract *RollupUtilsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// RollupUtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RollupUtilsTransactorSession struct {
	Contract     *RollupUtilsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// RollupUtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type RollupUtilsRaw struct {
	Contract *RollupUtils // Generic contract binding to access the raw methods on
}

// RollupUtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RollupUtilsCallerRaw struct {
	Contract *RollupUtilsCaller // Generic read-only contract binding to access the raw methods on
}

// RollupUtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RollupUtilsTransactorRaw struct {
	Contract *RollupUtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRollupUtils creates a new instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtils(address common.Address, backend bind.ContractBackend) (*RollupUtils, error) {
	contract, err := bindRollupUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &RollupUtils{RollupUtilsCaller: RollupUtilsCaller{contract: contract}, RollupUtilsTransactor: RollupUtilsTransactor{contract: contract}, RollupUtilsFilterer: RollupUtilsFilterer{contract: contract}}, nil
}

// NewRollupUtilsCaller creates a new read-only instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtilsCaller(address common.Address, caller bind.ContractCaller) (*RollupUtilsCaller, error) {
	contract, err := bindRollupUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RollupUtilsCaller{contract: contract}, nil
}

// NewRollupUtilsTransactor creates a new write-only instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*RollupUtilsTransactor, error) {
	contract, err := bindRollupUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RollupUtilsTransactor{contract: contract}, nil
}

// NewRollupUtilsFilterer creates a new log filterer instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*RollupUtilsFilterer, error) {
	contract, err := bindRollupUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RollupUtilsFilterer{contract: contract}, nil
}

// bindRollupUtils binds a generic wrapper to an already deployed contract.
func bindRollupUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupUtilsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupUtils *RollupUtilsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupUtils.Contract.RollupUtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupUtils *RollupUtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupUtils.Contract.RollupUtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupUtils *RollupUtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupUtils.Contract.RollupUtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupUtils *RollupUtilsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupUtils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupUtils *RollupUtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupUtils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupUtils *RollupUtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupUtils.Contract.contract.Transact(opts, method, params...)
}

// SafeMathABI is the input ABI used to generate the binding from.
const SafeMathABI = "[]"

// SafeMathBin is the compiled bytecode used for deploying new contracts.
var SafeMathBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820b6e334180b77cc68114f188c0aa47be28528be9d593d39d3e17df219ffce7d1b64736f6c63430005110032"

// DeploySafeMath deploys a new Ethereum contract, binding an instance of SafeMath to it.
func DeploySafeMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SafeMath, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SafeMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// SafeMath is an auto generated Go binding around an Ethereum contract.
type SafeMath struct {
	SafeMathCaller     // Read-only binding to the contract
	SafeMathTransactor // Write-only binding to the contract
	SafeMathFilterer   // Log filterer for contract events
}

// SafeMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type SafeMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeMathSession struct {
	Contract     *SafeMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeMathCallerSession struct {
	Contract *SafeMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// SafeMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeMathTransactorSession struct {
	Contract     *SafeMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SafeMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type SafeMathRaw struct {
	Contract *SafeMath // Generic contract binding to access the raw methods on
}

// SafeMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeMathCallerRaw struct {
	Contract *SafeMathCaller // Generic read-only contract binding to access the raw methods on
}

// SafeMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeMathTransactorRaw struct {
	Contract *SafeMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSafeMath creates a new instance of SafeMath, bound to a specific deployed contract.
func NewSafeMath(address common.Address, backend bind.ContractBackend) (*SafeMath, error) {
	contract, err := bindSafeMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// NewSafeMathCaller creates a new read-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathCaller(address common.Address, caller bind.ContractCaller) (*SafeMathCaller, error) {
	contract, err := bindSafeMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathCaller{contract: contract}, nil
}

// NewSafeMathTransactor creates a new write-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathTransactor(address common.Address, transactor bind.ContractTransactor) (*SafeMathTransactor, error) {
	contract, err := bindSafeMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathTransactor{contract: contract}, nil
}

// NewSafeMathFilterer creates a new log filterer instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathFilterer(address common.Address, filterer bind.ContractFilterer) (*SafeMathFilterer, error) {
	contract, err := bindSafeMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeMathFilterer{contract: contract}, nil
}

// bindSafeMath binds a generic wrapper to an already deployed contract.
func bindSafeMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.SafeMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transact(opts, method, params...)
}

// StakingABI is the input ABI used to generate the binding from.
const StakingABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"}],\"name\":\"RollupChallengeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asserter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"}],\"name\":\"RollupChallengeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"toNodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeMoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"RollupStakeRefunded\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeFactory\",\"outputs\":[{\"internalType\":\"contractIChallengeFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakeRequired\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakerAddress\",\"type\":\"address\"}],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resolveChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"asserterAddress\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"challengerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"prevNode\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"stakerNodeTypes\",\"type\":\"uint256[2]\"},{\"internalType\":\"bytes32[2]\",\"name\":\"vmProtoHashes\",\"type\":\"bytes32[2]\"},{\"internalType\":\"bytes32[]\",\"name\":\"asserterProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"challengerProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"asserterNodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"challengerDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"challengerPeriodTicks\",\"type\":\"uint128\"}],\"name\":\"startChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// StakingFuncSigs maps the 4-byte function signature to its string representation.
var StakingFuncSigs = map[string]string{
	"5dbaf68b": "challengeFactory()",
	"d16c305d": "getStakeRequired()",
	"6177fd18": "isStaked(address)",
	"6bc3cd22": "resolveChallenge(address,address,uint256)",
	"bac5963f": "startChallenge(address,address,bytes32,uint256,uint256[2],bytes32[2],bytes32[],bytes32[],bytes32,bytes32,uint128)",
}

// StakingBin is the compiled bytecode used for deploying new contracts.
var StakingBin = "0x608060405234801561001057600080fd5b50610c0e806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80635dbaf68b1461005c5780636177fd18146100805780636bc3cd22146100ba578063bac5963f146100f2578063d16c305d146102a8575b600080fd5b6100646102cc565b604080516001600160a01b039092168252519081900360200190f35b6100a66004803603602081101561009657600080fd5b50356001600160a01b03166102db565b604080519115158252519081900360200190f35b6100f0600480360360608110156100d057600080fd5b506001600160a01b038135811691602081013590911690604001356102f8565b005b6100f060048036036101a081101561010957600080fd5b6040805180820182526001600160a01b0384358116946020810135909116938382013593606083013593918301929160c08301916080840190600290839083908082843760009201919091525050604080518082018252929594938181019392509060029083908390808284376000920191909152509194939260208101925035905064010000000081111561019e57600080fd5b8201836020820111156101b057600080fd5b803590602001918460208302840111640100000000831117156101d257600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929594936020810193503591505064010000000081111561022257600080fd5b82018360208201111561023457600080fd5b8035906020019184602083028401116401000000008311171561025657600080fd5b91908080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525092955050823593505050602081013590604001356001600160801b0316610491565b6102b06108c3565b604080516001600160801b039092168252519081900360200190f35b6000546001600160a01b031681565b6001600160a01b0316600090815260026020526040902054151590565b33600090815260046020908152604091829020548251808401909352600f83526e2922a9afa1a420a62fa9a2a72222a960891b9183019190915260ff166103bd5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561038257818101518382015260200161036a565b50505050905090810190601f1680156103af5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b50336000908152600460205260408120805460ff191690556103de846108d2565b6001546040519192506001600160a01b0386169160026001600160801b039283160490911680156108fc02916000818181858888f19350505050158015610429573d6000803e3d6000fd5b5060018101805460ff60801b1916905561044283610963565b604080513381526001600160a01b03808716602083015285168183015290517f468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f299181900360600190a150505050565b600061049c8c6108d2565b905060006104a98c6108d2565b60018301549091508a906104c5906001600160801b03166109a4565b106040518060400160405280600d81526020016c53544b315f444541444c494e4560981b815250906105385760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b5060018101548a90610552906001600160801b03166109a4565b106040518060400160405280600d81526020016c53544b325f444541444c494e4560981b815250906105c55760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b50600182015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff16156106455760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b50600181015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff16156106c55760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b506020808a01518a5160408051808201909152600a8152692a2ca822afa7a92222a960b11b938101939093521161073d5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b50815461076561075f8d8d898e600060200201518e60005b60200201516109ab565b89610a13565b146040518060400160405280600c81526020016b20a9a9a2a92a2fa82927a7a360a11b815250906107d75760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b5080546108086108028d8d6107f5896001600160801b038a16610a2a565b60208f01518e6001610755565b88610a13565b146040518060400160405280600a81526020016921a420a62fa82927a7a360b11b815250906108785760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b5060018281018054600160801b60ff60801b199182168117909255918301805490921617905560208901516108b4908e908e9086908890610a56565b50505050505050505050505050565b6001546001600160801b031690565b6001600160a01b038116600090815260026020908152604080832080548251808401909352600a83526924a72b2fa9aa20a5a2a960b11b938301939093529161095c5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b5092915050565b6001600160a01b03166000908152600260205260408120908155600101805470ffffffffffffffffffffffffffffffffff1916905560038054600019019055565b6103e80290565b6040805160208082018490528183018790526060820186905260808083018690528351808403909101815260a08301845280519082012060c0830189905260e08084019190915283518084039091018152610100909201909252805191012095945050505050565b6000610a23838360008551610b71565b9392505050565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b600080546040805163432ed0e160e11b81526001600160a01b03898116600483015288811660248301526001600160801b038816604483015260648201879052608482018690529151919092169163865da1c29160a480830192602092919082900301818787803b158015610aca57600080fd5b505af1158015610ade573d6000803e3d6000fd5b505050506040513d6020811015610af457600080fd5b50516001600160a01b03808216600081815260046020908152604091829020805460ff1916600117905581518b85168152938a16908401528281018690526060830191909152519192507f6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f919081900360800190a1505050505050565b600084835b83811015610bcf5781868281518110610b8b57fe5b602002602001015160405160200180838152602001828152602001925050506040516020818303038152906040528051906020012091508080600101915050610b76565b509594505050505056fea265627a7a723158203715b70e1304f9cedbc7942d3096a9261652f3f80683b138a764c7086486f4f664736f6c63430005110032"

// DeployStaking deploys a new Ethereum contract, binding an instance of Staking to it.
func DeployStaking(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Staking, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(StakingBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Staking{StakingCaller: StakingCaller{contract: contract}, StakingTransactor: StakingTransactor{contract: contract}, StakingFilterer: StakingFilterer{contract: contract}}, nil
}

// Staking is an auto generated Go binding around an Ethereum contract.
type Staking struct {
	StakingCaller     // Read-only binding to the contract
	StakingTransactor // Write-only binding to the contract
	StakingFilterer   // Log filterer for contract events
}

// StakingCaller is an auto generated read-only Go binding around an Ethereum contract.
type StakingCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StakingTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StakingFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StakingSession struct {
	Contract     *Staking          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StakingCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StakingCallerSession struct {
	Contract *StakingCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// StakingTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StakingTransactorSession struct {
	Contract     *StakingTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// StakingRaw is an auto generated low-level Go binding around an Ethereum contract.
type StakingRaw struct {
	Contract *Staking // Generic contract binding to access the raw methods on
}

// StakingCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StakingCallerRaw struct {
	Contract *StakingCaller // Generic read-only contract binding to access the raw methods on
}

// StakingTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StakingTransactorRaw struct {
	Contract *StakingTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStaking creates a new instance of Staking, bound to a specific deployed contract.
func NewStaking(address common.Address, backend bind.ContractBackend) (*Staking, error) {
	contract, err := bindStaking(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Staking{StakingCaller: StakingCaller{contract: contract}, StakingTransactor: StakingTransactor{contract: contract}, StakingFilterer: StakingFilterer{contract: contract}}, nil
}

// NewStakingCaller creates a new read-only instance of Staking, bound to a specific deployed contract.
func NewStakingCaller(address common.Address, caller bind.ContractCaller) (*StakingCaller, error) {
	contract, err := bindStaking(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StakingCaller{contract: contract}, nil
}

// NewStakingTransactor creates a new write-only instance of Staking, bound to a specific deployed contract.
func NewStakingTransactor(address common.Address, transactor bind.ContractTransactor) (*StakingTransactor, error) {
	contract, err := bindStaking(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StakingTransactor{contract: contract}, nil
}

// NewStakingFilterer creates a new log filterer instance of Staking, bound to a specific deployed contract.
func NewStakingFilterer(address common.Address, filterer bind.ContractFilterer) (*StakingFilterer, error) {
	contract, err := bindStaking(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StakingFilterer{contract: contract}, nil
}

// bindStaking binds a generic wrapper to an already deployed contract.
func bindStaking(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staking *StakingRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Staking.Contract.StakingCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staking *StakingRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.Contract.StakingTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staking *StakingRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staking.Contract.StakingTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staking *StakingCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Staking.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staking *StakingTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staking *StakingTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staking.Contract.contract.Transact(opts, method, params...)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() view returns(address)
func (_Staking *StakingCaller) ChallengeFactory(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "challengeFactory")
	return *ret0, err
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() view returns(address)
func (_Staking *StakingSession) ChallengeFactory() (common.Address, error) {
	return _Staking.Contract.ChallengeFactory(&_Staking.CallOpts)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() view returns(address)
func (_Staking *StakingCallerSession) ChallengeFactory() (common.Address, error) {
	return _Staking.Contract.ChallengeFactory(&_Staking.CallOpts)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() view returns(uint128)
func (_Staking *StakingCaller) GetStakeRequired(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "getStakeRequired")
	return *ret0, err
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() view returns(uint128)
func (_Staking *StakingSession) GetStakeRequired() (*big.Int, error) {
	return _Staking.Contract.GetStakeRequired(&_Staking.CallOpts)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() view returns(uint128)
func (_Staking *StakingCallerSession) GetStakeRequired() (*big.Int, error) {
	return _Staking.Contract.GetStakeRequired(&_Staking.CallOpts)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) view returns(bool)
func (_Staking *StakingCaller) IsStaked(opts *bind.CallOpts, _stakerAddress common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "isStaked", _stakerAddress)
	return *ret0, err
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) view returns(bool)
func (_Staking *StakingSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _Staking.Contract.IsStaked(&_Staking.CallOpts, _stakerAddress)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) view returns(bool)
func (_Staking *StakingCallerSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _Staking.Contract.IsStaked(&_Staking.CallOpts, _stakerAddress)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_Staking *StakingTransactor) ResolveChallenge(opts *bind.TransactOpts, winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "resolveChallenge", winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_Staking *StakingSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.ResolveChallenge(&_Staking.TransactOpts, winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_Staking *StakingTransactorSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.ResolveChallenge(&_Staking.TransactOpts, winner, loser, arg2)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_Staking *StakingTransactor) StartChallenge(opts *bind.TransactOpts, asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "startChallenge", asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_Staking *StakingSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.StartChallenge(&_Staking.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_Staking *StakingTransactorSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.StartChallenge(&_Staking.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StakingRollupChallengeCompletedIterator is returned from FilterRollupChallengeCompleted and is used to iterate over the raw logs and unpacked data for RollupChallengeCompleted events raised by the Staking contract.
type StakingRollupChallengeCompletedIterator struct {
	Event *StakingRollupChallengeCompleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupChallengeCompletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupChallengeCompleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupChallengeCompleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupChallengeCompletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupChallengeCompletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupChallengeCompleted represents a RollupChallengeCompleted event raised by the Staking contract.
type StakingRollupChallengeCompleted struct {
	ChallengeContract common.Address
	Winner            common.Address
	Loser             common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeCompleted is a free log retrieval operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_Staking *StakingFilterer) FilterRollupChallengeCompleted(opts *bind.FilterOpts) (*StakingRollupChallengeCompletedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return &StakingRollupChallengeCompletedIterator{contract: _Staking.contract, event: "RollupChallengeCompleted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeCompleted is a free log subscription operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_Staking *StakingFilterer) WatchRollupChallengeCompleted(opts *bind.WatchOpts, sink chan<- *StakingRollupChallengeCompleted) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupChallengeCompleted)
				if err := _Staking.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeCompleted is a log parse operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_Staking *StakingFilterer) ParseRollupChallengeCompleted(log types.Log) (*StakingRollupChallengeCompleted, error) {
	event := new(StakingRollupChallengeCompleted)
	if err := _Staking.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupChallengeStartedIterator is returned from FilterRollupChallengeStarted and is used to iterate over the raw logs and unpacked data for RollupChallengeStarted events raised by the Staking contract.
type StakingRollupChallengeStartedIterator struct {
	Event *StakingRollupChallengeStarted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupChallengeStartedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupChallengeStarted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupChallengeStarted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupChallengeStartedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupChallengeStartedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupChallengeStarted represents a RollupChallengeStarted event raised by the Staking contract.
type StakingRollupChallengeStarted struct {
	Asserter          common.Address
	Challenger        common.Address
	ChallengeType     *big.Int
	ChallengeContract common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeStarted is a free log retrieval operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_Staking *StakingFilterer) FilterRollupChallengeStarted(opts *bind.FilterOpts) (*StakingRollupChallengeStartedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return &StakingRollupChallengeStartedIterator{contract: _Staking.contract, event: "RollupChallengeStarted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeStarted is a free log subscription operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_Staking *StakingFilterer) WatchRollupChallengeStarted(opts *bind.WatchOpts, sink chan<- *StakingRollupChallengeStarted) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupChallengeStarted)
				if err := _Staking.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeStarted is a log parse operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_Staking *StakingFilterer) ParseRollupChallengeStarted(log types.Log) (*StakingRollupChallengeStarted, error) {
	event := new(StakingRollupChallengeStarted)
	if err := _Staking.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupStakeCreatedIterator is returned from FilterRollupStakeCreated and is used to iterate over the raw logs and unpacked data for RollupStakeCreated events raised by the Staking contract.
type StakingRollupStakeCreatedIterator struct {
	Event *StakingRollupStakeCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupStakeCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupStakeCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupStakeCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupStakeCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupStakeCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupStakeCreated represents a RollupStakeCreated event raised by the Staking contract.
type StakingRollupStakeCreated struct {
	Staker   common.Address
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeCreated is a free log retrieval operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_Staking *StakingFilterer) FilterRollupStakeCreated(opts *bind.FilterOpts) (*StakingRollupStakeCreatedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return &StakingRollupStakeCreatedIterator{contract: _Staking.contract, event: "RollupStakeCreated", logs: logs, sub: sub}, nil
}

// WatchRollupStakeCreated is a free log subscription operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_Staking *StakingFilterer) WatchRollupStakeCreated(opts *bind.WatchOpts, sink chan<- *StakingRollupStakeCreated) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupStakeCreated)
				if err := _Staking.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeCreated is a log parse operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_Staking *StakingFilterer) ParseRollupStakeCreated(log types.Log) (*StakingRollupStakeCreated, error) {
	event := new(StakingRollupStakeCreated)
	if err := _Staking.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupStakeMovedIterator is returned from FilterRollupStakeMoved and is used to iterate over the raw logs and unpacked data for RollupStakeMoved events raised by the Staking contract.
type StakingRollupStakeMovedIterator struct {
	Event *StakingRollupStakeMoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupStakeMovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupStakeMoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupStakeMoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupStakeMovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupStakeMovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupStakeMoved represents a RollupStakeMoved event raised by the Staking contract.
type StakingRollupStakeMoved struct {
	Staker     common.Address
	ToNodeHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeMoved is a free log retrieval operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_Staking *StakingFilterer) FilterRollupStakeMoved(opts *bind.FilterOpts) (*StakingRollupStakeMovedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return &StakingRollupStakeMovedIterator{contract: _Staking.contract, event: "RollupStakeMoved", logs: logs, sub: sub}, nil
}

// WatchRollupStakeMoved is a free log subscription operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_Staking *StakingFilterer) WatchRollupStakeMoved(opts *bind.WatchOpts, sink chan<- *StakingRollupStakeMoved) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupStakeMoved)
				if err := _Staking.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeMoved is a log parse operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_Staking *StakingFilterer) ParseRollupStakeMoved(log types.Log) (*StakingRollupStakeMoved, error) {
	event := new(StakingRollupStakeMoved)
	if err := _Staking.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupStakeRefundedIterator is returned from FilterRollupStakeRefunded and is used to iterate over the raw logs and unpacked data for RollupStakeRefunded events raised by the Staking contract.
type StakingRollupStakeRefundedIterator struct {
	Event *StakingRollupStakeRefunded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupStakeRefundedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupStakeRefunded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupStakeRefunded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupStakeRefundedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupStakeRefundedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupStakeRefunded represents a RollupStakeRefunded event raised by the Staking contract.
type StakingRollupStakeRefunded struct {
	Staker common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeRefunded is a free log retrieval operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_Staking *StakingFilterer) FilterRollupStakeRefunded(opts *bind.FilterOpts) (*StakingRollupStakeRefundedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return &StakingRollupStakeRefundedIterator{contract: _Staking.contract, event: "RollupStakeRefunded", logs: logs, sub: sub}, nil
}

// WatchRollupStakeRefunded is a free log subscription operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_Staking *StakingFilterer) WatchRollupStakeRefunded(opts *bind.WatchOpts, sink chan<- *StakingRollupStakeRefunded) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupStakeRefunded)
				if err := _Staking.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeRefunded is a log parse operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_Staking *StakingFilterer) ParseRollupStakeRefunded(log types.Log) (*StakingRollupStakeRefunded, error) {
	event := new(StakingRollupStakeRefunded)
	if err := _Staking.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// VMABI is the input ABI used to generate the binding from.
const VMABI = "[]"

// VMBin is the compiled bytecode used for deploying new contracts.
var VMBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820d7c9e68fb76299ef596ead4d6c13362eedd484e3987351586105918380009a4864736f6c63430005110032"

// DeployVM deploys a new Ethereum contract, binding an instance of VM to it.
func DeployVM(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *VM, error) {
	parsed, err := abi.JSON(strings.NewReader(VMABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(VMBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &VM{VMCaller: VMCaller{contract: contract}, VMTransactor: VMTransactor{contract: contract}, VMFilterer: VMFilterer{contract: contract}}, nil
}

// VM is an auto generated Go binding around an Ethereum contract.
type VM struct {
	VMCaller     // Read-only binding to the contract
	VMTransactor // Write-only binding to the contract
	VMFilterer   // Log filterer for contract events
}

// VMCaller is an auto generated read-only Go binding around an Ethereum contract.
type VMCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VMTransactor is an auto generated write-only Go binding around an Ethereum contract.
type VMTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VMFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type VMFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VMSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type VMSession struct {
	Contract     *VM               // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// VMCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type VMCallerSession struct {
	Contract *VMCaller     // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// VMTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type VMTransactorSession struct {
	Contract     *VMTransactor     // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// VMRaw is an auto generated low-level Go binding around an Ethereum contract.
type VMRaw struct {
	Contract *VM // Generic contract binding to access the raw methods on
}

// VMCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type VMCallerRaw struct {
	Contract *VMCaller // Generic read-only contract binding to access the raw methods on
}

// VMTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type VMTransactorRaw struct {
	Contract *VMTransactor // Generic write-only contract binding to access the raw methods on
}

// NewVM creates a new instance of VM, bound to a specific deployed contract.
func NewVM(address common.Address, backend bind.ContractBackend) (*VM, error) {
	contract, err := bindVM(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &VM{VMCaller: VMCaller{contract: contract}, VMTransactor: VMTransactor{contract: contract}, VMFilterer: VMFilterer{contract: contract}}, nil
}

// NewVMCaller creates a new read-only instance of VM, bound to a specific deployed contract.
func NewVMCaller(address common.Address, caller bind.ContractCaller) (*VMCaller, error) {
	contract, err := bindVM(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &VMCaller{contract: contract}, nil
}

// NewVMTransactor creates a new write-only instance of VM, bound to a specific deployed contract.
func NewVMTransactor(address common.Address, transactor bind.ContractTransactor) (*VMTransactor, error) {
	contract, err := bindVM(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &VMTransactor{contract: contract}, nil
}

// NewVMFilterer creates a new log filterer instance of VM, bound to a specific deployed contract.
func NewVMFilterer(address common.Address, filterer bind.ContractFilterer) (*VMFilterer, error) {
	contract, err := bindVM(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &VMFilterer{contract: contract}, nil
}

// bindVM binds a generic wrapper to an already deployed contract.
func bindVM(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(VMABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_VM *VMRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _VM.Contract.VMCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_VM *VMRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _VM.Contract.VMTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_VM *VMRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _VM.Contract.VMTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_VM *VMCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _VM.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_VM *VMTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _VM.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_VM *VMTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _VM.Contract.contract.Transact(opts, method, params...)
}

// ValueABI is the input ABI used to generate the binding from.
const ValueABI = "[]"

// ValueBin is the compiled bytecode used for deploying new contracts.
var ValueBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a723158201fe9469de644da1f3ec98a19028f1f3f30ea7e34bdc0fd2f3b84092fc4cde58d64736f6c63430005110032"

// DeployValue deploys a new Ethereum contract, binding an instance of Value to it.
func DeployValue(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Value, error) {
	parsed, err := abi.JSON(strings.NewReader(ValueABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ValueBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Value{ValueCaller: ValueCaller{contract: contract}, ValueTransactor: ValueTransactor{contract: contract}, ValueFilterer: ValueFilterer{contract: contract}}, nil
}

// Value is an auto generated Go binding around an Ethereum contract.
type Value struct {
	ValueCaller     // Read-only binding to the contract
	ValueTransactor // Write-only binding to the contract
	ValueFilterer   // Log filterer for contract events
}

// ValueCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValueCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValueTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValueTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValueFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValueFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValueSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValueSession struct {
	Contract     *Value            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ValueCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValueCallerSession struct {
	Contract *ValueCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ValueTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValueTransactorSession struct {
	Contract     *ValueTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ValueRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValueRaw struct {
	Contract *Value // Generic contract binding to access the raw methods on
}

// ValueCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValueCallerRaw struct {
	Contract *ValueCaller // Generic read-only contract binding to access the raw methods on
}

// ValueTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValueTransactorRaw struct {
	Contract *ValueTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValue creates a new instance of Value, bound to a specific deployed contract.
func NewValue(address common.Address, backend bind.ContractBackend) (*Value, error) {
	contract, err := bindValue(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Value{ValueCaller: ValueCaller{contract: contract}, ValueTransactor: ValueTransactor{contract: contract}, ValueFilterer: ValueFilterer{contract: contract}}, nil
}

// NewValueCaller creates a new read-only instance of Value, bound to a specific deployed contract.
func NewValueCaller(address common.Address, caller bind.ContractCaller) (*ValueCaller, error) {
	contract, err := bindValue(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValueCaller{contract: contract}, nil
}

// NewValueTransactor creates a new write-only instance of Value, bound to a specific deployed contract.
func NewValueTransactor(address common.Address, transactor bind.ContractTransactor) (*ValueTransactor, error) {
	contract, err := bindValue(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValueTransactor{contract: contract}, nil
}

// NewValueFilterer creates a new log filterer instance of Value, bound to a specific deployed contract.
func NewValueFilterer(address common.Address, filterer bind.ContractFilterer) (*ValueFilterer, error) {
	contract, err := bindValue(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValueFilterer{contract: contract}, nil
}

// bindValue binds a generic wrapper to an already deployed contract.
func bindValue(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValueABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Value *ValueRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Value.Contract.ValueCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Value *ValueRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Value.Contract.ValueTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Value *ValueRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Value.Contract.ValueTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Value *ValueCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Value.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Value *ValueTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Value.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Value *ValueTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Value.Contract.contract.Transact(opts, method, params...)
}
