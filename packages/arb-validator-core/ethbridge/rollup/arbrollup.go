// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package rollup

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = abi.U256
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// ArbRollupABI is the input ABI used to generate the binding from.
const ArbRollupABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"logsAccHash\",\"type\":\"bytes32[]\"}],\"name\":\"ConfirmedAssertion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"ConfirmedValidAssertion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[8]\",\"name\":\"fields\",\"type\":\"bytes32[8]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inboxCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"importedMessageCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[4]\",\"name\":\"timeBounds\",\"type\":\"uint128[4]\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numArbGas\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numSteps\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didInboxInsn\",\"type\":\"bool\"}],\"name\":\"RollupAsserted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"}],\"name\":\"RollupChallengeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asserter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"}],\"name\":\"RollupChallengeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"initVMHash\",\"type\":\"bytes32\"}],\"name\":\"RollupCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"RollupPruned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"toNodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeMoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"RollupStakeRefunded\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeFactory\",\"outputs\":[{\"internalType\":\"contractIChallengeFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"initalProtoStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"branches\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"deadlineTicks\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"challengeNodeData\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"logsAcc\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"vmProtoStateHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"messageCounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"messages\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"stakerAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"stakerProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakerProofOffsets\",\"type\":\"uint256[]\"}],\"name\":\"confirm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"forwardContractMessage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakeRequired\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalInbox\",\"outputs\":[{\"internalType\":\"contractIGlobalInbox\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_vmState\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"_gracePeriodTicks\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_arbGasSpeedLimitPerTick\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"_maxExecutionSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint64[2]\",\"name\":\"_maxTimeBoundsWidth\",\"type\":\"uint64[2]\"},{\"internalType\":\"uint128\",\"name\":\"_stakeRequirement\",\"type\":\"uint128\"},{\"internalType\":\"addresspayable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_challengeFactoryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_globalInboxAddress\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakerAddress\",\"type\":\"address\"}],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"isValidLeaf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestConfirmed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[9]\",\"name\":\"_fields\",\"type\":\"bytes32[9]\"},{\"internalType\":\"uint256\",\"name\":\"_beforeInboxCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_prevDeadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_prevChildType\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"_numSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint128[4]\",\"name\":\"_timeBounds\",\"type\":\"uint128[4]\"},{\"internalType\":\"uint256\",\"name\":\"_importedMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_didInboxInsn\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"_numArbGas\",\"type\":\"uint64\"},{\"internalType\":\"bytes32[]\",\"name\":\"_stakerProof\",\"type\":\"bytes32[]\"}],\"name\":\"makeAssertion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof1\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof2\",\"type\":\"bytes32[]\"}],\"name\":\"moveStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerShutdown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof1\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof2\",\"type\":\"bytes32[]\"}],\"name\":\"placeStake\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"fromNodes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"leafProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"leafProofLengths\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"latestConfProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"latestConfirmedProofLengths\",\"type\":\"uint256[]\"}],\"name\":\"pruneLeaves\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakeConfirmed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"latestConfirmedProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"stakerProof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakeMooted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakeOld\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"disputableNodeHashVal\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"childType\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"vmProtoStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakePassedDeadline\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resolveChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_arbContract\",\"type\":\"address\"}],\"name\":\"spawnCallProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"asserterAddress\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"challengerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"prevNode\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"stakerNodeTypes\",\"type\":\"uint256[2]\"},{\"internalType\":\"bytes32[2]\",\"name\":\"vmProtoHashes\",\"type\":\"bytes32[2]\"},{\"internalType\":\"bytes32[]\",\"name\":\"asserterProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"challengerProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"asserterNodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"challengerDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"challengerPeriodTicks\",\"type\":\"uint128\"}],\"name\":\"startChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vmParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gracePeriodTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arbGasSpeedLimitPerTick\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"maxExecutionSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxBlockBoundsWidth\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxTimestampBoundsWidth\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ArbRollupFuncSigs maps the 4-byte function signature to its string representation.
var ArbRollupFuncSigs = map[string]string{
	"ffa1ad74": "VERSION()",
	"5dbaf68b": "challengeFactory()",
	"1a072771": "confirm(bytes32,uint256[],uint256[],bytes32[],bytes32[],bytes32[],uint256[],bytes,address[],bytes32[],uint256[])",
	"c5818317": "forwardContractMessage(address,bytes)",
	"d16c305d": "getStakeRequired()",
	"d489113a": "globalInbox()",
	"8e0f7167": "init(bytes32,uint128,uint128,uint64,uint64[2],uint128,address,address,address)",
	"6177fd18": "isStaked(address)",
	"57ca6d1b": "isValidLeaf(bytes32)",
	"65f7f80d": "latestConfirmed()",
	"a7067556": "makeAssertion(bytes32[9],uint256,uint256,uint32,uint64,uint128[4],uint256,bool,uint64,bytes32[])",
	"dbad0a39": "moveStake(bytes32[],bytes32[])",
	"cfa80707": "ownerShutdown()",
	"e0620d64": "placeStake(bytes32[],bytes32[])",
	"fcfd8d3f": "pruneLeaves(bytes32[],bytes32[],uint256[],bytes32[],uint256[])",
	"7cfaaf67": "recoverStakeConfirmed(bytes32[])",
	"33554032": "recoverStakeMooted(address,bytes32,bytes32[],bytes32[])",
	"113ec9d8": "recoverStakeOld(address,bytes32[])",
	"badb3f14": "recoverStakePassedDeadline(address,uint256,bytes32,uint256,bytes32,bytes32[])",
	"6bc3cd22": "resolveChallenge(address,address,uint256)",
	"f75e4866": "spawnCallProxy(address)",
	"bac5963f": "startChallenge(address,address,bytes32,uint256,uint256[2],bytes32[2],bytes32[],bytes32[],bytes32,bytes32,uint128)",
	"b7ff920e": "supportedContracts(address)",
	"bbc2cc00": "vmParams()",
}

// ArbRollupBin is the compiled bytecode used for deploying new contracts.
var ArbRollupBin = "0x608060405234801561001057600080fd5b5061554b806100206000396000f3fe60806040526004361061014b5760003560e01c8063bac5963f116100b6578063d489113a1161006f578063d489113a14610e80578063dbad0a3914610e95578063e0620d6414610f60578063f75e48661461101e578063fcfd8d3f14611051578063ffa1ad74146113075761014b565b8063bac5963f14610b0e578063badb3f1414610ccd578063bbc2cc0014610d70578063c581831714610dbc578063cfa8070714610e3a578063d16c305d14610e4f5761014b565b806365f7f80d1161010857806365f7f80d146108aa5780636bc3cd22146108d15780637cfaaf67146109145780638e0f71671461098f578063a706755614610a10578063b7ff920e14610adb5761014b565b8063113ec9d8146101505780631a072771146101dd578063335540321461072857806357ca6d1b146108085780635dbaf68b146108465780636177fd1814610877575b600080fd5b34801561015c57600080fd5b506101db6004803603604081101561017357600080fd5b6001600160a01b038235169190810190604081016020820135600160201b81111561019d57600080fd5b8201836020820111156101af57600080fd5b803590602001918460208302840111600160201b831117156101d057600080fd5b509092509050611391565b005b3480156101e957600080fd5b506101db600480360361016081101561020157600080fd5b81359190810190604081016020820135600160201b81111561022257600080fd5b82018360208201111561023457600080fd5b803590602001918460208302840111600160201b8311171561025557600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156102a457600080fd5b8201836020820111156102b657600080fd5b803590602001918460208302840111600160201b831117156102d757600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561032657600080fd5b82018360208201111561033857600080fd5b803590602001918460208302840111600160201b8311171561035957600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156103a857600080fd5b8201836020820111156103ba57600080fd5b803590602001918460208302840111600160201b831117156103db57600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561042a57600080fd5b82018360208201111561043c57600080fd5b803590602001918460208302840111600160201b8311171561045d57600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156104ac57600080fd5b8201836020820111156104be57600080fd5b803590602001918460208302840111600160201b831117156104df57600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561052e57600080fd5b82018360208201111561054057600080fd5b803590602001918460018302840111600160201b8311171561056157600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b8111156105b357600080fd5b8201836020820111156105c557600080fd5b803590602001918460208302840111600160201b831117156105e657600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561063557600080fd5b82018360208201111561064757600080fd5b803590602001918460208302840111600160201b8311171561066857600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156106b757600080fd5b8201836020820111156106c957600080fd5b803590602001918460208302840111600160201b831117156106ea57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550611482945050505050565b34801561073457600080fd5b506101db6004803603608081101561074b57600080fd5b6001600160a01b0382351691602081013591810190606081016040820135600160201b81111561077a57600080fd5b82018360208201111561078c57600080fd5b803590602001918460208302840111600160201b831117156107ad57600080fd5b919390929091602081019035600160201b8111156107ca57600080fd5b8201836020820111156107dc57600080fd5b803590602001918460208302840111600160201b831117156107fd57600080fd5b5090925090506114d4565b34801561081457600080fd5b506108326004803603602081101561082b57600080fd5b503561162c565b604080519115158252519081900360200190f35b34801561085257600080fd5b5061085b611644565b604080516001600160a01b039092168252519081900360200190f35b34801561088357600080fd5b506108326004803603602081101561089a57600080fd5b50356001600160a01b0316611653565b3480156108b657600080fd5b506108bf611670565b60408051918252519081900360200190f35b3480156108dd57600080fd5b506101db600480360360608110156108f457600080fd5b506001600160a01b03813581169160208101359091169060400135611676565b34801561092057600080fd5b506101db6004803603602081101561093757600080fd5b810190602081018135600160201b81111561095157600080fd5b82018360208201111561096357600080fd5b803590602001918460208302840111600160201b8311171561098457600080fd5b5090925090506117d2565b34801561099b57600080fd5b506101db60048036036101408110156109b357600080fd5b508035906001600160801b03602082013581169160408101358216916001600160401b0360608301351691608081019160c082013516906001600160a01b0360e08201358116916101008101358216916101209091013516611813565b348015610a1c57600080fd5b506101db60048036036102a0811015610a3457600080fd5b610120820135906101408301359063ffffffff61016085013516906001600160401b036101808601358116916101a0870191610220880135916102408901351515916102608a013516908901896102a08101610280820135600160201b811115610a9d57600080fd5b820183602082011115610aaf57600080fd5b803590602001918460208302840111600160201b83111715610ad057600080fd5b50909250905061187f565b348015610ae757600080fd5b5061085b60048036036020811015610afe57600080fd5b50356001600160a01b0316611a69565b348015610b1a57600080fd5b506101db60048036036101a0811015610b3257600080fd5b6040805180820182526001600160a01b0384358116946020810135909116938382013593606083013593918301929160c083019160808401906002908390839080828437600092019190915250506040805180820182529295949381810193925090600290839083908082843760009201919091525091949392602081019250359050600160201b811115610bc657600080fd5b820183602082011115610bd857600080fd5b803590602001918460208302840111600160201b83111715610bf957600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b811115610c4857600080fd5b820183602082011115610c5a57600080fd5b803590602001918460208302840111600160201b83111715610c7b57600080fd5b91908080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525092955050823593505050602081013590604001356001600160801b0316611a84565b348015610cd957600080fd5b506101db600480360360c0811015610cf057600080fd5b6001600160a01b03823516916020810135916040820135916060810135916080820135919081019060c0810160a0820135600160201b811115610d3257600080fd5b820183602082011115610d4457600080fd5b803590602001918460208302840111600160201b83111715610d6557600080fd5b509092509050611eb6565b348015610d7c57600080fd5b50610d85612031565b6040805195865260208601949094526001600160401b03928316858501529082166060850152166080830152519081900360a00190f35b6101db60048036036040811015610dd257600080fd5b6001600160a01b038235169190810190604081016020820135600160201b811115610dfc57600080fd5b820183602082011115610e0e57600080fd5b803590602001918460018302840111600160201b83111715610e2f57600080fd5b50909250905061205c565b348015610e4657600080fd5b506101db6121d6565b348015610e5b57600080fd5b50610e64612255565b604080516001600160801b039092168252519081900360200190f35b348015610e8c57600080fd5b5061085b612264565b348015610ea157600080fd5b506101db60048036036040811015610eb857600080fd5b810190602081018135600160201b811115610ed257600080fd5b820183602082011115610ee457600080fd5b803590602001918460208302840111600160201b83111715610f0557600080fd5b919390929091602081019035600160201b811115610f2257600080fd5b820183602082011115610f3457600080fd5b803590602001918460208302840111600160201b83111715610f5557600080fd5b509092509050612273565b6101db60048036036040811015610f7657600080fd5b810190602081018135600160201b811115610f9057600080fd5b820183602082011115610fa257600080fd5b803590602001918460208302840111600160201b83111715610fc357600080fd5b919390929091602081019035600160201b811115610fe057600080fd5b820183602082011115610ff257600080fd5b803590602001918460208302840111600160201b8311171561101357600080fd5b509092509050612384565b34801561102a57600080fd5b506101db6004803603602081101561104157600080fd5b50356001600160a01b0316612497565b34801561105d57600080fd5b506101db600480360360a081101561107457600080fd5b810190602081018135600160201b81111561108e57600080fd5b8201836020820111156110a057600080fd5b803590602001918460208302840111600160201b831117156110c157600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561111057600080fd5b82018360208201111561112257600080fd5b803590602001918460208302840111600160201b8311171561114357600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561119257600080fd5b8201836020820111156111a457600080fd5b803590602001918460208302840111600160201b831117156111c557600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561121457600080fd5b82018360208201111561122657600080fd5b803590602001918460208302840111600160201b8311171561124757600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561129657600080fd5b8201836020820111156112a857600080fd5b803590602001918460208302840111600160201b831117156112c957600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550612520945050505050565b34801561131357600080fd5b5061131c6125e9565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561135657818101518382015260200161133e565b50505050905090810190601f1680156113835780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b60408051808201909152600e81526d0a48a86ac9e9888be988a9c8ea8960931b60208201528161143f5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156114045781810151838201526020016113ec565b50505050905090810190601f1680156114315780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5061147d8383838080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061260692505050565b505050565b6114c76040518061010001604052808d81526020018c81526020018b81526020018a8152602001898152602001888152602001878152602001868152508484846126a5565b5050505050505050505050565b60006114df33612a40565b9050828260008181106114ee57fe5b905060200201358585600081811061150257fe5b9050602002013514158015611559575061151a611670565b61155787878780806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612ad092505050565b145b80156115a057508061159e87858580806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612ad092505050565b145b604051806040016040528060148152602001732922a1a7ab2fa1a7a7232624a1aa2fa82927a7a360611b815250906116195760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5061162387612ae7565b50505050505050565b60008181526004602052604090205460ff165b919050565b6006546001600160a01b031681565b6001600160a01b0316600090815260086020526040902054151590565b60055490565b336000908152600a6020908152604091829020548251808401909352600f83526e2922a9afa1a420a62fa9a2a72222a960891b9183019190915260ff166116fe5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50336000908152600a60205260408120805460ff1916905561171f84612b70565b6007546040519192506001600160a01b0386169160026001600160801b039283160490911680156108fc02916000818181858888f1935050505015801561176a573d6000803e3d6000fd5b5060018101805460ff60801b1916905561178383612bfa565b604080513381526001600160a01b03808716602083015285168183015290517f468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f299181900360600190a150505050565b61180f3383838080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061260692505050565b5050565b61184b89898989896002806020026040519081016040528092919082600260200280828437600092019190915250889150612c3b9050565b6118558483612d4e565b5050600b80546001600160a01b0319166001600160a01b0392909216919091179055505050505050565b611887615280565b60408051610220810182528d3581526020808f0135908201528082018d9052908d01356060820152608081018b905260a081018d6003602002013581526020018a63ffffffff168152602001896001600160401b03168152602001886004806020026040519081016040528092919082600460200280828437600092019190915250505081526020810188905260808e810135604083015260a08f01356060830152018d6006602002013581526020018615158152602001856001600160401b031681526020018d60076009811061195b57fe5b602002013581526020018d60086009811061197257fe5b60200201359052905060008061198783612e84565b91509150600061199633612a40565b9050826119d682888880806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612ad092505050565b146040518060400160405280601181526020017026a0a5a2afa9aa20a5a2a92fa82927a7a360791b81525090611a4d5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50611a58338361306d565b505050505050505050505050505050565b600d602052600090815260409020546001600160a01b031681565b6000611a8f8c612b70565b90506000611a9c8c612b70565b60018301549091508a90611ab8906001600160801b03166130c6565b106040518060400160405280600d81526020016c53544b315f444541444c494e4560981b81525090611b2b5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5060018101548a90611b45906001600160801b03166130c6565b106040518060400160405280600d81526020016c53544b325f444541444c494e4560981b81525090611bb85760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50600182015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff1615611c385760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50600181015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff1615611cb85760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b506020808a01518a5160408051808201909152600a8152692a2ca822afa7a92222a960b11b9381019390935211611d305760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b508154611d58611d528d8d898e600060200201518e60005b60200201516130cd565b89612ad0565b146040518060400160405280600c81526020016b20a9a9a2a92a2fa82927a7a360a11b81525090611dca5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b508054611dfb611df58d8d611de8896001600160801b038a16613135565b60208f01518e6001611d48565b88612ad0565b146040518060400160405280600a81526020016921a420a62fa82927a7a360b11b81525090611e6b5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5060018281018054600160801b60ff60801b19918216811790925591830180549092161790556020890151611ea7908e908e9086908890613161565b50505050505050505050505050565b6000611ec133612a40565b90506000611ed282898989896130cd565b90506000611f1382868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612ad092505050565b9050611f1e8161162c565b604051806040016040528060138152602001722922a1a7ab2fa222a0a22624a722afa622a0a360691b81525090611f965760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50611fa0896130c6565b431015604051806040016040528060138152602001725245434f565f444541444c494e455f54494d4560681b8152509061201b5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b506120258a612ae7565b50505050505050505050565b6001546002546003546001600160401b0380821691600160401b8104821691600160801b9091041685565b336000908152600c60205260409020546001600160a01b0316806120b15760405162461bcd60e51b81526004018080602001828103825260298152602001806154ee6029913960400191505060405180910390fd5b60008054604080516396588a2760e01b81526001600160a01b0385811660048301528881166024830152915191909216926396588a279234926044808301939282900301818588803b15801561210657600080fd5b505af115801561211a573d6000803e3d6000fd5b50506000546040516384cb799760e01b81526001600160a01b03868116600483019081528a821660248401523460448401819052608060648501908152608485018b90529290941696506384cb799795508794508a93928a928a929160a401848480828437600081840152601f19601f8201169050808301925050509650505050505050600060405180830381600087803b1580156121b857600080fd5b505af11580156121cc573d6000803e3d6000fd5b5050505050505050565b600b5460408051808201909152600a81526927a7262cafa7aba722a960b11b6020820152906001600160a01b031633146122515760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5033ff5b6007546001600160801b031690565b6000546001600160a01b031681565b600061227e33612a40565b905060006122bf82878780806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612ad092505050565b9050600061230082868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612ad092505050565b905061230b8161162c565b6040518060400160405280600981526020016826a7ab22afa622a0a360b91b815250906123795760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50611623338361306d565b60006123ca612391611670565b868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612ad092505050565b9050600061240b82858580806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612ad092505050565b90506124168161162c565b6040518060400160405280600a815260200169282620a1a2afa622a0a360b11b815250906124855760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5061248f8261327f565b505050505050565b6000306040516124a69061530d565b6001600160a01b03909116815260405190819003602001906000f0801580156124d3573d6000803e3d6000fd5b506001600160a01b039081166000818152600c602090815260408083208054959097166001600160a01b03199586168117909755958252600d905293909320805490911690921790915550565b84518351811480156125325750808251145b61257c576040805162461bcd60e51b81526020600482015260166024820152750d2dce0eae840d8cadccee8d040dad2e6e8dac2e8c6d60531b604482015290519081900360640190fd5b600080805b838110156125de576125d189828151811061259857fe5b60200260200101518683815181106125ac57fe5b60200260200101518984815181106125c057fe5b60200260200101518b8a888861342d565b9093509150600101612581565b505050505050505050565b604051806040016040528060018152602001600d60fa1b81525081565b600061261133612a40565b905061261b611670565b6126258284612ad0565b146040518060400160405280601081526020016f2922a1a7ab2fa820aa242fa82927a7a360811b8152509061269b5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5061147d83612ae7565b6020840151516040850151805160001983019081106126c057fe5b60200260200101516126d1436130c6565b101560405180604001604052806009815260200168434f4e465f54494d4560b81b815250906127415760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b506060600061275787612752611670565b6135f6565b8151919350915060005b818110156127b15783818151811061277557fe5b60200260200101517f89cc5e236414c34f1206c0c14d8ac5b0e5444b669b309aaca16fe3d27749f50e60405160405180910390a2600101612761565b5060006127db838a6040015160018803815181106127cb57fe5b60200260200101518a8a8a6136b3565b9050600081116040518060400160405280600f81526020016e21a7a7232fa420a9afa9aa20a5a2a960891b815250906128555760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5061285f8361382d565b6000805460e08b015160c08c015160405163072fd2bb60e01b81526060600482019081528351606483015283516001600160a01b039095169563072fd2bb958b938392602482019260448301926084019160208a0191908190849084905b838110156128d55781810151838201526020016128bd565b50505050905090810190601f1680156129025780820380516001836020036101000a031916815260200191505b508481038352865181528651602091820191808901910280838360005b8381101561293757818101518382015260200161291f565b50505050905001848103825285818151815260200191508051906020019060200280838360005b8381101561297657818101518382015260200161295e565b505050509050019650505050505050600060405180830381600087803b15801561299f57600080fd5b505af11580156129b3573d6000803e3d6000fd5b5050505060008211156125de57608089015160408051602080825283518183015283517fded5fa103431438087188a5f8c6a4c3ea90996bbd63be7b1b3fa0a425b37fdd59493839290830191818601910280838360005b83811015612a22578181015183820152602001612a0a565b505050509050019250505060405180910390a1505050505050505050565b6001600160a01b0381166000908152600860209081526040808320548151808301909252600a82526924a72b2fa9aa20a5a2a960b11b9282019290925281612ac95760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5092915050565b6000612ae0838360008551613868565b9392505050565b612af081612bfa565b6007546040516001600160a01b038316916001600160801b031680156108fc02916000818181858888f19350505050158015612b30573d6000803e3d6000fd5b50604080516001600160a01b038316815290517f953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c9181900360200190a150565b6001600160a01b038116600090815260086020908152604080832080548251808401909352600a83526924a72b2fa9aa20a5a2a960b11b9383019390935291612ac95760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b6001600160a01b03166000908152600860205260408120908155600101805470ffffffffffffffffffffffffffffffffff1916905560098054600019019055565b600080546001600160a01b0319166001600160a01b038316178155612c6987612c626138d2565b60006138f3565b90506000612c7a81808080866130cd565b60058190556000818152600460209081526040918290208054600160ff1990911681179091556001600160801b038b81169091558916600255600380548851898401516001600160401b03918216600160401b0267ffffffffffffffff199093168c8316176fffffffffffffffff000000000000000019169290921767ffffffffffffffff60801b1916600160801b919092160217905581518b815291519293507f4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d92918290030190a15050505050505050565b60065460408051808201909152600a815269494e49545f545749434560b01b6020820152906001600160a01b031615612dc85760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5060408051808201909152600c81526b494e49545f4e4f4e5a45524f60a01b60208201526001600160a01b038216612e415760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50600680546001600160a01b0319166001600160a01b0392909216919091179055600780546001600160801b0319166001600160801b0392909216919091179055565b600080600080612e938561392a565b91509150612ea08261162c565b6040518060400160405280600981526020016826a0a5a2afa622a0a360b91b81525090612f0e5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50612f1885613978565b6000805460408051630220168160e01b8152306004820152815184936001600160a01b03169263022016819260248082019391829003018186803b158015612f5f57600080fd5b505afa158015612f73573d6000803e3d6000fd5b505050506040513d6040811015612f8957600080fd5b50805160209091015160408901519193509150612fad90829063ffffffff613c1816565b87610120015111156040518060400160405280601081526020016f135052d157d35154d4d051d157d0d39560821b8152509061302a5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50600061303a8886868686613c5a565b6000868152600460205260409020805460ff19169055905061305f8886838686613d63565b939550929350505050915091565b6001600160a01b0382166000818152600860209081526040918290208490558151928352820183905280517fbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f49281900390910190a15050565b6103e80290565b6040805160208082018490528183018790526060820186905260808083018690528351808403909101815260a08301845280519082012060c0830189905260e08084019190915283518084039091018152610100909201909252805191012095945050505050565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b6006546040805163432ed0e160e11b81526001600160a01b03888116600483015287811660248301526001600160801b038716604483015260648201869052608482018590529151600093929092169163865da1c29160a48082019260209290919082900301818787803b1580156131d857600080fd5b505af11580156131ec573d6000803e3d6000fd5b505050506040513d602081101561320257600080fd5b50516001600160a01b038082166000818152600a6020908152604091829020805460ff1916600117905581518b85168152938a16908401528281018690526060830191909152519192507f6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f919081900360800190a1505050505050565b60078054604080518082019091529182526614d512d7d0535560ca1b60208301526001600160801b031634146132f65760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5033600090815260086020908152604091829020548251808401909352600c83526b105314911657d4d51052d15160a21b918301919091521561337a5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50604080516060810182528281526001600160801b03438116602080840191825260008486018181523380835260088452918790209551865592516001958601805494511515600160801b0260ff60801b19929096166001600160801b031990951694909417169390931790915560098054909301909255825190815290810183905281517fcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88929181900390910190a150565b6000806000871180156134405750600088115b6040518060400160405280600e81526020016d28292aa722afa82927a7a32622a760911b815250906134b35760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5083870183890160006134c4611670565b6134d08d8a8986613868565b14905080801561350657508786815181106134e757fe5b60200260200101518988815181106134fb57fe5b602002602001015114155b6040518060400160405280600e81526020016d141495539157d0d3d391931250d560921b815250906135795760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5060006135888d8b8a87613868565b90506135938161162c565b156135e457600081815260046020908152604091829020805460ff19169055815183815291517f3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f44909509281900390910190a15b50919b909a5098505050505050505050565b6060600061360384613e96565b6020808501515160c0860151516040805182815282850281019094019052909181801561363a578160200160208202803883390190505b50935061364561531a565b86516136519087613ee8565b90506000805b848110156136a25761366a898483613f22565b9093509150811561369a5782608001518760018560000151038151811061368d57fe5b6020026020010181815250505b600101613657565b505060800151925050509250929050565b825160095460408051808201909152600a81526910d210d2d7d0d3d5539560b21b602082015260009291821461372a5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50825181600101146040518060400160405280600c81526020016b4348434b5f4f46465345545360a01b815250906137a35760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5060008080805b8481101561381e5760008982815181106137c057fe5b602002602001015190506138028c8a8d84898d88815181106137de57fe5b60200260200101518e89600101815181106137f557fe5b6020026020010151613ff1565b92508215613811576001909301925b60601b93506001016137aa565b50909998505050505050505050565b60058190556040805182815290517f9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f639181900360200190a150565b600084835b838110156138c6578186828151811061388257fe5b60200260200101516040516020018083815260200182815260200192505050604051602081830303815290604052805190602001209150808060010191505061386d565b5090505b949350505050565b604080516000808252602082019092526138ed81600161414e565b91505090565b6040805160208082019590955280820193909352606080840192909252805180840390920182526080909201909152805191012090565b60008060006139468460000151856020015186604001516138f3565b9050600061396d856060015186608001518760a001518860c0015163ffffffff16866130cd565b935090915050915091565b80516139839061416d565b1580156139985750805161399690614173565b155b6040518060400160405280600881526020016726a0a5a2afa92aa760c11b81525090613a055760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b5060035460e082015160408051808201909152600981526804d414b455f535445560bc1b6020820152916001600160401b0390811691161115613a895760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b506003546101008201518051600160401b9092046001600160401b03169091016001600160801b031690600160200201516001600160801b03161115613ace57600080fd5b6003546101008201516060810151600160801b9092046001600160401b03169091016001600160801b031690600260200201516001600160801b03161115613b1557600080fd5b613b23816101000151614177565b604051806040016040528060098152602001684d414b455f54494d4560b81b81525090613b915760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b506101208101511580613ba65750806101a001515b6040518060400160405280600d81526020016c4d414b455f4d4553534147455360981b8152509061180f5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b6000612ae083836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f7700008152506141d9565b6040805160a081018252600154815260025460208201526003546001600160401b0380821693830193909352600160401b810483166060830152600160801b9004909116608082015260009081908190613cb5908943614233565b915091506000613ccf89898489898c60016000015461428a565b90506000613ce58a8a858b6001600001546142d4565b90506000613cfc8b8b868c6001600001548a614339565b90506000613d0b8c8c876143c9565b6000948552600460205260408086208054600160ff1991821681179092559587528187208054871682179055938652808620805486168517905581865290942080549093169091179091555098975050505050505050565b7fccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc604051806101000160405280868152602001848152602001876101400151815260200187610160015181526020018761018001518152602001876101e00151815260200187610200015181526020018581525082876101200151886101000151896101c001518a60e001518b6101a001516040518088600860200280838360005b83811015613e1d578181015183820152602001613e05565b5050505090500187815260200186815260200185600460200280838360005b83811015613e54578181015183820152602001613e3c565b5050506001600160401b039788169390910192835250509290931660208301521515604080830191909152519081900360600195509350505050a15050505050565b60208101515160c08201515160a0830151518114613eb357600080fd5b8083608001515114613ec457600080fd5b8183604001515114613ed557600080fd5b8082038360600151511461147d57600080fd5b613ef061531a565b6040518060a0016040528060008152602001600081526020016000815260200184815260200183815250905092915050565b613f2a61531a565b60008085602001518481518110613f3d57fe5b60200260200101519050600060038214905060008115613f8557613f6a8888600001518960400151614411565b60608a01526040890191909152875160010188529050613fb4565b8760600151876020015181518110613f9957fe5b60200260200101519050866020018051809190600101815250505b613fe0876080015189604001518881518110613fcc57fe5b602002602001015183868b606001516130cd565b608088015250949694955050505050565b6000836bffffffffffffffffffffffff19168560601b6bffffffffffffffffffffffff1916116040518060400160405280600a81526020016921a421a5afa7a92222a960b11b815250906140865760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b50600061409286612b70565b600181015490915060009088906140b1906001600160801b03166130c6565b10905080156141415781546140c88b8b8888613868565b146040518060400160405280601181526020017021a421a5afa9aa20a5a2a92fa82927a7a360791b8152509061413f5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b505b9998505050505050505050565b6000614158615348565b614162848461449b565b90506138ca816144ba565b60011490565b1590565b80516000906001600160801b031643108015906141a1575060208201516001600160801b03164311155b80156141ba575060408201516001600160801b03164210155b80156141d3575060608201516001600160801b03164211155b92915050565b6000818484111561422b5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114045781810151838201526020016113ec565b505050900390565b60008060008560200151856101c001516001600160401b03168161425357fe5b04905060008660000151614266866130c6565b019050856080015181101561427c575060808501515b909690870195509350505050565b6000806142aa896101400151878b61012001518c604001510188036138f3565b905061414188886142c6846142bf60016130c6565b8801613135565b6142ce614520565b886130cd565b6000806142fe87602001518861014001516142ed6138d2565b8a61016001518b6101200151614525565b905060006143178261431060016130c6565b8601613135565b905061432d87878361432761456b565b896130cd565b98975050505050505050565b60008061435588600001518961010001518a6101600151614570565b905060006143878961018001518a6101a001518b6101c001516000801b8d6101e001516000801b8f61020001516145e1565b9050600061439a8a60e001518484614644565b90506143bb89896143ad84898b01613135565b6143b561468c565b8b6130cd565b9a9950505050505050505050565b60006138ca83836143e4876101e00151886102000151613135565b6143ec614691565b61440c8961018001518a61014001518b61012001518c60400151016138f3565b6130cd565b600080600080600061443f8860e00151878a60c001518a8151811061443257fe5b6020026020010151614696565b915091506000614466838a608001518a8151811061445957fe5b6020026020010151613135565b905060008960a00151898151811061447a57fe5b60200260200101519050828282965096509650505050505b93509350939050565b6144a3615348565b60006144ae84614759565b90506138ca8184614819565b606081015160009060ff1660021461450f576040805162461bcd60e51b815260206004820152601360248201527209aeae6e840c4ca40a0e4ca92dac2ceca90e6d606b1b604482015290519081900360640190fd5b815160808301516141d3919061489d565b600090565b60408051602080820197909752808201959095526060850193909352608084019190915260a0808401919091528151808403909101815260c09092019052805191012090565b600190565b81516020808401516040808601516060968701518251808601999099526001600160801b0319608096871b81168a85015293861b841660508a015290851b83169688019690965294831b166070860152818501929092528251808503909101815260a0909301909152815191012090565b6040805160208082019990995296151560f81b8782015260c09590951b6001600160c01b031916604187015260498601939093526069850191909152608984015260a9808401919091528151808403909101815260c99092019052805191012090565b6040805160c09490941b6001600160c01b0319166020808601919091526028850193909352604880850192909252805180850390920182526068909301909252815191012090565b600290565b600390565b60008080806146a3615348565b8660005b87811015614749576146b98a836148d7565b91965090935091508461470c576040805162461bcd60e51b8152602060048201526016602482015275496e76616c6964206f7574707574206d65737361676560501b604482015290519081900360640190fd5b8361471684614a15565b604080516020808201949094528082019290925280518083038201815260609092019052805191012093506001016146a7565b5091989197509095505050505050565b60006008825111156147a9576040805162461bcd60e51b8152602060048201526014602482015273092dcecc2d8d2c840e8eae0d8ca40d8cadccee8d60631b604482015290519081900360640190fd5b6000825183604051602001808360ff1660ff1660f81b8152600101828051906020019060200280838360005b838110156147ed5781810151838201526020016147d5565b505050509050019250505060405160208183030381529060405280519060200120905080915050919050565b614821615348565b6040805160a0810182528481528151608081018352600080825260208281018290528285018290526060830182905280840192909252835181815291820184529192830191614886565b614873615348565b81526020019060019003908161486b5790505b508152600260208201526040019290925250919050565b60408051600360f81b6020808301919091526021820194909452604180820193909352815180820390930183526061019052805191012090565b6000806148e2615348565b84518410614902576000846148f76000614b0b565b925092509250614a0e565b600080859050600087828151811061491657fe5b016020015160019092019160f81c9050600061493061537c565b60ff8316614964576149428a85614b90565b91965094509150848461495484614b0b565b9750975097505050505050614a0e565b60ff83166001141561498c5761497a8a85614be3565b91965094509050848461495483614d43565b60ff8316600214156149a2576149548a85614daa565b600360ff8416108015906149b95750600c60ff8416105b156149f457600219830160606149d0828d88614e4f565b9198509650905086866149e283614f09565b99509950995050505050505050614a0e565b600080614a016000614b0b565b9199509750955050505050505b9250925092565b6000600360090160ff16826060015160ff1610614a6d576040805162461bcd60e51b8152602060048201526011602482015270496e76616c6964207479706520636f646560781b604482015290519081900360640190fd5b606082015160ff16614a8b578151614a8490614ff8565b905061163f565b606082015160ff1660011415614abe576020808301518051604082015160608301519290930151614a849391929061501c565b606082015160ff1660021415614ad757614a84826144ba565b600360ff16826060015160ff1610158015614afb57506060820151600c60ff909116105b15614b0957614a84826150c4565bfe5b614b13615348565b6040805160a0810182528381528151608081018352600080825260208281018290528285018290526060830182905280840192909252835181815291820184529192830191614b78565b614b65615348565b815260200190600190039081614b5d5790505b50815260006020820152600160409091015292915050565b6000806000808551905084811080614baa57506020858203105b15614bbf575060009250839150829050614a0e565b600160208601614bd5888863ffffffff6150e216565b935093509350509250925092565b600080614bee61537c565b60008490506000868281518110614c0157fe5b602001015160f81c60f81b60f81c905081806001019250506000878381518110614c2757fe5b016020015160019384019360f89190911c915060009060ff84161415614cad576000614c51615348565b614c5b8b876148d7565b909750909250905081614c9f57505060408051608081018252600080825260208201819052918101829052606081018290529097508896509450614a0e9350505050565b614ca881614a15565b925050505b6000614cbf8a8663ffffffff6150e216565b90506020850194508360ff1660011415614d0b576040805160808101825260ff90941684526020840191909152600190830181905260608301919091529550919350909150614a0e9050565b6040805160808101825260ff949094168452602084019190915260009083018190526060830152506001989297509550909350505050565b614d4b615348565b6040805160a0810182526000808252602080830186905283518281529081018452919283019190614d92565b614d7f615348565b815260200190600190039081614d775790505b50815260016020820181905260409091015292915050565b600080614db5615348565b614dbd615348565b8551600090819087811080614dd457506040888203105b15614dec576000888596509650965050505050614a0e565b6000614dfe8a8a63ffffffff6150e216565b9050602089019850614e108a8a614b90565b909a50945092508215614e3b57614e278185614819565b600198508997509550614a0e945050505050565b600089869750975097505050505050614a0e565b60008060606000849050600060608860ff16604051908082528060200260200182016040528015614e9a57816020015b614e87615348565b815260200190600190039081614e7f5790505b50905060005b8960ff168160ff161015614ef757614eb889856148d7565b8451859060ff8616908110614ec957fe5b60209081029190910101529450925082614eef5750600095508694509250614492915050565b600101614ea0565b50600199929850965090945050505050565b614f11615348565b614f1b82516150fe565b614f6c576040805162461bcd60e51b815260206004820152601a60248201527f5475706c65206d75737420686176652076616c69642073697a65000000000000604482015290519081900360640190fd5b600160005b8351811015614fa357838181518110614f8657fe5b602002602001015160800151820191508080600101915050614f71565b506040805160a08101825260008082528251608080820185528282526020808301849052828601849052606080840194909452840191909152928201869052945160030160ff16948101949094528301525090565b60408051602080820193909352815180820384018152908201909152805191012090565b60008315615076575060408051600160f81b6020808301919091526001600160f81b031960f888901b16602183015260228201859052604280830185905283518084039091018152606290920190925280519101206138ca565b5060408051600160f81b6020808301919091526001600160f81b031960f888901b16602183015260228083018590528351808403909101815260429092019092528051910120949350505050565b60006150ce615348565b6150d783615105565b9050612ae0816144ba565b600081602001835110156150f557600080fd5b50016020015190565b6008101590565b61510d615348565b6151168261517b565b61515c576040805162461bcd60e51b81526020600482015260126024820152714d757374206265205475706c65207479706560701b604482015290519081900360640190fd5b606061516b836040015161518a565b9050612ae081846080015161449b565b60006141d38260600151615262565b60606008825111156151da576040805162461bcd60e51b8152602060048201526014602482015273092dcecc2d8d2c840e8eae0d8ca40d8cadccee8d60631b604482015290519081900360640190fd5b60608251604051908082528060200260200182016040528015615207578160200160208202803883390190505b50805190915060005b8181101561525957600061523686838151811061522957fe5b6020026020010151614a15565b90508084838151811061524557fe5b602090810291909101015250600101615210565b50909392505050565b6000600c60ff83161080156141d3575050600360ff91909116101590565b6040805161022081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081019190915261010081016152ce6153a3565b815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e082018190526101009091015290565b61012c806153c283390190565b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915290565b6040518060a001604052806000815260200161536261537c565b815260606020820181905260006040830181905291015290565b60408051608081018252600080825260208201819052918101829052606081019190915290565b6040518060800160405280600490602082028038833950919291505056fe608060405234801561001057600080fd5b5060405161012c38038061012c8339818101604052602081101561003357600080fd5b5051600080546001600160a01b039092166001600160a01b031990921691909117905560c8806100646000396000f3fe608060408181526000805463c581831760e01b90935233608481815260a49384523660c48190526001600160a01b039095169463c5818317943494929060e4848480828437600081840152601f19601f8201169050808301925050509450505050506000604051808303818588803b158015607957600080fd5b505af1158015608c573d6000803e3d6000fd5b505050505000fea265627a7a7231582095499efdd805ef927947826882e0ad2d797acbe02559cbc2422e593af041b0ae64736f6c634300050f00324e6f6e20696e7465726661636520636f6e74726163742063616e27742073656e64206d657373616765a265627a7a72315820934afb62a574983a9f878d3ffa0a933f23376b343330bfef4c09763fbc38d82f64736f6c634300050f0032"

// DeployArbRollup deploys a new Ethereum contract, binding an instance of ArbRollup to it.
func DeployArbRollup(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ArbRollup, error) {
	parsed, err := abi.JSON(strings.NewReader(ArbRollupABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ArbRollupBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ArbRollup{ArbRollupCaller: ArbRollupCaller{contract: contract}, ArbRollupTransactor: ArbRollupTransactor{contract: contract}, ArbRollupFilterer: ArbRollupFilterer{contract: contract}}, nil
}

// ArbRollup is an auto generated Go binding around an Ethereum contract.
type ArbRollup struct {
	ArbRollupCaller     // Read-only binding to the contract
	ArbRollupTransactor // Write-only binding to the contract
	ArbRollupFilterer   // Log filterer for contract events
}

// ArbRollupCaller is an auto generated read-only Go binding around an Ethereum contract.
type ArbRollupCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbRollupTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ArbRollupTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbRollupFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ArbRollupFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbRollupSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ArbRollupSession struct {
	Contract     *ArbRollup        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ArbRollupCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ArbRollupCallerSession struct {
	Contract *ArbRollupCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// ArbRollupTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ArbRollupTransactorSession struct {
	Contract     *ArbRollupTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// ArbRollupRaw is an auto generated low-level Go binding around an Ethereum contract.
type ArbRollupRaw struct {
	Contract *ArbRollup // Generic contract binding to access the raw methods on
}

// ArbRollupCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ArbRollupCallerRaw struct {
	Contract *ArbRollupCaller // Generic read-only contract binding to access the raw methods on
}

// ArbRollupTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ArbRollupTransactorRaw struct {
	Contract *ArbRollupTransactor // Generic write-only contract binding to access the raw methods on
}

// NewArbRollup creates a new instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollup(address common.Address, backend bind.ContractBackend) (*ArbRollup, error) {
	contract, err := bindArbRollup(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ArbRollup{ArbRollupCaller: ArbRollupCaller{contract: contract}, ArbRollupTransactor: ArbRollupTransactor{contract: contract}, ArbRollupFilterer: ArbRollupFilterer{contract: contract}}, nil
}

// NewArbRollupCaller creates a new read-only instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollupCaller(address common.Address, caller bind.ContractCaller) (*ArbRollupCaller, error) {
	contract, err := bindArbRollup(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ArbRollupCaller{contract: contract}, nil
}

// NewArbRollupTransactor creates a new write-only instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollupTransactor(address common.Address, transactor bind.ContractTransactor) (*ArbRollupTransactor, error) {
	contract, err := bindArbRollup(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ArbRollupTransactor{contract: contract}, nil
}

// NewArbRollupFilterer creates a new log filterer instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollupFilterer(address common.Address, filterer bind.ContractFilterer) (*ArbRollupFilterer, error) {
	contract, err := bindArbRollup(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ArbRollupFilterer{contract: contract}, nil
}

// bindArbRollup binds a generic wrapper to an already deployed contract.
func bindArbRollup(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ArbRollupABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ArbRollup *ArbRollupRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ArbRollup.Contract.ArbRollupCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ArbRollup *ArbRollupRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbRollup.Contract.ArbRollupTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ArbRollup *ArbRollupRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ArbRollup.Contract.ArbRollupTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ArbRollup *ArbRollupCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ArbRollup.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ArbRollup *ArbRollupTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbRollup.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ArbRollup *ArbRollupTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ArbRollup.Contract.contract.Transact(opts, method, params...)
}

// VERSION is a free data retrieval call binding the contract method 0xffa1ad74.
//
// Solidity: function VERSION() constant returns(string)
func (_ArbRollup *ArbRollupCaller) VERSION(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "VERSION")
	return *ret0, err
}

// VERSION is a free data retrieval call binding the contract method 0xffa1ad74.
//
// Solidity: function VERSION() constant returns(string)
func (_ArbRollup *ArbRollupSession) VERSION() (string, error) {
	return _ArbRollup.Contract.VERSION(&_ArbRollup.CallOpts)
}

// VERSION is a free data retrieval call binding the contract method 0xffa1ad74.
//
// Solidity: function VERSION() constant returns(string)
func (_ArbRollup *ArbRollupCallerSession) VERSION() (string, error) {
	return _ArbRollup.Contract.VERSION(&_ArbRollup.CallOpts)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_ArbRollup *ArbRollupCaller) ChallengeFactory(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "challengeFactory")
	return *ret0, err
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_ArbRollup *ArbRollupSession) ChallengeFactory() (common.Address, error) {
	return _ArbRollup.Contract.ChallengeFactory(&_ArbRollup.CallOpts)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_ArbRollup *ArbRollupCallerSession) ChallengeFactory() (common.Address, error) {
	return _ArbRollup.Contract.ChallengeFactory(&_ArbRollup.CallOpts)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_ArbRollup *ArbRollupCaller) GetStakeRequired(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "getStakeRequired")
	return *ret0, err
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_ArbRollup *ArbRollupSession) GetStakeRequired() (*big.Int, error) {
	return _ArbRollup.Contract.GetStakeRequired(&_ArbRollup.CallOpts)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_ArbRollup *ArbRollupCallerSession) GetStakeRequired() (*big.Int, error) {
	return _ArbRollup.Contract.GetStakeRequired(&_ArbRollup.CallOpts)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_ArbRollup *ArbRollupCaller) GlobalInbox(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "globalInbox")
	return *ret0, err
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_ArbRollup *ArbRollupSession) GlobalInbox() (common.Address, error) {
	return _ArbRollup.Contract.GlobalInbox(&_ArbRollup.CallOpts)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_ArbRollup *ArbRollupCallerSession) GlobalInbox() (common.Address, error) {
	return _ArbRollup.Contract.GlobalInbox(&_ArbRollup.CallOpts)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_ArbRollup *ArbRollupCaller) IsStaked(opts *bind.CallOpts, _stakerAddress common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "isStaked", _stakerAddress)
	return *ret0, err
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_ArbRollup *ArbRollupSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _ArbRollup.Contract.IsStaked(&_ArbRollup.CallOpts, _stakerAddress)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_ArbRollup *ArbRollupCallerSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _ArbRollup.Contract.IsStaked(&_ArbRollup.CallOpts, _stakerAddress)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_ArbRollup *ArbRollupCaller) IsValidLeaf(opts *bind.CallOpts, leaf [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "isValidLeaf", leaf)
	return *ret0, err
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_ArbRollup *ArbRollupSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _ArbRollup.Contract.IsValidLeaf(&_ArbRollup.CallOpts, leaf)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_ArbRollup *ArbRollupCallerSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _ArbRollup.Contract.IsValidLeaf(&_ArbRollup.CallOpts, leaf)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_ArbRollup *ArbRollupCaller) LatestConfirmed(opts *bind.CallOpts) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "latestConfirmed")
	return *ret0, err
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_ArbRollup *ArbRollupSession) LatestConfirmed() ([32]byte, error) {
	return _ArbRollup.Contract.LatestConfirmed(&_ArbRollup.CallOpts)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_ArbRollup *ArbRollupCallerSession) LatestConfirmed() ([32]byte, error) {
	return _ArbRollup.Contract.LatestConfirmed(&_ArbRollup.CallOpts)
}

// SupportedContracts is a free data retrieval call binding the contract method 0xb7ff920e.
//
// Solidity: function supportedContracts(address ) constant returns(address)
func (_ArbRollup *ArbRollupCaller) SupportedContracts(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "supportedContracts", arg0)
	return *ret0, err
}

// SupportedContracts is a free data retrieval call binding the contract method 0xb7ff920e.
//
// Solidity: function supportedContracts(address ) constant returns(address)
func (_ArbRollup *ArbRollupSession) SupportedContracts(arg0 common.Address) (common.Address, error) {
	return _ArbRollup.Contract.SupportedContracts(&_ArbRollup.CallOpts, arg0)
}

// SupportedContracts is a free data retrieval call binding the contract method 0xb7ff920e.
//
// Solidity: function supportedContracts(address ) constant returns(address)
func (_ArbRollup *ArbRollupCallerSession) SupportedContracts(arg0 common.Address) (common.Address, error) {
	return _ArbRollup.Contract.SupportedContracts(&_ArbRollup.CallOpts, arg0)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_ArbRollup *ArbRollupCaller) VmParams(opts *bind.CallOpts) (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	ret := new(struct {
		GracePeriodTicks        *big.Int
		ArbGasSpeedLimitPerTick *big.Int
		MaxExecutionSteps       uint64
		MaxBlockBoundsWidth     uint64
		MaxTimestampBoundsWidth uint64
	})
	out := ret
	err := _ArbRollup.contract.Call(opts, out, "vmParams")
	return *ret, err
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_ArbRollup *ArbRollupSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	return _ArbRollup.Contract.VmParams(&_ArbRollup.CallOpts)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_ArbRollup *ArbRollupCallerSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	return _ArbRollup.Contract.VmParams(&_ArbRollup.CallOpts)
}

// Confirm is a paid mutator transaction binding the contract method 0x1a072771.
//
// Solidity: function confirm(bytes32 initalProtoStateHash, uint256[] branches, uint256[] deadlineTicks, bytes32[] challengeNodeData, bytes32[] logsAcc, bytes32[] vmProtoStateHashes, uint256[] messageCounts, bytes messages, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactor) Confirm(opts *bind.TransactOpts, initalProtoStateHash [32]byte, branches []*big.Int, deadlineTicks []*big.Int, challengeNodeData [][32]byte, logsAcc [][32]byte, vmProtoStateHashes [][32]byte, messageCounts []*big.Int, messages []byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "confirm", initalProtoStateHash, branches, deadlineTicks, challengeNodeData, logsAcc, vmProtoStateHashes, messageCounts, messages, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// Confirm is a paid mutator transaction binding the contract method 0x1a072771.
//
// Solidity: function confirm(bytes32 initalProtoStateHash, uint256[] branches, uint256[] deadlineTicks, bytes32[] challengeNodeData, bytes32[] logsAcc, bytes32[] vmProtoStateHashes, uint256[] messageCounts, bytes messages, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupSession) Confirm(initalProtoStateHash [32]byte, branches []*big.Int, deadlineTicks []*big.Int, challengeNodeData [][32]byte, logsAcc [][32]byte, vmProtoStateHashes [][32]byte, messageCounts []*big.Int, messages []byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.Confirm(&_ArbRollup.TransactOpts, initalProtoStateHash, branches, deadlineTicks, challengeNodeData, logsAcc, vmProtoStateHashes, messageCounts, messages, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// Confirm is a paid mutator transaction binding the contract method 0x1a072771.
//
// Solidity: function confirm(bytes32 initalProtoStateHash, uint256[] branches, uint256[] deadlineTicks, bytes32[] challengeNodeData, bytes32[] logsAcc, bytes32[] vmProtoStateHashes, uint256[] messageCounts, bytes messages, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactorSession) Confirm(initalProtoStateHash [32]byte, branches []*big.Int, deadlineTicks []*big.Int, challengeNodeData [][32]byte, logsAcc [][32]byte, vmProtoStateHashes [][32]byte, messageCounts []*big.Int, messages []byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.Confirm(&_ArbRollup.TransactOpts, initalProtoStateHash, branches, deadlineTicks, challengeNodeData, logsAcc, vmProtoStateHashes, messageCounts, messages, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) returns()
func (_ArbRollup *ArbRollupTransactor) ForwardContractMessage(opts *bind.TransactOpts, _sender common.Address, _data []byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "forwardContractMessage", _sender, _data)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) returns()
func (_ArbRollup *ArbRollupSession) ForwardContractMessage(_sender common.Address, _data []byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.ForwardContractMessage(&_ArbRollup.TransactOpts, _sender, _data)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) returns()
func (_ArbRollup *ArbRollupTransactorSession) ForwardContractMessage(_sender common.Address, _data []byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.ForwardContractMessage(&_ArbRollup.TransactOpts, _sender, _data)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_ArbRollup *ArbRollupTransactor) Init(opts *bind.TransactOpts, _vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "init", _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_ArbRollup *ArbRollupSession) Init(_vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.Init(&_ArbRollup.TransactOpts, _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_ArbRollup *ArbRollupTransactorSession) Init(_vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.Init(&_ArbRollup.TransactOpts, _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// MakeAssertion is a paid mutator transaction binding the contract method 0xa7067556.
//
// Solidity: function makeAssertion(bytes32[9] _fields, uint256 _beforeInboxCount, uint256 _prevDeadlineTicks, uint32 _prevChildType, uint64 _numSteps, uint128[4] _timeBounds, uint256 _importedMessageCount, bool _didInboxInsn, uint64 _numArbGas, bytes32[] _stakerProof) returns()
func (_ArbRollup *ArbRollupTransactor) MakeAssertion(opts *bind.TransactOpts, _fields [9][32]byte, _beforeInboxCount *big.Int, _prevDeadlineTicks *big.Int, _prevChildType uint32, _numSteps uint64, _timeBounds [4]*big.Int, _importedMessageCount *big.Int, _didInboxInsn bool, _numArbGas uint64, _stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "makeAssertion", _fields, _beforeInboxCount, _prevDeadlineTicks, _prevChildType, _numSteps, _timeBounds, _importedMessageCount, _didInboxInsn, _numArbGas, _stakerProof)
}

// MakeAssertion is a paid mutator transaction binding the contract method 0xa7067556.
//
// Solidity: function makeAssertion(bytes32[9] _fields, uint256 _beforeInboxCount, uint256 _prevDeadlineTicks, uint32 _prevChildType, uint64 _numSteps, uint128[4] _timeBounds, uint256 _importedMessageCount, bool _didInboxInsn, uint64 _numArbGas, bytes32[] _stakerProof) returns()
func (_ArbRollup *ArbRollupSession) MakeAssertion(_fields [9][32]byte, _beforeInboxCount *big.Int, _prevDeadlineTicks *big.Int, _prevChildType uint32, _numSteps uint64, _timeBounds [4]*big.Int, _importedMessageCount *big.Int, _didInboxInsn bool, _numArbGas uint64, _stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MakeAssertion(&_ArbRollup.TransactOpts, _fields, _beforeInboxCount, _prevDeadlineTicks, _prevChildType, _numSteps, _timeBounds, _importedMessageCount, _didInboxInsn, _numArbGas, _stakerProof)
}

// MakeAssertion is a paid mutator transaction binding the contract method 0xa7067556.
//
// Solidity: function makeAssertion(bytes32[9] _fields, uint256 _beforeInboxCount, uint256 _prevDeadlineTicks, uint32 _prevChildType, uint64 _numSteps, uint128[4] _timeBounds, uint256 _importedMessageCount, bool _didInboxInsn, uint64 _numArbGas, bytes32[] _stakerProof) returns()
func (_ArbRollup *ArbRollupTransactorSession) MakeAssertion(_fields [9][32]byte, _beforeInboxCount *big.Int, _prevDeadlineTicks *big.Int, _prevChildType uint32, _numSteps uint64, _timeBounds [4]*big.Int, _importedMessageCount *big.Int, _didInboxInsn bool, _numArbGas uint64, _stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MakeAssertion(&_ArbRollup.TransactOpts, _fields, _beforeInboxCount, _prevDeadlineTicks, _prevChildType, _numSteps, _timeBounds, _importedMessageCount, _didInboxInsn, _numArbGas, _stakerProof)
}

// MoveStake is a paid mutator transaction binding the contract method 0xdbad0a39.
//
// Solidity: function moveStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupTransactor) MoveStake(opts *bind.TransactOpts, proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "moveStake", proof1, proof2)
}

// MoveStake is a paid mutator transaction binding the contract method 0xdbad0a39.
//
// Solidity: function moveStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupSession) MoveStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MoveStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// MoveStake is a paid mutator transaction binding the contract method 0xdbad0a39.
//
// Solidity: function moveStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupTransactorSession) MoveStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MoveStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// OwnerShutdown is a paid mutator transaction binding the contract method 0xcfa80707.
//
// Solidity: function ownerShutdown() returns()
func (_ArbRollup *ArbRollupTransactor) OwnerShutdown(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "ownerShutdown")
}

// OwnerShutdown is a paid mutator transaction binding the contract method 0xcfa80707.
//
// Solidity: function ownerShutdown() returns()
func (_ArbRollup *ArbRollupSession) OwnerShutdown() (*types.Transaction, error) {
	return _ArbRollup.Contract.OwnerShutdown(&_ArbRollup.TransactOpts)
}

// OwnerShutdown is a paid mutator transaction binding the contract method 0xcfa80707.
//
// Solidity: function ownerShutdown() returns()
func (_ArbRollup *ArbRollupTransactorSession) OwnerShutdown() (*types.Transaction, error) {
	return _ArbRollup.Contract.OwnerShutdown(&_ArbRollup.TransactOpts)
}

// PlaceStake is a paid mutator transaction binding the contract method 0xe0620d64.
//
// Solidity: function placeStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupTransactor) PlaceStake(opts *bind.TransactOpts, proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "placeStake", proof1, proof2)
}

// PlaceStake is a paid mutator transaction binding the contract method 0xe0620d64.
//
// Solidity: function placeStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupSession) PlaceStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.PlaceStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// PlaceStake is a paid mutator transaction binding the contract method 0xe0620d64.
//
// Solidity: function placeStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupTransactorSession) PlaceStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.PlaceStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_ArbRollup *ArbRollupTransactor) PruneLeaves(opts *bind.TransactOpts, fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "pruneLeaves", fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_ArbRollup *ArbRollupSession) PruneLeaves(fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.PruneLeaves(&_ArbRollup.TransactOpts, fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_ArbRollup *ArbRollupTransactorSession) PruneLeaves(fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.PruneLeaves(&_ArbRollup.TransactOpts, fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// RecoverStakeConfirmed is a paid mutator transaction binding the contract method 0x7cfaaf67.
//
// Solidity: function recoverStakeConfirmed(bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakeConfirmed(opts *bind.TransactOpts, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakeConfirmed", proof)
}

// RecoverStakeConfirmed is a paid mutator transaction binding the contract method 0x7cfaaf67.
//
// Solidity: function recoverStakeConfirmed(bytes32[] proof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakeConfirmed(proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeConfirmed(&_ArbRollup.TransactOpts, proof)
}

// RecoverStakeConfirmed is a paid mutator transaction binding the contract method 0x7cfaaf67.
//
// Solidity: function recoverStakeConfirmed(bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakeConfirmed(proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeConfirmed(&_ArbRollup.TransactOpts, proof)
}

// RecoverStakeMooted is a paid mutator transaction binding the contract method 0x33554032.
//
// Solidity: function recoverStakeMooted(address stakerAddress, bytes32 node, bytes32[] latestConfirmedProof, bytes32[] stakerProof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakeMooted(opts *bind.TransactOpts, stakerAddress common.Address, node [32]byte, latestConfirmedProof [][32]byte, stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakeMooted", stakerAddress, node, latestConfirmedProof, stakerProof)
}

// RecoverStakeMooted is a paid mutator transaction binding the contract method 0x33554032.
//
// Solidity: function recoverStakeMooted(address stakerAddress, bytes32 node, bytes32[] latestConfirmedProof, bytes32[] stakerProof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakeMooted(stakerAddress common.Address, node [32]byte, latestConfirmedProof [][32]byte, stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeMooted(&_ArbRollup.TransactOpts, stakerAddress, node, latestConfirmedProof, stakerProof)
}

// RecoverStakeMooted is a paid mutator transaction binding the contract method 0x33554032.
//
// Solidity: function recoverStakeMooted(address stakerAddress, bytes32 node, bytes32[] latestConfirmedProof, bytes32[] stakerProof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakeMooted(stakerAddress common.Address, node [32]byte, latestConfirmedProof [][32]byte, stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeMooted(&_ArbRollup.TransactOpts, stakerAddress, node, latestConfirmedProof, stakerProof)
}

// RecoverStakeOld is a paid mutator transaction binding the contract method 0x113ec9d8.
//
// Solidity: function recoverStakeOld(address stakerAddress, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakeOld(opts *bind.TransactOpts, stakerAddress common.Address, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakeOld", stakerAddress, proof)
}

// RecoverStakeOld is a paid mutator transaction binding the contract method 0x113ec9d8.
//
// Solidity: function recoverStakeOld(address stakerAddress, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakeOld(stakerAddress common.Address, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeOld(&_ArbRollup.TransactOpts, stakerAddress, proof)
}

// RecoverStakeOld is a paid mutator transaction binding the contract method 0x113ec9d8.
//
// Solidity: function recoverStakeOld(address stakerAddress, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakeOld(stakerAddress common.Address, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeOld(&_ArbRollup.TransactOpts, stakerAddress, proof)
}

// RecoverStakePassedDeadline is a paid mutator transaction binding the contract method 0xbadb3f14.
//
// Solidity: function recoverStakePassedDeadline(address stakerAddress, uint256 deadlineTicks, bytes32 disputableNodeHashVal, uint256 childType, bytes32 vmProtoStateHash, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakePassedDeadline(opts *bind.TransactOpts, stakerAddress common.Address, deadlineTicks *big.Int, disputableNodeHashVal [32]byte, childType *big.Int, vmProtoStateHash [32]byte, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakePassedDeadline", stakerAddress, deadlineTicks, disputableNodeHashVal, childType, vmProtoStateHash, proof)
}

// RecoverStakePassedDeadline is a paid mutator transaction binding the contract method 0xbadb3f14.
//
// Solidity: function recoverStakePassedDeadline(address stakerAddress, uint256 deadlineTicks, bytes32 disputableNodeHashVal, uint256 childType, bytes32 vmProtoStateHash, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakePassedDeadline(stakerAddress common.Address, deadlineTicks *big.Int, disputableNodeHashVal [32]byte, childType *big.Int, vmProtoStateHash [32]byte, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakePassedDeadline(&_ArbRollup.TransactOpts, stakerAddress, deadlineTicks, disputableNodeHashVal, childType, vmProtoStateHash, proof)
}

// RecoverStakePassedDeadline is a paid mutator transaction binding the contract method 0xbadb3f14.
//
// Solidity: function recoverStakePassedDeadline(address stakerAddress, uint256 deadlineTicks, bytes32 disputableNodeHashVal, uint256 childType, bytes32 vmProtoStateHash, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakePassedDeadline(stakerAddress common.Address, deadlineTicks *big.Int, disputableNodeHashVal [32]byte, childType *big.Int, vmProtoStateHash [32]byte, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakePassedDeadline(&_ArbRollup.TransactOpts, stakerAddress, deadlineTicks, disputableNodeHashVal, childType, vmProtoStateHash, proof)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_ArbRollup *ArbRollupTransactor) ResolveChallenge(opts *bind.TransactOpts, winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "resolveChallenge", winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_ArbRollup *ArbRollupSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ResolveChallenge(&_ArbRollup.TransactOpts, winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_ArbRollup *ArbRollupTransactorSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ResolveChallenge(&_ArbRollup.TransactOpts, winner, loser, arg2)
}

// SpawnCallProxy is a paid mutator transaction binding the contract method 0xf75e4866.
//
// Solidity: function spawnCallProxy(address _arbContract) returns()
func (_ArbRollup *ArbRollupTransactor) SpawnCallProxy(opts *bind.TransactOpts, _arbContract common.Address) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "spawnCallProxy", _arbContract)
}

// SpawnCallProxy is a paid mutator transaction binding the contract method 0xf75e4866.
//
// Solidity: function spawnCallProxy(address _arbContract) returns()
func (_ArbRollup *ArbRollupSession) SpawnCallProxy(_arbContract common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.SpawnCallProxy(&_ArbRollup.TransactOpts, _arbContract)
}

// SpawnCallProxy is a paid mutator transaction binding the contract method 0xf75e4866.
//
// Solidity: function spawnCallProxy(address _arbContract) returns()
func (_ArbRollup *ArbRollupTransactorSession) SpawnCallProxy(_arbContract common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.SpawnCallProxy(&_ArbRollup.TransactOpts, _arbContract)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_ArbRollup *ArbRollupTransactor) StartChallenge(opts *bind.TransactOpts, asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "startChallenge", asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_ArbRollup *ArbRollupSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.StartChallenge(&_ArbRollup.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_ArbRollup *ArbRollupTransactorSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.StartChallenge(&_ArbRollup.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// ArbRollupConfirmedAssertionIterator is returned from FilterConfirmedAssertion and is used to iterate over the raw logs and unpacked data for ConfirmedAssertion events raised by the ArbRollup contract.
type ArbRollupConfirmedAssertionIterator struct {
	Event *ArbRollupConfirmedAssertion // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupConfirmedAssertionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupConfirmedAssertion)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupConfirmedAssertion)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupConfirmedAssertionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupConfirmedAssertionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupConfirmedAssertion represents a ConfirmedAssertion event raised by the ArbRollup contract.
type ArbRollupConfirmedAssertion struct {
	LogsAccHash [][32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterConfirmedAssertion is a free log retrieval operation binding the contract event 0xded5fa103431438087188a5f8c6a4c3ea90996bbd63be7b1b3fa0a425b37fdd5.
//
// Solidity: event ConfirmedAssertion(bytes32[] logsAccHash)
func (_ArbRollup *ArbRollupFilterer) FilterConfirmedAssertion(opts *bind.FilterOpts) (*ArbRollupConfirmedAssertionIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "ConfirmedAssertion")
	if err != nil {
		return nil, err
	}
	return &ArbRollupConfirmedAssertionIterator{contract: _ArbRollup.contract, event: "ConfirmedAssertion", logs: logs, sub: sub}, nil
}

// WatchConfirmedAssertion is a free log subscription operation binding the contract event 0xded5fa103431438087188a5f8c6a4c3ea90996bbd63be7b1b3fa0a425b37fdd5.
//
// Solidity: event ConfirmedAssertion(bytes32[] logsAccHash)
func (_ArbRollup *ArbRollupFilterer) WatchConfirmedAssertion(opts *bind.WatchOpts, sink chan<- *ArbRollupConfirmedAssertion) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "ConfirmedAssertion")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupConfirmedAssertion)
				if err := _ArbRollup.contract.UnpackLog(event, "ConfirmedAssertion", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseConfirmedAssertion is a log parse operation binding the contract event 0xded5fa103431438087188a5f8c6a4c3ea90996bbd63be7b1b3fa0a425b37fdd5.
//
// Solidity: event ConfirmedAssertion(bytes32[] logsAccHash)
func (_ArbRollup *ArbRollupFilterer) ParseConfirmedAssertion(log types.Log) (*ArbRollupConfirmedAssertion, error) {
	event := new(ArbRollupConfirmedAssertion)
	if err := _ArbRollup.contract.UnpackLog(event, "ConfirmedAssertion", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupConfirmedValidAssertionIterator is returned from FilterConfirmedValidAssertion and is used to iterate over the raw logs and unpacked data for ConfirmedValidAssertion events raised by the ArbRollup contract.
type ArbRollupConfirmedValidAssertionIterator struct {
	Event *ArbRollupConfirmedValidAssertion // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupConfirmedValidAssertionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupConfirmedValidAssertion)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupConfirmedValidAssertion)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupConfirmedValidAssertionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupConfirmedValidAssertionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupConfirmedValidAssertion represents a ConfirmedValidAssertion event raised by the ArbRollup contract.
type ArbRollupConfirmedValidAssertion struct {
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterConfirmedValidAssertion is a free log retrieval operation binding the contract event 0x89cc5e236414c34f1206c0c14d8ac5b0e5444b669b309aaca16fe3d27749f50e.
//
// Solidity: event ConfirmedValidAssertion(bytes32 indexed nodeHash)
func (_ArbRollup *ArbRollupFilterer) FilterConfirmedValidAssertion(opts *bind.FilterOpts, nodeHash [][32]byte) (*ArbRollupConfirmedValidAssertionIterator, error) {

	var nodeHashRule []interface{}
	for _, nodeHashItem := range nodeHash {
		nodeHashRule = append(nodeHashRule, nodeHashItem)
	}

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "ConfirmedValidAssertion", nodeHashRule)
	if err != nil {
		return nil, err
	}
	return &ArbRollupConfirmedValidAssertionIterator{contract: _ArbRollup.contract, event: "ConfirmedValidAssertion", logs: logs, sub: sub}, nil
}

// WatchConfirmedValidAssertion is a free log subscription operation binding the contract event 0x89cc5e236414c34f1206c0c14d8ac5b0e5444b669b309aaca16fe3d27749f50e.
//
// Solidity: event ConfirmedValidAssertion(bytes32 indexed nodeHash)
func (_ArbRollup *ArbRollupFilterer) WatchConfirmedValidAssertion(opts *bind.WatchOpts, sink chan<- *ArbRollupConfirmedValidAssertion, nodeHash [][32]byte) (event.Subscription, error) {

	var nodeHashRule []interface{}
	for _, nodeHashItem := range nodeHash {
		nodeHashRule = append(nodeHashRule, nodeHashItem)
	}

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "ConfirmedValidAssertion", nodeHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupConfirmedValidAssertion)
				if err := _ArbRollup.contract.UnpackLog(event, "ConfirmedValidAssertion", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseConfirmedValidAssertion is a log parse operation binding the contract event 0x89cc5e236414c34f1206c0c14d8ac5b0e5444b669b309aaca16fe3d27749f50e.
//
// Solidity: event ConfirmedValidAssertion(bytes32 indexed nodeHash)
func (_ArbRollup *ArbRollupFilterer) ParseConfirmedValidAssertion(log types.Log) (*ArbRollupConfirmedValidAssertion, error) {
	event := new(ArbRollupConfirmedValidAssertion)
	if err := _ArbRollup.contract.UnpackLog(event, "ConfirmedValidAssertion", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupAssertedIterator is returned from FilterRollupAsserted and is used to iterate over the raw logs and unpacked data for RollupAsserted events raised by the ArbRollup contract.
type ArbRollupRollupAssertedIterator struct {
	Event *ArbRollupRollupAsserted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupAssertedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupAsserted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupAsserted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupAssertedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupAssertedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupAsserted represents a RollupAsserted event raised by the ArbRollup contract.
type ArbRollupRollupAsserted struct {
	Fields               [8][32]byte
	InboxCount           *big.Int
	ImportedMessageCount *big.Int
	TimeBounds           [4]*big.Int
	NumArbGas            uint64
	NumSteps             uint64
	DidInboxInsn         bool
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterRollupAsserted is a free log retrieval operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_ArbRollup *ArbRollupFilterer) FilterRollupAsserted(opts *bind.FilterOpts) (*ArbRollupRollupAssertedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupAssertedIterator{contract: _ArbRollup.contract, event: "RollupAsserted", logs: logs, sub: sub}, nil
}

// WatchRollupAsserted is a free log subscription operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_ArbRollup *ArbRollupFilterer) WatchRollupAsserted(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupAsserted) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupAsserted)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupAsserted is a log parse operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_ArbRollup *ArbRollupFilterer) ParseRollupAsserted(log types.Log) (*ArbRollupRollupAsserted, error) {
	event := new(ArbRollupRollupAsserted)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupChallengeCompletedIterator is returned from FilterRollupChallengeCompleted and is used to iterate over the raw logs and unpacked data for RollupChallengeCompleted events raised by the ArbRollup contract.
type ArbRollupRollupChallengeCompletedIterator struct {
	Event *ArbRollupRollupChallengeCompleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupChallengeCompletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupChallengeCompleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupChallengeCompleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupChallengeCompletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupChallengeCompletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupChallengeCompleted represents a RollupChallengeCompleted event raised by the ArbRollup contract.
type ArbRollupRollupChallengeCompleted struct {
	ChallengeContract common.Address
	Winner            common.Address
	Loser             common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeCompleted is a free log retrieval operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_ArbRollup *ArbRollupFilterer) FilterRollupChallengeCompleted(opts *bind.FilterOpts) (*ArbRollupRollupChallengeCompletedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupChallengeCompletedIterator{contract: _ArbRollup.contract, event: "RollupChallengeCompleted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeCompleted is a free log subscription operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_ArbRollup *ArbRollupFilterer) WatchRollupChallengeCompleted(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupChallengeCompleted) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupChallengeCompleted)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeCompleted is a log parse operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_ArbRollup *ArbRollupFilterer) ParseRollupChallengeCompleted(log types.Log) (*ArbRollupRollupChallengeCompleted, error) {
	event := new(ArbRollupRollupChallengeCompleted)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupChallengeStartedIterator is returned from FilterRollupChallengeStarted and is used to iterate over the raw logs and unpacked data for RollupChallengeStarted events raised by the ArbRollup contract.
type ArbRollupRollupChallengeStartedIterator struct {
	Event *ArbRollupRollupChallengeStarted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupChallengeStartedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupChallengeStarted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupChallengeStarted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupChallengeStartedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupChallengeStartedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupChallengeStarted represents a RollupChallengeStarted event raised by the ArbRollup contract.
type ArbRollupRollupChallengeStarted struct {
	Asserter          common.Address
	Challenger        common.Address
	ChallengeType     *big.Int
	ChallengeContract common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeStarted is a free log retrieval operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_ArbRollup *ArbRollupFilterer) FilterRollupChallengeStarted(opts *bind.FilterOpts) (*ArbRollupRollupChallengeStartedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupChallengeStartedIterator{contract: _ArbRollup.contract, event: "RollupChallengeStarted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeStarted is a free log subscription operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_ArbRollup *ArbRollupFilterer) WatchRollupChallengeStarted(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupChallengeStarted) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupChallengeStarted)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeStarted is a log parse operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_ArbRollup *ArbRollupFilterer) ParseRollupChallengeStarted(log types.Log) (*ArbRollupRollupChallengeStarted, error) {
	event := new(ArbRollupRollupChallengeStarted)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupConfirmedIterator is returned from FilterRollupConfirmed and is used to iterate over the raw logs and unpacked data for RollupConfirmed events raised by the ArbRollup contract.
type ArbRollupRollupConfirmedIterator struct {
	Event *ArbRollupRollupConfirmed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupConfirmedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupConfirmed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupConfirmed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupConfirmedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupConfirmedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupConfirmed represents a RollupConfirmed event raised by the ArbRollup contract.
type ArbRollupRollupConfirmed struct {
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupConfirmed is a free log retrieval operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupConfirmed(opts *bind.FilterOpts) (*ArbRollupRollupConfirmedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupConfirmedIterator{contract: _ArbRollup.contract, event: "RollupConfirmed", logs: logs, sub: sub}, nil
}

// WatchRollupConfirmed is a free log subscription operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupConfirmed(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupConfirmed) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupConfirmed)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupConfirmed is a log parse operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupConfirmed(log types.Log) (*ArbRollupRollupConfirmed, error) {
	event := new(ArbRollupRollupConfirmed)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupCreatedIterator is returned from FilterRollupCreated and is used to iterate over the raw logs and unpacked data for RollupCreated events raised by the ArbRollup contract.
type ArbRollupRollupCreatedIterator struct {
	Event *ArbRollupRollupCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupCreated represents a RollupCreated event raised by the ArbRollup contract.
type ArbRollupRollupCreated struct {
	InitVMHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupCreated is a free log retrieval operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupCreated(opts *bind.FilterOpts) (*ArbRollupRollupCreatedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupCreatedIterator{contract: _ArbRollup.contract, event: "RollupCreated", logs: logs, sub: sub}, nil
}

// WatchRollupCreated is a free log subscription operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupCreated(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupCreated) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupCreated)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupCreated is a log parse operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupCreated(log types.Log) (*ArbRollupRollupCreated, error) {
	event := new(ArbRollupRollupCreated)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupPrunedIterator is returned from FilterRollupPruned and is used to iterate over the raw logs and unpacked data for RollupPruned events raised by the ArbRollup contract.
type ArbRollupRollupPrunedIterator struct {
	Event *ArbRollupRollupPruned // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupPrunedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupPruned)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupPruned)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupPrunedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupPrunedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupPruned represents a RollupPruned event raised by the ArbRollup contract.
type ArbRollupRollupPruned struct {
	Leaf [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRollupPruned is a free log retrieval operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_ArbRollup *ArbRollupFilterer) FilterRollupPruned(opts *bind.FilterOpts) (*ArbRollupRollupPrunedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupPrunedIterator{contract: _ArbRollup.contract, event: "RollupPruned", logs: logs, sub: sub}, nil
}

// WatchRollupPruned is a free log subscription operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_ArbRollup *ArbRollupFilterer) WatchRollupPruned(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupPruned) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupPruned)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupPruned", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupPruned is a log parse operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_ArbRollup *ArbRollupFilterer) ParseRollupPruned(log types.Log) (*ArbRollupRollupPruned, error) {
	event := new(ArbRollupRollupPruned)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupPruned", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupStakeCreatedIterator is returned from FilterRollupStakeCreated and is used to iterate over the raw logs and unpacked data for RollupStakeCreated events raised by the ArbRollup contract.
type ArbRollupRollupStakeCreatedIterator struct {
	Event *ArbRollupRollupStakeCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupStakeCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupStakeCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupStakeCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupStakeCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupStakeCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupStakeCreated represents a RollupStakeCreated event raised by the ArbRollup contract.
type ArbRollupRollupStakeCreated struct {
	Staker   common.Address
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeCreated is a free log retrieval operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupStakeCreated(opts *bind.FilterOpts) (*ArbRollupRollupStakeCreatedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupStakeCreatedIterator{contract: _ArbRollup.contract, event: "RollupStakeCreated", logs: logs, sub: sub}, nil
}

// WatchRollupStakeCreated is a free log subscription operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupStakeCreated(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupStakeCreated) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupStakeCreated)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeCreated is a log parse operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupStakeCreated(log types.Log) (*ArbRollupRollupStakeCreated, error) {
	event := new(ArbRollupRollupStakeCreated)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupStakeMovedIterator is returned from FilterRollupStakeMoved and is used to iterate over the raw logs and unpacked data for RollupStakeMoved events raised by the ArbRollup contract.
type ArbRollupRollupStakeMovedIterator struct {
	Event *ArbRollupRollupStakeMoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupStakeMovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupStakeMoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupStakeMoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupStakeMovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupStakeMovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupStakeMoved represents a RollupStakeMoved event raised by the ArbRollup contract.
type ArbRollupRollupStakeMoved struct {
	Staker     common.Address
	ToNodeHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeMoved is a free log retrieval operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupStakeMoved(opts *bind.FilterOpts) (*ArbRollupRollupStakeMovedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupStakeMovedIterator{contract: _ArbRollup.contract, event: "RollupStakeMoved", logs: logs, sub: sub}, nil
}

// WatchRollupStakeMoved is a free log subscription operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupStakeMoved(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupStakeMoved) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupStakeMoved)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeMoved is a log parse operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupStakeMoved(log types.Log) (*ArbRollupRollupStakeMoved, error) {
	event := new(ArbRollupRollupStakeMoved)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupStakeRefundedIterator is returned from FilterRollupStakeRefunded and is used to iterate over the raw logs and unpacked data for RollupStakeRefunded events raised by the ArbRollup contract.
type ArbRollupRollupStakeRefundedIterator struct {
	Event *ArbRollupRollupStakeRefunded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupStakeRefundedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupStakeRefunded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupStakeRefunded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupStakeRefundedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupStakeRefundedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupStakeRefunded represents a RollupStakeRefunded event raised by the ArbRollup contract.
type ArbRollupRollupStakeRefunded struct {
	Staker common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeRefunded is a free log retrieval operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_ArbRollup *ArbRollupFilterer) FilterRollupStakeRefunded(opts *bind.FilterOpts) (*ArbRollupRollupStakeRefundedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupStakeRefundedIterator{contract: _ArbRollup.contract, event: "RollupStakeRefunded", logs: logs, sub: sub}, nil
}

// WatchRollupStakeRefunded is a free log subscription operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_ArbRollup *ArbRollupFilterer) WatchRollupStakeRefunded(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupStakeRefunded) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupStakeRefunded)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeRefunded is a log parse operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_ArbRollup *ArbRollupFilterer) ParseRollupStakeRefunded(log types.Log) (*ArbRollupRollupStakeRefunded, error) {
	event := new(ArbRollupRollupStakeRefunded)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbVMContractProxyABI is the input ABI used to generate the binding from.
const ArbVMContractProxyABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_arbChain\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]"

// ArbVMContractProxyBin is the compiled bytecode used for deploying new contracts.
var ArbVMContractProxyBin = "0x608060405234801561001057600080fd5b5060405161012c38038061012c8339818101604052602081101561003357600080fd5b5051600080546001600160a01b039092166001600160a01b031990921691909117905560c8806100646000396000f3fe608060408181526000805463c581831760e01b90935233608481815260a49384523660c48190526001600160a01b039095169463c5818317943494929060e4848480828437600081840152601f19601f8201169050808301925050509450505050506000604051808303818588803b158015607957600080fd5b505af1158015608c573d6000803e3d6000fd5b505050505000fea265627a7a7231582095499efdd805ef927947826882e0ad2d797acbe02559cbc2422e593af041b0ae64736f6c634300050f0032"

// DeployArbVMContractProxy deploys a new Ethereum contract, binding an instance of ArbVMContractProxy to it.
func DeployArbVMContractProxy(auth *bind.TransactOpts, backend bind.ContractBackend, _arbChain common.Address) (common.Address, *types.Transaction, *ArbVMContractProxy, error) {
	parsed, err := abi.JSON(strings.NewReader(ArbVMContractProxyABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ArbVMContractProxyBin), backend, _arbChain)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ArbVMContractProxy{ArbVMContractProxyCaller: ArbVMContractProxyCaller{contract: contract}, ArbVMContractProxyTransactor: ArbVMContractProxyTransactor{contract: contract}, ArbVMContractProxyFilterer: ArbVMContractProxyFilterer{contract: contract}}, nil
}

// ArbVMContractProxy is an auto generated Go binding around an Ethereum contract.
type ArbVMContractProxy struct {
	ArbVMContractProxyCaller     // Read-only binding to the contract
	ArbVMContractProxyTransactor // Write-only binding to the contract
	ArbVMContractProxyFilterer   // Log filterer for contract events
}

// ArbVMContractProxyCaller is an auto generated read-only Go binding around an Ethereum contract.
type ArbVMContractProxyCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbVMContractProxyTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ArbVMContractProxyTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbVMContractProxyFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ArbVMContractProxyFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbVMContractProxySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ArbVMContractProxySession struct {
	Contract     *ArbVMContractProxy // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ArbVMContractProxyCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ArbVMContractProxyCallerSession struct {
	Contract *ArbVMContractProxyCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// ArbVMContractProxyTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ArbVMContractProxyTransactorSession struct {
	Contract     *ArbVMContractProxyTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// ArbVMContractProxyRaw is an auto generated low-level Go binding around an Ethereum contract.
type ArbVMContractProxyRaw struct {
	Contract *ArbVMContractProxy // Generic contract binding to access the raw methods on
}

// ArbVMContractProxyCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ArbVMContractProxyCallerRaw struct {
	Contract *ArbVMContractProxyCaller // Generic read-only contract binding to access the raw methods on
}

// ArbVMContractProxyTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ArbVMContractProxyTransactorRaw struct {
	Contract *ArbVMContractProxyTransactor // Generic write-only contract binding to access the raw methods on
}

// NewArbVMContractProxy creates a new instance of ArbVMContractProxy, bound to a specific deployed contract.
func NewArbVMContractProxy(address common.Address, backend bind.ContractBackend) (*ArbVMContractProxy, error) {
	contract, err := bindArbVMContractProxy(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ArbVMContractProxy{ArbVMContractProxyCaller: ArbVMContractProxyCaller{contract: contract}, ArbVMContractProxyTransactor: ArbVMContractProxyTransactor{contract: contract}, ArbVMContractProxyFilterer: ArbVMContractProxyFilterer{contract: contract}}, nil
}

// NewArbVMContractProxyCaller creates a new read-only instance of ArbVMContractProxy, bound to a specific deployed contract.
func NewArbVMContractProxyCaller(address common.Address, caller bind.ContractCaller) (*ArbVMContractProxyCaller, error) {
	contract, err := bindArbVMContractProxy(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ArbVMContractProxyCaller{contract: contract}, nil
}

// NewArbVMContractProxyTransactor creates a new write-only instance of ArbVMContractProxy, bound to a specific deployed contract.
func NewArbVMContractProxyTransactor(address common.Address, transactor bind.ContractTransactor) (*ArbVMContractProxyTransactor, error) {
	contract, err := bindArbVMContractProxy(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ArbVMContractProxyTransactor{contract: contract}, nil
}

// NewArbVMContractProxyFilterer creates a new log filterer instance of ArbVMContractProxy, bound to a specific deployed contract.
func NewArbVMContractProxyFilterer(address common.Address, filterer bind.ContractFilterer) (*ArbVMContractProxyFilterer, error) {
	contract, err := bindArbVMContractProxy(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ArbVMContractProxyFilterer{contract: contract}, nil
}

// bindArbVMContractProxy binds a generic wrapper to an already deployed contract.
func bindArbVMContractProxy(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ArbVMContractProxyABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ArbVMContractProxy *ArbVMContractProxyRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ArbVMContractProxy.Contract.ArbVMContractProxyCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ArbVMContractProxy *ArbVMContractProxyRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbVMContractProxy.Contract.ArbVMContractProxyTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ArbVMContractProxy *ArbVMContractProxyRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ArbVMContractProxy.Contract.ArbVMContractProxyTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ArbVMContractProxy *ArbVMContractProxyCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ArbVMContractProxy.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ArbVMContractProxy *ArbVMContractProxyTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbVMContractProxy.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ArbVMContractProxy *ArbVMContractProxyTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ArbVMContractProxy.Contract.contract.Transact(opts, method, params...)
}

// BytesLibABI is the input ABI used to generate the binding from.
const BytesLibABI = "[]"

// BytesLibBin is the compiled bytecode used for deploying new contracts.
var BytesLibBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a723158204a4406891b86a3dacfb6ea735b92a605972908aec5c506cc187bb6f01ef6a24064736f6c634300050f0032"

// DeployBytesLib deploys a new Ethereum contract, binding an instance of BytesLib to it.
func DeployBytesLib(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BytesLib, error) {
	parsed, err := abi.JSON(strings.NewReader(BytesLibABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(BytesLibBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BytesLib{BytesLibCaller: BytesLibCaller{contract: contract}, BytesLibTransactor: BytesLibTransactor{contract: contract}, BytesLibFilterer: BytesLibFilterer{contract: contract}}, nil
}

// BytesLib is an auto generated Go binding around an Ethereum contract.
type BytesLib struct {
	BytesLibCaller     // Read-only binding to the contract
	BytesLibTransactor // Write-only binding to the contract
	BytesLibFilterer   // Log filterer for contract events
}

// BytesLibCaller is an auto generated read-only Go binding around an Ethereum contract.
type BytesLibCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BytesLibTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BytesLibTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BytesLibFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BytesLibFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BytesLibSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BytesLibSession struct {
	Contract     *BytesLib         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BytesLibCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BytesLibCallerSession struct {
	Contract *BytesLibCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// BytesLibTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BytesLibTransactorSession struct {
	Contract     *BytesLibTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// BytesLibRaw is an auto generated low-level Go binding around an Ethereum contract.
type BytesLibRaw struct {
	Contract *BytesLib // Generic contract binding to access the raw methods on
}

// BytesLibCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BytesLibCallerRaw struct {
	Contract *BytesLibCaller // Generic read-only contract binding to access the raw methods on
}

// BytesLibTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BytesLibTransactorRaw struct {
	Contract *BytesLibTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBytesLib creates a new instance of BytesLib, bound to a specific deployed contract.
func NewBytesLib(address common.Address, backend bind.ContractBackend) (*BytesLib, error) {
	contract, err := bindBytesLib(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BytesLib{BytesLibCaller: BytesLibCaller{contract: contract}, BytesLibTransactor: BytesLibTransactor{contract: contract}, BytesLibFilterer: BytesLibFilterer{contract: contract}}, nil
}

// NewBytesLibCaller creates a new read-only instance of BytesLib, bound to a specific deployed contract.
func NewBytesLibCaller(address common.Address, caller bind.ContractCaller) (*BytesLibCaller, error) {
	contract, err := bindBytesLib(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BytesLibCaller{contract: contract}, nil
}

// NewBytesLibTransactor creates a new write-only instance of BytesLib, bound to a specific deployed contract.
func NewBytesLibTransactor(address common.Address, transactor bind.ContractTransactor) (*BytesLibTransactor, error) {
	contract, err := bindBytesLib(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BytesLibTransactor{contract: contract}, nil
}

// NewBytesLibFilterer creates a new log filterer instance of BytesLib, bound to a specific deployed contract.
func NewBytesLibFilterer(address common.Address, filterer bind.ContractFilterer) (*BytesLibFilterer, error) {
	contract, err := bindBytesLib(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BytesLibFilterer{contract: contract}, nil
}

// bindBytesLib binds a generic wrapper to an already deployed contract.
func bindBytesLib(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BytesLibABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BytesLib *BytesLibRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BytesLib.Contract.BytesLibCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BytesLib *BytesLibRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BytesLib.Contract.BytesLibTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BytesLib *BytesLibRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BytesLib.Contract.BytesLibTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BytesLib *BytesLibCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BytesLib.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BytesLib *BytesLibTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BytesLib.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BytesLib *BytesLibTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BytesLib.Contract.contract.Transact(opts, method, params...)
}

// ChallengeUtilsABI is the input ABI used to generate the binding from.
const ChallengeUtilsABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"INVALID_EXECUTION_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVALID_INBOX_TOP_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVALID_MESSAGES_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VALID_CHILD_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ChallengeUtilsFuncSigs maps the 4-byte function signature to its string representation.
var ChallengeUtilsFuncSigs = map[string]string{
	"95312727": "INVALID_EXECUTION_TYPE()",
	"a697bcac": "INVALID_INBOX_TOP_TYPE()",
	"d7519b46": "INVALID_MESSAGES_TYPE()",
	"2e179be5": "VALID_CHILD_TYPE()",
}

// ChallengeUtilsBin is the compiled bytecode used for deploying new contracts.
var ChallengeUtilsBin = "0x60c9610025600b82828239805160001a60731461001857fe5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361060515760003560e01c80632e179be51460565780639531272714606e578063a697bcac146074578063d7519b4614607a575b600080fd5b605c6080565b60408051918252519081900360200190f35b605c6085565b605c608a565b605c608f565b600381565b600281565b600081565b60018156fea265627a7a72315820700623dcb300d07a89dd66c2f312e517c83be08b285278c67140cfaaad930fb064736f6c634300050f0032"

// DeployChallengeUtils deploys a new Ethereum contract, binding an instance of ChallengeUtils to it.
func DeployChallengeUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ChallengeUtils, error) {
	parsed, err := abi.JSON(strings.NewReader(ChallengeUtilsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ChallengeUtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ChallengeUtils{ChallengeUtilsCaller: ChallengeUtilsCaller{contract: contract}, ChallengeUtilsTransactor: ChallengeUtilsTransactor{contract: contract}, ChallengeUtilsFilterer: ChallengeUtilsFilterer{contract: contract}}, nil
}

// ChallengeUtils is an auto generated Go binding around an Ethereum contract.
type ChallengeUtils struct {
	ChallengeUtilsCaller     // Read-only binding to the contract
	ChallengeUtilsTransactor // Write-only binding to the contract
	ChallengeUtilsFilterer   // Log filterer for contract events
}

// ChallengeUtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type ChallengeUtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeUtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ChallengeUtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeUtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ChallengeUtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeUtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ChallengeUtilsSession struct {
	Contract     *ChallengeUtils   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ChallengeUtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ChallengeUtilsCallerSession struct {
	Contract *ChallengeUtilsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// ChallengeUtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ChallengeUtilsTransactorSession struct {
	Contract     *ChallengeUtilsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// ChallengeUtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type ChallengeUtilsRaw struct {
	Contract *ChallengeUtils // Generic contract binding to access the raw methods on
}

// ChallengeUtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ChallengeUtilsCallerRaw struct {
	Contract *ChallengeUtilsCaller // Generic read-only contract binding to access the raw methods on
}

// ChallengeUtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ChallengeUtilsTransactorRaw struct {
	Contract *ChallengeUtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewChallengeUtils creates a new instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtils(address common.Address, backend bind.ContractBackend) (*ChallengeUtils, error) {
	contract, err := bindChallengeUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtils{ChallengeUtilsCaller: ChallengeUtilsCaller{contract: contract}, ChallengeUtilsTransactor: ChallengeUtilsTransactor{contract: contract}, ChallengeUtilsFilterer: ChallengeUtilsFilterer{contract: contract}}, nil
}

// NewChallengeUtilsCaller creates a new read-only instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtilsCaller(address common.Address, caller bind.ContractCaller) (*ChallengeUtilsCaller, error) {
	contract, err := bindChallengeUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtilsCaller{contract: contract}, nil
}

// NewChallengeUtilsTransactor creates a new write-only instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*ChallengeUtilsTransactor, error) {
	contract, err := bindChallengeUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtilsTransactor{contract: contract}, nil
}

// NewChallengeUtilsFilterer creates a new log filterer instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*ChallengeUtilsFilterer, error) {
	contract, err := bindChallengeUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtilsFilterer{contract: contract}, nil
}

// bindChallengeUtils binds a generic wrapper to an already deployed contract.
func bindChallengeUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ChallengeUtilsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ChallengeUtils *ChallengeUtilsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ChallengeUtils.Contract.ChallengeUtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ChallengeUtils *ChallengeUtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.ChallengeUtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ChallengeUtils *ChallengeUtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.ChallengeUtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ChallengeUtils *ChallengeUtilsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ChallengeUtils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ChallengeUtils *ChallengeUtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ChallengeUtils *ChallengeUtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.contract.Transact(opts, method, params...)
}

// INVALIDEXECUTIONTYPE is a free data retrieval call binding the contract method 0x95312727.
//
// Solidity: function INVALID_EXECUTION_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCaller) INVALIDEXECUTIONTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ChallengeUtils.contract.Call(opts, out, "INVALID_EXECUTION_TYPE")
	return *ret0, err
}

// INVALIDEXECUTIONTYPE is a free data retrieval call binding the contract method 0x95312727.
//
// Solidity: function INVALID_EXECUTION_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsSession) INVALIDEXECUTIONTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDEXECUTIONTYPE(&_ChallengeUtils.CallOpts)
}

// INVALIDEXECUTIONTYPE is a free data retrieval call binding the contract method 0x95312727.
//
// Solidity: function INVALID_EXECUTION_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCallerSession) INVALIDEXECUTIONTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDEXECUTIONTYPE(&_ChallengeUtils.CallOpts)
}

// INVALIDINBOXTOPTYPE is a free data retrieval call binding the contract method 0xa697bcac.
//
// Solidity: function INVALID_INBOX_TOP_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCaller) INVALIDINBOXTOPTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ChallengeUtils.contract.Call(opts, out, "INVALID_INBOX_TOP_TYPE")
	return *ret0, err
}

// INVALIDINBOXTOPTYPE is a free data retrieval call binding the contract method 0xa697bcac.
//
// Solidity: function INVALID_INBOX_TOP_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsSession) INVALIDINBOXTOPTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDINBOXTOPTYPE(&_ChallengeUtils.CallOpts)
}

// INVALIDINBOXTOPTYPE is a free data retrieval call binding the contract method 0xa697bcac.
//
// Solidity: function INVALID_INBOX_TOP_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCallerSession) INVALIDINBOXTOPTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDINBOXTOPTYPE(&_ChallengeUtils.CallOpts)
}

// INVALIDMESSAGESTYPE is a free data retrieval call binding the contract method 0xd7519b46.
//
// Solidity: function INVALID_MESSAGES_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCaller) INVALIDMESSAGESTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ChallengeUtils.contract.Call(opts, out, "INVALID_MESSAGES_TYPE")
	return *ret0, err
}

// INVALIDMESSAGESTYPE is a free data retrieval call binding the contract method 0xd7519b46.
//
// Solidity: function INVALID_MESSAGES_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsSession) INVALIDMESSAGESTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDMESSAGESTYPE(&_ChallengeUtils.CallOpts)
}

// INVALIDMESSAGESTYPE is a free data retrieval call binding the contract method 0xd7519b46.
//
// Solidity: function INVALID_MESSAGES_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCallerSession) INVALIDMESSAGESTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.INVALIDMESSAGESTYPE(&_ChallengeUtils.CallOpts)
}

// VALIDCHILDTYPE is a free data retrieval call binding the contract method 0x2e179be5.
//
// Solidity: function VALID_CHILD_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCaller) VALIDCHILDTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ChallengeUtils.contract.Call(opts, out, "VALID_CHILD_TYPE")
	return *ret0, err
}

// VALIDCHILDTYPE is a free data retrieval call binding the contract method 0x2e179be5.
//
// Solidity: function VALID_CHILD_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsSession) VALIDCHILDTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.VALIDCHILDTYPE(&_ChallengeUtils.CallOpts)
}

// VALIDCHILDTYPE is a free data retrieval call binding the contract method 0x2e179be5.
//
// Solidity: function VALID_CHILD_TYPE() constant returns(uint256)
func (_ChallengeUtils *ChallengeUtilsCallerSession) VALIDCHILDTYPE() (*big.Int, error) {
	return _ChallengeUtils.Contract.VALIDCHILDTYPE(&_ChallengeUtils.CallOpts)
}

// IArbRollupABI is the input ABI used to generate the binding from.
const IArbRollupABI = "[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"forwardContractMessage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_vmState\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"_gracePeriodTicks\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_arbGasSpeedLimitPerTick\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"_maxExecutionSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint64[2]\",\"name\":\"_maxTimeBoundsWidth\",\"type\":\"uint64[2]\"},{\"internalType\":\"uint128\",\"name\":\"_stakeRequirement\",\"type\":\"uint128\"},{\"internalType\":\"addresspayable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_challengeFactoryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_globalInboxAddress\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IArbRollupFuncSigs maps the 4-byte function signature to its string representation.
var IArbRollupFuncSigs = map[string]string{
	"c5818317": "forwardContractMessage(address,bytes)",
	"8e0f7167": "init(bytes32,uint128,uint128,uint64,uint64[2],uint128,address,address,address)",
}

// IArbRollup is an auto generated Go binding around an Ethereum contract.
type IArbRollup struct {
	IArbRollupCaller     // Read-only binding to the contract
	IArbRollupTransactor // Write-only binding to the contract
	IArbRollupFilterer   // Log filterer for contract events
}

// IArbRollupCaller is an auto generated read-only Go binding around an Ethereum contract.
type IArbRollupCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IArbRollupTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IArbRollupTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IArbRollupFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IArbRollupFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IArbRollupSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IArbRollupSession struct {
	Contract     *IArbRollup       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IArbRollupCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IArbRollupCallerSession struct {
	Contract *IArbRollupCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// IArbRollupTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IArbRollupTransactorSession struct {
	Contract     *IArbRollupTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IArbRollupRaw is an auto generated low-level Go binding around an Ethereum contract.
type IArbRollupRaw struct {
	Contract *IArbRollup // Generic contract binding to access the raw methods on
}

// IArbRollupCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IArbRollupCallerRaw struct {
	Contract *IArbRollupCaller // Generic read-only contract binding to access the raw methods on
}

// IArbRollupTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IArbRollupTransactorRaw struct {
	Contract *IArbRollupTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIArbRollup creates a new instance of IArbRollup, bound to a specific deployed contract.
func NewIArbRollup(address common.Address, backend bind.ContractBackend) (*IArbRollup, error) {
	contract, err := bindIArbRollup(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IArbRollup{IArbRollupCaller: IArbRollupCaller{contract: contract}, IArbRollupTransactor: IArbRollupTransactor{contract: contract}, IArbRollupFilterer: IArbRollupFilterer{contract: contract}}, nil
}

// NewIArbRollupCaller creates a new read-only instance of IArbRollup, bound to a specific deployed contract.
func NewIArbRollupCaller(address common.Address, caller bind.ContractCaller) (*IArbRollupCaller, error) {
	contract, err := bindIArbRollup(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IArbRollupCaller{contract: contract}, nil
}

// NewIArbRollupTransactor creates a new write-only instance of IArbRollup, bound to a specific deployed contract.
func NewIArbRollupTransactor(address common.Address, transactor bind.ContractTransactor) (*IArbRollupTransactor, error) {
	contract, err := bindIArbRollup(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IArbRollupTransactor{contract: contract}, nil
}

// NewIArbRollupFilterer creates a new log filterer instance of IArbRollup, bound to a specific deployed contract.
func NewIArbRollupFilterer(address common.Address, filterer bind.ContractFilterer) (*IArbRollupFilterer, error) {
	contract, err := bindIArbRollup(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IArbRollupFilterer{contract: contract}, nil
}

// bindIArbRollup binds a generic wrapper to an already deployed contract.
func bindIArbRollup(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IArbRollupABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IArbRollup *IArbRollupRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IArbRollup.Contract.IArbRollupCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IArbRollup *IArbRollupRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IArbRollup.Contract.IArbRollupTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IArbRollup *IArbRollupRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IArbRollup.Contract.IArbRollupTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IArbRollup *IArbRollupCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IArbRollup.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IArbRollup *IArbRollupTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IArbRollup.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IArbRollup *IArbRollupTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IArbRollup.Contract.contract.Transact(opts, method, params...)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) returns()
func (_IArbRollup *IArbRollupTransactor) ForwardContractMessage(opts *bind.TransactOpts, _sender common.Address, _data []byte) (*types.Transaction, error) {
	return _IArbRollup.contract.Transact(opts, "forwardContractMessage", _sender, _data)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) returns()
func (_IArbRollup *IArbRollupSession) ForwardContractMessage(_sender common.Address, _data []byte) (*types.Transaction, error) {
	return _IArbRollup.Contract.ForwardContractMessage(&_IArbRollup.TransactOpts, _sender, _data)
}

// ForwardContractMessage is a paid mutator transaction binding the contract method 0xc5818317.
//
// Solidity: function forwardContractMessage(address _sender, bytes _data) returns()
func (_IArbRollup *IArbRollupTransactorSession) ForwardContractMessage(_sender common.Address, _data []byte) (*types.Transaction, error) {
	return _IArbRollup.Contract.ForwardContractMessage(&_IArbRollup.TransactOpts, _sender, _data)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_IArbRollup *IArbRollupTransactor) Init(opts *bind.TransactOpts, _vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _IArbRollup.contract.Transact(opts, "init", _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_IArbRollup *IArbRollupSession) Init(_vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _IArbRollup.Contract.Init(&_IArbRollup.TransactOpts, _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// Init is a paid mutator transaction binding the contract method 0x8e0f7167.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint64[2] _maxTimeBoundsWidth, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_IArbRollup *IArbRollupTransactorSession) Init(_vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _maxTimeBoundsWidth [2]uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _IArbRollup.Contract.Init(&_IArbRollup.TransactOpts, _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _maxTimeBoundsWidth, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// IChallengeFactoryABI is the input ABI used to generate the binding from.
const IChallengeFactoryABI = "[{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"_asserter\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"_challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_challengePeriodTicks\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_challengeHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"}],\"name\":\"createChallenge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asserter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"}],\"name\":\"generateCloneAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// IChallengeFactoryFuncSigs maps the 4-byte function signature to its string representation.
var IChallengeFactoryFuncSigs = map[string]string{
	"865da1c2": "createChallenge(address,address,uint256,bytes32,uint256)",
	"729406c8": "generateCloneAddress(address,address,uint256)",
}

// IChallengeFactory is an auto generated Go binding around an Ethereum contract.
type IChallengeFactory struct {
	IChallengeFactoryCaller     // Read-only binding to the contract
	IChallengeFactoryTransactor // Write-only binding to the contract
	IChallengeFactoryFilterer   // Log filterer for contract events
}

// IChallengeFactoryCaller is an auto generated read-only Go binding around an Ethereum contract.
type IChallengeFactoryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IChallengeFactoryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IChallengeFactoryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IChallengeFactoryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IChallengeFactoryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IChallengeFactorySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IChallengeFactorySession struct {
	Contract     *IChallengeFactory // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IChallengeFactoryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IChallengeFactoryCallerSession struct {
	Contract *IChallengeFactoryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// IChallengeFactoryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IChallengeFactoryTransactorSession struct {
	Contract     *IChallengeFactoryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// IChallengeFactoryRaw is an auto generated low-level Go binding around an Ethereum contract.
type IChallengeFactoryRaw struct {
	Contract *IChallengeFactory // Generic contract binding to access the raw methods on
}

// IChallengeFactoryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IChallengeFactoryCallerRaw struct {
	Contract *IChallengeFactoryCaller // Generic read-only contract binding to access the raw methods on
}

// IChallengeFactoryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IChallengeFactoryTransactorRaw struct {
	Contract *IChallengeFactoryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIChallengeFactory creates a new instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactory(address common.Address, backend bind.ContractBackend) (*IChallengeFactory, error) {
	contract, err := bindIChallengeFactory(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactory{IChallengeFactoryCaller: IChallengeFactoryCaller{contract: contract}, IChallengeFactoryTransactor: IChallengeFactoryTransactor{contract: contract}, IChallengeFactoryFilterer: IChallengeFactoryFilterer{contract: contract}}, nil
}

// NewIChallengeFactoryCaller creates a new read-only instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactoryCaller(address common.Address, caller bind.ContractCaller) (*IChallengeFactoryCaller, error) {
	contract, err := bindIChallengeFactory(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactoryCaller{contract: contract}, nil
}

// NewIChallengeFactoryTransactor creates a new write-only instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactoryTransactor(address common.Address, transactor bind.ContractTransactor) (*IChallengeFactoryTransactor, error) {
	contract, err := bindIChallengeFactory(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactoryTransactor{contract: contract}, nil
}

// NewIChallengeFactoryFilterer creates a new log filterer instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactoryFilterer(address common.Address, filterer bind.ContractFilterer) (*IChallengeFactoryFilterer, error) {
	contract, err := bindIChallengeFactory(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactoryFilterer{contract: contract}, nil
}

// bindIChallengeFactory binds a generic wrapper to an already deployed contract.
func bindIChallengeFactory(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IChallengeFactoryABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IChallengeFactory *IChallengeFactoryRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IChallengeFactory.Contract.IChallengeFactoryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IChallengeFactory *IChallengeFactoryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.IChallengeFactoryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IChallengeFactory *IChallengeFactoryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.IChallengeFactoryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IChallengeFactory *IChallengeFactoryCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IChallengeFactory.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IChallengeFactory *IChallengeFactoryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IChallengeFactory *IChallengeFactoryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.contract.Transact(opts, method, params...)
}

// GenerateCloneAddress is a free data retrieval call binding the contract method 0x729406c8.
//
// Solidity: function generateCloneAddress(address asserter, address challenger, uint256 challengeType) constant returns(address)
func (_IChallengeFactory *IChallengeFactoryCaller) GenerateCloneAddress(opts *bind.CallOpts, asserter common.Address, challenger common.Address, challengeType *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _IChallengeFactory.contract.Call(opts, out, "generateCloneAddress", asserter, challenger, challengeType)
	return *ret0, err
}

// GenerateCloneAddress is a free data retrieval call binding the contract method 0x729406c8.
//
// Solidity: function generateCloneAddress(address asserter, address challenger, uint256 challengeType) constant returns(address)
func (_IChallengeFactory *IChallengeFactorySession) GenerateCloneAddress(asserter common.Address, challenger common.Address, challengeType *big.Int) (common.Address, error) {
	return _IChallengeFactory.Contract.GenerateCloneAddress(&_IChallengeFactory.CallOpts, asserter, challenger, challengeType)
}

// GenerateCloneAddress is a free data retrieval call binding the contract method 0x729406c8.
//
// Solidity: function generateCloneAddress(address asserter, address challenger, uint256 challengeType) constant returns(address)
func (_IChallengeFactory *IChallengeFactoryCallerSession) GenerateCloneAddress(asserter common.Address, challenger common.Address, challengeType *big.Int) (common.Address, error) {
	return _IChallengeFactory.Contract.GenerateCloneAddress(&_IChallengeFactory.CallOpts, asserter, challenger, challengeType)
}

// CreateChallenge is a paid mutator transaction binding the contract method 0x865da1c2.
//
// Solidity: function createChallenge(address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeHash, uint256 challengeType) returns(address)
func (_IChallengeFactory *IChallengeFactoryTransactor) CreateChallenge(opts *bind.TransactOpts, _asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeHash [32]byte, challengeType *big.Int) (*types.Transaction, error) {
	return _IChallengeFactory.contract.Transact(opts, "createChallenge", _asserter, _challenger, _challengePeriodTicks, _challengeHash, challengeType)
}

// CreateChallenge is a paid mutator transaction binding the contract method 0x865da1c2.
//
// Solidity: function createChallenge(address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeHash, uint256 challengeType) returns(address)
func (_IChallengeFactory *IChallengeFactorySession) CreateChallenge(_asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeHash [32]byte, challengeType *big.Int) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.CreateChallenge(&_IChallengeFactory.TransactOpts, _asserter, _challenger, _challengePeriodTicks, _challengeHash, challengeType)
}

// CreateChallenge is a paid mutator transaction binding the contract method 0x865da1c2.
//
// Solidity: function createChallenge(address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeHash, uint256 challengeType) returns(address)
func (_IChallengeFactory *IChallengeFactoryTransactorSession) CreateChallenge(_asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeHash [32]byte, challengeType *big.Int) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.CreateChallenge(&_IChallengeFactory.TransactOpts, _asserter, _challenger, _challengePeriodTicks, _challengeHash, challengeType)
}

// IGlobalInboxABI is the input ABI used to generate the binding from.
const IGlobalInboxABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"ContractTransactionMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"ERC20DepositMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc721\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"ERC721DepositMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"EthDepositMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"}],\"name\":\"TransactionMessageBatchDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seqNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"TransactionMessageDelivered\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositERC20Message\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc721\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositERC721Message\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"depositEthMessage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"forwardContractTransactionMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"forwardEthMessage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getInbox\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_messages\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"messageCounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"nodeHashes\",\"type\":\"bytes32[]\"}],\"name\":\"sendMessages\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seqNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"sendTransactionMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IGlobalInboxFuncSigs maps the 4-byte function signature to its string representation.
var IGlobalInboxFuncSigs = map[string]string{
	"bca22b76": "depositERC20Message(address,address,address,uint256)",
	"8b7010aa": "depositERC721Message(address,address,address,uint256)",
	"5bd21290": "depositEthMessage(address,address)",
	"84cb7997": "forwardContractTransactionMessage(address,address,uint256,bytes)",
	"96588a27": "forwardEthMessage(address,address)",
	"02201681": "getInbox(address)",
	"072fd2bb": "sendMessages(bytes,uint256[],bytes32[])",
	"8f5ed73e": "sendTransactionMessage(address,address,uint256,uint256,bytes)",
}

// IGlobalInbox is an auto generated Go binding around an Ethereum contract.
type IGlobalInbox struct {
	IGlobalInboxCaller     // Read-only binding to the contract
	IGlobalInboxTransactor // Write-only binding to the contract
	IGlobalInboxFilterer   // Log filterer for contract events
}

// IGlobalInboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type IGlobalInboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGlobalInboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IGlobalInboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGlobalInboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IGlobalInboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGlobalInboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IGlobalInboxSession struct {
	Contract     *IGlobalInbox     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IGlobalInboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IGlobalInboxCallerSession struct {
	Contract *IGlobalInboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IGlobalInboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IGlobalInboxTransactorSession struct {
	Contract     *IGlobalInboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IGlobalInboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type IGlobalInboxRaw struct {
	Contract *IGlobalInbox // Generic contract binding to access the raw methods on
}

// IGlobalInboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IGlobalInboxCallerRaw struct {
	Contract *IGlobalInboxCaller // Generic read-only contract binding to access the raw methods on
}

// IGlobalInboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IGlobalInboxTransactorRaw struct {
	Contract *IGlobalInboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIGlobalInbox creates a new instance of IGlobalInbox, bound to a specific deployed contract.
func NewIGlobalInbox(address common.Address, backend bind.ContractBackend) (*IGlobalInbox, error) {
	contract, err := bindIGlobalInbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IGlobalInbox{IGlobalInboxCaller: IGlobalInboxCaller{contract: contract}, IGlobalInboxTransactor: IGlobalInboxTransactor{contract: contract}, IGlobalInboxFilterer: IGlobalInboxFilterer{contract: contract}}, nil
}

// NewIGlobalInboxCaller creates a new read-only instance of IGlobalInbox, bound to a specific deployed contract.
func NewIGlobalInboxCaller(address common.Address, caller bind.ContractCaller) (*IGlobalInboxCaller, error) {
	contract, err := bindIGlobalInbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxCaller{contract: contract}, nil
}

// NewIGlobalInboxTransactor creates a new write-only instance of IGlobalInbox, bound to a specific deployed contract.
func NewIGlobalInboxTransactor(address common.Address, transactor bind.ContractTransactor) (*IGlobalInboxTransactor, error) {
	contract, err := bindIGlobalInbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxTransactor{contract: contract}, nil
}

// NewIGlobalInboxFilterer creates a new log filterer instance of IGlobalInbox, bound to a specific deployed contract.
func NewIGlobalInboxFilterer(address common.Address, filterer bind.ContractFilterer) (*IGlobalInboxFilterer, error) {
	contract, err := bindIGlobalInbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxFilterer{contract: contract}, nil
}

// bindIGlobalInbox binds a generic wrapper to an already deployed contract.
func bindIGlobalInbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IGlobalInboxABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IGlobalInbox *IGlobalInboxRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IGlobalInbox.Contract.IGlobalInboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IGlobalInbox *IGlobalInboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.IGlobalInboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IGlobalInbox *IGlobalInboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.IGlobalInboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IGlobalInbox *IGlobalInboxCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IGlobalInbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IGlobalInbox *IGlobalInboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IGlobalInbox *IGlobalInboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.contract.Transact(opts, method, params...)
}

// GetInbox is a free data retrieval call binding the contract method 0x02201681.
//
// Solidity: function getInbox(address account) constant returns(bytes32, uint256)
func (_IGlobalInbox *IGlobalInboxCaller) GetInbox(opts *bind.CallOpts, account common.Address) ([32]byte, *big.Int, error) {
	var (
		ret0 = new([32]byte)
		ret1 = new(*big.Int)
	)
	out := &[]interface{}{
		ret0,
		ret1,
	}
	err := _IGlobalInbox.contract.Call(opts, out, "getInbox", account)
	return *ret0, *ret1, err
}

// GetInbox is a free data retrieval call binding the contract method 0x02201681.
//
// Solidity: function getInbox(address account) constant returns(bytes32, uint256)
func (_IGlobalInbox *IGlobalInboxSession) GetInbox(account common.Address) ([32]byte, *big.Int, error) {
	return _IGlobalInbox.Contract.GetInbox(&_IGlobalInbox.CallOpts, account)
}

// GetInbox is a free data retrieval call binding the contract method 0x02201681.
//
// Solidity: function getInbox(address account) constant returns(bytes32, uint256)
func (_IGlobalInbox *IGlobalInboxCallerSession) GetInbox(account common.Address) ([32]byte, *big.Int, error) {
	return _IGlobalInbox.Contract.GetInbox(&_IGlobalInbox.CallOpts, account)
}

// DepositERC20Message is a paid mutator transaction binding the contract method 0xbca22b76.
//
// Solidity: function depositERC20Message(address _chain, address _to, address _erc20, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) DepositERC20Message(opts *bind.TransactOpts, _chain common.Address, _to common.Address, _erc20 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "depositERC20Message", _chain, _to, _erc20, _value)
}

// DepositERC20Message is a paid mutator transaction binding the contract method 0xbca22b76.
//
// Solidity: function depositERC20Message(address _chain, address _to, address _erc20, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxSession) DepositERC20Message(_chain common.Address, _to common.Address, _erc20 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositERC20Message(&_IGlobalInbox.TransactOpts, _chain, _to, _erc20, _value)
}

// DepositERC20Message is a paid mutator transaction binding the contract method 0xbca22b76.
//
// Solidity: function depositERC20Message(address _chain, address _to, address _erc20, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) DepositERC20Message(_chain common.Address, _to common.Address, _erc20 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositERC20Message(&_IGlobalInbox.TransactOpts, _chain, _to, _erc20, _value)
}

// DepositERC721Message is a paid mutator transaction binding the contract method 0x8b7010aa.
//
// Solidity: function depositERC721Message(address _chain, address _to, address _erc721, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) DepositERC721Message(opts *bind.TransactOpts, _chain common.Address, _to common.Address, _erc721 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "depositERC721Message", _chain, _to, _erc721, _value)
}

// DepositERC721Message is a paid mutator transaction binding the contract method 0x8b7010aa.
//
// Solidity: function depositERC721Message(address _chain, address _to, address _erc721, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxSession) DepositERC721Message(_chain common.Address, _to common.Address, _erc721 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositERC721Message(&_IGlobalInbox.TransactOpts, _chain, _to, _erc721, _value)
}

// DepositERC721Message is a paid mutator transaction binding the contract method 0x8b7010aa.
//
// Solidity: function depositERC721Message(address _chain, address _to, address _erc721, uint256 _value) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) DepositERC721Message(_chain common.Address, _to common.Address, _erc721 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositERC721Message(&_IGlobalInbox.TransactOpts, _chain, _to, _erc721, _value)
}

// DepositEthMessage is a paid mutator transaction binding the contract method 0x5bd21290.
//
// Solidity: function depositEthMessage(address _chain, address _to) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) DepositEthMessage(opts *bind.TransactOpts, _chain common.Address, _to common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "depositEthMessage", _chain, _to)
}

// DepositEthMessage is a paid mutator transaction binding the contract method 0x5bd21290.
//
// Solidity: function depositEthMessage(address _chain, address _to) returns()
func (_IGlobalInbox *IGlobalInboxSession) DepositEthMessage(_chain common.Address, _to common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositEthMessage(&_IGlobalInbox.TransactOpts, _chain, _to)
}

// DepositEthMessage is a paid mutator transaction binding the contract method 0x5bd21290.
//
// Solidity: function depositEthMessage(address _chain, address _to) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) DepositEthMessage(_chain common.Address, _to common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.DepositEthMessage(&_IGlobalInbox.TransactOpts, _chain, _to)
}

// ForwardContractTransactionMessage is a paid mutator transaction binding the contract method 0x84cb7997.
//
// Solidity: function forwardContractTransactionMessage(address _to, address _from, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) ForwardContractTransactionMessage(opts *bind.TransactOpts, _to common.Address, _from common.Address, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "forwardContractTransactionMessage", _to, _from, _value, _data)
}

// ForwardContractTransactionMessage is a paid mutator transaction binding the contract method 0x84cb7997.
//
// Solidity: function forwardContractTransactionMessage(address _to, address _from, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxSession) ForwardContractTransactionMessage(_to common.Address, _from common.Address, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.ForwardContractTransactionMessage(&_IGlobalInbox.TransactOpts, _to, _from, _value, _data)
}

// ForwardContractTransactionMessage is a paid mutator transaction binding the contract method 0x84cb7997.
//
// Solidity: function forwardContractTransactionMessage(address _to, address _from, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) ForwardContractTransactionMessage(_to common.Address, _from common.Address, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.ForwardContractTransactionMessage(&_IGlobalInbox.TransactOpts, _to, _from, _value, _data)
}

// ForwardEthMessage is a paid mutator transaction binding the contract method 0x96588a27.
//
// Solidity: function forwardEthMessage(address _to, address _from) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) ForwardEthMessage(opts *bind.TransactOpts, _to common.Address, _from common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "forwardEthMessage", _to, _from)
}

// ForwardEthMessage is a paid mutator transaction binding the contract method 0x96588a27.
//
// Solidity: function forwardEthMessage(address _to, address _from) returns()
func (_IGlobalInbox *IGlobalInboxSession) ForwardEthMessage(_to common.Address, _from common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.ForwardEthMessage(&_IGlobalInbox.TransactOpts, _to, _from)
}

// ForwardEthMessage is a paid mutator transaction binding the contract method 0x96588a27.
//
// Solidity: function forwardEthMessage(address _to, address _from) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) ForwardEthMessage(_to common.Address, _from common.Address) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.ForwardEthMessage(&_IGlobalInbox.TransactOpts, _to, _from)
}

// SendMessages is a paid mutator transaction binding the contract method 0x072fd2bb.
//
// Solidity: function sendMessages(bytes _messages, uint256[] messageCounts, bytes32[] nodeHashes) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) SendMessages(opts *bind.TransactOpts, _messages []byte, messageCounts []*big.Int, nodeHashes [][32]byte) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "sendMessages", _messages, messageCounts, nodeHashes)
}

// SendMessages is a paid mutator transaction binding the contract method 0x072fd2bb.
//
// Solidity: function sendMessages(bytes _messages, uint256[] messageCounts, bytes32[] nodeHashes) returns()
func (_IGlobalInbox *IGlobalInboxSession) SendMessages(_messages []byte, messageCounts []*big.Int, nodeHashes [][32]byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.SendMessages(&_IGlobalInbox.TransactOpts, _messages, messageCounts, nodeHashes)
}

// SendMessages is a paid mutator transaction binding the contract method 0x072fd2bb.
//
// Solidity: function sendMessages(bytes _messages, uint256[] messageCounts, bytes32[] nodeHashes) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) SendMessages(_messages []byte, messageCounts []*big.Int, nodeHashes [][32]byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.SendMessages(&_IGlobalInbox.TransactOpts, _messages, messageCounts, nodeHashes)
}

// SendTransactionMessage is a paid mutator transaction binding the contract method 0x8f5ed73e.
//
// Solidity: function sendTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxTransactor) SendTransactionMessage(opts *bind.TransactOpts, _chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.contract.Transact(opts, "sendTransactionMessage", _chain, _to, _seqNumber, _value, _data)
}

// SendTransactionMessage is a paid mutator transaction binding the contract method 0x8f5ed73e.
//
// Solidity: function sendTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxSession) SendTransactionMessage(_chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.SendTransactionMessage(&_IGlobalInbox.TransactOpts, _chain, _to, _seqNumber, _value, _data)
}

// SendTransactionMessage is a paid mutator transaction binding the contract method 0x8f5ed73e.
//
// Solidity: function sendTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data) returns()
func (_IGlobalInbox *IGlobalInboxTransactorSession) SendTransactionMessage(_chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalInbox.Contract.SendTransactionMessage(&_IGlobalInbox.TransactOpts, _chain, _to, _seqNumber, _value, _data)
}

// IGlobalInboxContractTransactionMessageDeliveredIterator is returned from FilterContractTransactionMessageDelivered and is used to iterate over the raw logs and unpacked data for ContractTransactionMessageDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxContractTransactionMessageDeliveredIterator struct {
	Event *IGlobalInboxContractTransactionMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxContractTransactionMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxContractTransactionMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxContractTransactionMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxContractTransactionMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxContractTransactionMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxContractTransactionMessageDelivered represents a ContractTransactionMessageDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxContractTransactionMessageDelivered struct {
	Chain      common.Address
	To         common.Address
	From       common.Address
	Value      *big.Int
	Data       []byte
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterContractTransactionMessageDelivered is a free log retrieval operation binding the contract event 0x362b3acbdbf0277aefa83754ea8d39fc1c55d01d9351cf78969923f8cfee612c.
//
// Solidity: event ContractTransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, bytes data, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterContractTransactionMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalInboxContractTransactionMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "ContractTransactionMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxContractTransactionMessageDeliveredIterator{contract: _IGlobalInbox.contract, event: "ContractTransactionMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchContractTransactionMessageDelivered is a free log subscription operation binding the contract event 0x362b3acbdbf0277aefa83754ea8d39fc1c55d01d9351cf78969923f8cfee612c.
//
// Solidity: event ContractTransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, bytes data, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchContractTransactionMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxContractTransactionMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "ContractTransactionMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxContractTransactionMessageDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "ContractTransactionMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseContractTransactionMessageDelivered is a log parse operation binding the contract event 0x362b3acbdbf0277aefa83754ea8d39fc1c55d01d9351cf78969923f8cfee612c.
//
// Solidity: event ContractTransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, bytes data, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseContractTransactionMessageDelivered(log types.Log) (*IGlobalInboxContractTransactionMessageDelivered, error) {
	event := new(IGlobalInboxContractTransactionMessageDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "ContractTransactionMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalInboxERC20DepositMessageDeliveredIterator is returned from FilterERC20DepositMessageDelivered and is used to iterate over the raw logs and unpacked data for ERC20DepositMessageDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxERC20DepositMessageDeliveredIterator struct {
	Event *IGlobalInboxERC20DepositMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxERC20DepositMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxERC20DepositMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxERC20DepositMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxERC20DepositMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxERC20DepositMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxERC20DepositMessageDelivered represents a ERC20DepositMessageDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxERC20DepositMessageDelivered struct {
	Chain      common.Address
	To         common.Address
	From       common.Address
	Erc20      common.Address
	Value      *big.Int
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterERC20DepositMessageDelivered is a free log retrieval operation binding the contract event 0xb13d04085b4a9f87fecfccf9b72081bb8a273498d6b08b4bccf2940d555b5e60.
//
// Solidity: event ERC20DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc20, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterERC20DepositMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalInboxERC20DepositMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "ERC20DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxERC20DepositMessageDeliveredIterator{contract: _IGlobalInbox.contract, event: "ERC20DepositMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchERC20DepositMessageDelivered is a free log subscription operation binding the contract event 0xb13d04085b4a9f87fecfccf9b72081bb8a273498d6b08b4bccf2940d555b5e60.
//
// Solidity: event ERC20DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc20, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchERC20DepositMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxERC20DepositMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "ERC20DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxERC20DepositMessageDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "ERC20DepositMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC20DepositMessageDelivered is a log parse operation binding the contract event 0xb13d04085b4a9f87fecfccf9b72081bb8a273498d6b08b4bccf2940d555b5e60.
//
// Solidity: event ERC20DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc20, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseERC20DepositMessageDelivered(log types.Log) (*IGlobalInboxERC20DepositMessageDelivered, error) {
	event := new(IGlobalInboxERC20DepositMessageDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "ERC20DepositMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalInboxERC721DepositMessageDeliveredIterator is returned from FilterERC721DepositMessageDelivered and is used to iterate over the raw logs and unpacked data for ERC721DepositMessageDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxERC721DepositMessageDeliveredIterator struct {
	Event *IGlobalInboxERC721DepositMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxERC721DepositMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxERC721DepositMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxERC721DepositMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxERC721DepositMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxERC721DepositMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxERC721DepositMessageDelivered represents a ERC721DepositMessageDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxERC721DepositMessageDelivered struct {
	Chain      common.Address
	To         common.Address
	From       common.Address
	Erc721     common.Address
	Id         *big.Int
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterERC721DepositMessageDelivered is a free log retrieval operation binding the contract event 0x40baf11a4a4a4be2a155dbf303fbaec6fabd52e267268bd7e3de4b4ed8a2e095.
//
// Solidity: event ERC721DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc721, uint256 id, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterERC721DepositMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalInboxERC721DepositMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "ERC721DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxERC721DepositMessageDeliveredIterator{contract: _IGlobalInbox.contract, event: "ERC721DepositMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchERC721DepositMessageDelivered is a free log subscription operation binding the contract event 0x40baf11a4a4a4be2a155dbf303fbaec6fabd52e267268bd7e3de4b4ed8a2e095.
//
// Solidity: event ERC721DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc721, uint256 id, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchERC721DepositMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxERC721DepositMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "ERC721DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxERC721DepositMessageDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "ERC721DepositMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC721DepositMessageDelivered is a log parse operation binding the contract event 0x40baf11a4a4a4be2a155dbf303fbaec6fabd52e267268bd7e3de4b4ed8a2e095.
//
// Solidity: event ERC721DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc721, uint256 id, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseERC721DepositMessageDelivered(log types.Log) (*IGlobalInboxERC721DepositMessageDelivered, error) {
	event := new(IGlobalInboxERC721DepositMessageDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "ERC721DepositMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalInboxEthDepositMessageDeliveredIterator is returned from FilterEthDepositMessageDelivered and is used to iterate over the raw logs and unpacked data for EthDepositMessageDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxEthDepositMessageDeliveredIterator struct {
	Event *IGlobalInboxEthDepositMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxEthDepositMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxEthDepositMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxEthDepositMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxEthDepositMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxEthDepositMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxEthDepositMessageDelivered represents a EthDepositMessageDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxEthDepositMessageDelivered struct {
	Chain      common.Address
	To         common.Address
	From       common.Address
	Value      *big.Int
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterEthDepositMessageDelivered is a free log retrieval operation binding the contract event 0xfd0d0553177fec183128f048fbde54554a3a67302f7ebd7f735215a358290705.
//
// Solidity: event EthDepositMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterEthDepositMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalInboxEthDepositMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "EthDepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxEthDepositMessageDeliveredIterator{contract: _IGlobalInbox.contract, event: "EthDepositMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchEthDepositMessageDelivered is a free log subscription operation binding the contract event 0xfd0d0553177fec183128f048fbde54554a3a67302f7ebd7f735215a358290705.
//
// Solidity: event EthDepositMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchEthDepositMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxEthDepositMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "EthDepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxEthDepositMessageDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "EthDepositMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEthDepositMessageDelivered is a log parse operation binding the contract event 0xfd0d0553177fec183128f048fbde54554a3a67302f7ebd7f735215a358290705.
//
// Solidity: event EthDepositMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, uint256 messageNum)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseEthDepositMessageDelivered(log types.Log) (*IGlobalInboxEthDepositMessageDelivered, error) {
	event := new(IGlobalInboxEthDepositMessageDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "EthDepositMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalInboxTransactionMessageBatchDeliveredIterator is returned from FilterTransactionMessageBatchDelivered and is used to iterate over the raw logs and unpacked data for TransactionMessageBatchDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxTransactionMessageBatchDeliveredIterator struct {
	Event *IGlobalInboxTransactionMessageBatchDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxTransactionMessageBatchDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxTransactionMessageBatchDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxTransactionMessageBatchDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxTransactionMessageBatchDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxTransactionMessageBatchDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxTransactionMessageBatchDelivered represents a TransactionMessageBatchDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxTransactionMessageBatchDelivered struct {
	Chain common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransactionMessageBatchDelivered is a free log retrieval operation binding the contract event 0x9cd591b0e52bcf1c506475ee03776192ea3d99f35150ef6651b339333b7372c4.
//
// Solidity: event TransactionMessageBatchDelivered(address indexed chain)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterTransactionMessageBatchDelivered(opts *bind.FilterOpts, chain []common.Address) (*IGlobalInboxTransactionMessageBatchDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "TransactionMessageBatchDelivered", chainRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxTransactionMessageBatchDeliveredIterator{contract: _IGlobalInbox.contract, event: "TransactionMessageBatchDelivered", logs: logs, sub: sub}, nil
}

// WatchTransactionMessageBatchDelivered is a free log subscription operation binding the contract event 0x9cd591b0e52bcf1c506475ee03776192ea3d99f35150ef6651b339333b7372c4.
//
// Solidity: event TransactionMessageBatchDelivered(address indexed chain)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchTransactionMessageBatchDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxTransactionMessageBatchDelivered, chain []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "TransactionMessageBatchDelivered", chainRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxTransactionMessageBatchDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "TransactionMessageBatchDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransactionMessageBatchDelivered is a log parse operation binding the contract event 0x9cd591b0e52bcf1c506475ee03776192ea3d99f35150ef6651b339333b7372c4.
//
// Solidity: event TransactionMessageBatchDelivered(address indexed chain)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseTransactionMessageBatchDelivered(log types.Log) (*IGlobalInboxTransactionMessageBatchDelivered, error) {
	event := new(IGlobalInboxTransactionMessageBatchDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "TransactionMessageBatchDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalInboxTransactionMessageDeliveredIterator is returned from FilterTransactionMessageDelivered and is used to iterate over the raw logs and unpacked data for TransactionMessageDelivered events raised by the IGlobalInbox contract.
type IGlobalInboxTransactionMessageDeliveredIterator struct {
	Event *IGlobalInboxTransactionMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalInboxTransactionMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalInboxTransactionMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalInboxTransactionMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalInboxTransactionMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalInboxTransactionMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalInboxTransactionMessageDelivered represents a TransactionMessageDelivered event raised by the IGlobalInbox contract.
type IGlobalInboxTransactionMessageDelivered struct {
	Chain     common.Address
	To        common.Address
	From      common.Address
	SeqNumber *big.Int
	Value     *big.Int
	Data      []byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterTransactionMessageDelivered is a free log retrieval operation binding the contract event 0xcf612c95e8993eca9c6e0be96b26b47022996db601dc12b4cf68ec37829d87b3.
//
// Solidity: event TransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 seqNumber, uint256 value, bytes data)
func (_IGlobalInbox *IGlobalInboxFilterer) FilterTransactionMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalInboxTransactionMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.FilterLogs(opts, "TransactionMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalInboxTransactionMessageDeliveredIterator{contract: _IGlobalInbox.contract, event: "TransactionMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchTransactionMessageDelivered is a free log subscription operation binding the contract event 0xcf612c95e8993eca9c6e0be96b26b47022996db601dc12b4cf68ec37829d87b3.
//
// Solidity: event TransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 seqNumber, uint256 value, bytes data)
func (_IGlobalInbox *IGlobalInboxFilterer) WatchTransactionMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalInboxTransactionMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalInbox.contract.WatchLogs(opts, "TransactionMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalInboxTransactionMessageDelivered)
				if err := _IGlobalInbox.contract.UnpackLog(event, "TransactionMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransactionMessageDelivered is a log parse operation binding the contract event 0xcf612c95e8993eca9c6e0be96b26b47022996db601dc12b4cf68ec37829d87b3.
//
// Solidity: event TransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 seqNumber, uint256 value, bytes data)
func (_IGlobalInbox *IGlobalInboxFilterer) ParseTransactionMessageDelivered(log types.Log) (*IGlobalInboxTransactionMessageDelivered, error) {
	event := new(IGlobalInboxTransactionMessageDelivered)
	if err := _IGlobalInbox.contract.UnpackLog(event, "TransactionMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphABI is the input ABI used to generate the binding from.
const NodeGraphABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[8]\",\"name\":\"fields\",\"type\":\"bytes32[8]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inboxCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"importedMessageCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[4]\",\"name\":\"timeBounds\",\"type\":\"uint128[4]\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numArbGas\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numSteps\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didInboxInsn\",\"type\":\"bool\"}],\"name\":\"RollupAsserted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"initVMHash\",\"type\":\"bytes32\"}],\"name\":\"RollupCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"RollupPruned\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalInbox\",\"outputs\":[{\"internalType\":\"contractIGlobalInbox\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"isValidLeaf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestConfirmed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"fromNodes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"leafProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"leafProofLengths\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"latestConfProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"latestConfirmedProofLengths\",\"type\":\"uint256[]\"}],\"name\":\"pruneLeaves\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vmParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gracePeriodTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arbGasSpeedLimitPerTick\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"maxExecutionSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxBlockBoundsWidth\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxTimestampBoundsWidth\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// NodeGraphFuncSigs maps the 4-byte function signature to its string representation.
var NodeGraphFuncSigs = map[string]string{
	"d489113a": "globalInbox()",
	"57ca6d1b": "isValidLeaf(bytes32)",
	"65f7f80d": "latestConfirmed()",
	"fcfd8d3f": "pruneLeaves(bytes32[],bytes32[],uint256[],bytes32[],uint256[])",
	"bbc2cc00": "vmParams()",
}

// NodeGraphBin is the compiled bytecode used for deploying new contracts.
var NodeGraphBin = "0x608060405234801561001057600080fd5b5061077d806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806357ca6d1b1461005c57806365f7f80d1461008d578063bbc2cc00146100a7578063d489113a146100e7578063fcfd8d3f1461010b575b600080fd5b6100796004803603602081101561007257600080fd5b50356103b6565b604080519115158252519081900360200190f35b6100956103cb565b60408051918252519081900360200190f35b6100af6103d1565b60408051958652602086019490945267ffffffffffffffff928316858501529082166060850152166080830152519081900360a00190f35b6100ef610402565b604080516001600160a01b039092168252519081900360200190f35b6103b4600480360360a081101561012157600080fd5b810190602081018135600160201b81111561013b57600080fd5b82018360208201111561014d57600080fd5b803590602001918460208302840111600160201b8311171561016e57600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156101bd57600080fd5b8201836020820111156101cf57600080fd5b803590602001918460208302840111600160201b831117156101f057600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561023f57600080fd5b82018360208201111561025157600080fd5b803590602001918460208302840111600160201b8311171561027257600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156102c157600080fd5b8201836020820111156102d357600080fd5b803590602001918460208302840111600160201b831117156102f457600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561034357600080fd5b82018360208201111561035557600080fd5b803590602001918460208302840111600160201b8311171561037657600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550610411945050505050565b005b60009081526004602052604090205460ff1690565b60055490565b60015460025460035467ffffffffffffffff80821691680100000000000000008104821691600160801b9091041685565b6000546001600160a01b031681565b84518351811480156104235750808251145b61046d576040805162461bcd60e51b81526020600482015260166024820152750d2dce0eae840d8cadccee8d040dad2e6e8dac2e8c6d60531b604482015290519081900360640190fd5b600080805b838110156104cf576104c289828151811061048957fe5b602002602001015186838151811061049d57fe5b60200260200101518984815181106104b157fe5b60200260200101518b8a88886104da565b9093509150600101610472565b505050505050505050565b6000806000871180156104ed5750600088115b6040518060400160405280600e81526020016d28292aa722afa82927a7a32622a760911b8152509061059d5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561056257818101518382015260200161054a565b50505050905090810190601f16801561058f5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5083870183890160006105ae6103cb565b6105ba8d8a89866106e0565b1490508080156105f057508786815181106105d157fe5b60200260200101518988815181106105e557fe5b602002602001015114155b6040518060400160405280600e81526020016d141495539157d0d3d391931250d560921b815250906106635760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561056257818101518382015260200161054a565b5060006106728d8b8a876106e0565b905061067d816103b6565b156106ce57600081815260046020908152604091829020805460ff19169055815183815291517f3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f44909509281900390910190a15b50919b909a5098505050505050505050565b600084835b8381101561073e57818682815181106106fa57fe5b6020026020010151604051602001808381526020018281526020019250505060405160208183030381529060405280519060200120915080806001019150506106e5565b509594505050505056fea265627a7a723158209e8330ee63c2b32c74e65c17756434e8f8e7b9183cb71d88c10f829a079ffb0c64736f6c634300050f0032"

// DeployNodeGraph deploys a new Ethereum contract, binding an instance of NodeGraph to it.
func DeployNodeGraph(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *NodeGraph, error) {
	parsed, err := abi.JSON(strings.NewReader(NodeGraphABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(NodeGraphBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &NodeGraph{NodeGraphCaller: NodeGraphCaller{contract: contract}, NodeGraphTransactor: NodeGraphTransactor{contract: contract}, NodeGraphFilterer: NodeGraphFilterer{contract: contract}}, nil
}

// NodeGraph is an auto generated Go binding around an Ethereum contract.
type NodeGraph struct {
	NodeGraphCaller     // Read-only binding to the contract
	NodeGraphTransactor // Write-only binding to the contract
	NodeGraphFilterer   // Log filterer for contract events
}

// NodeGraphCaller is an auto generated read-only Go binding around an Ethereum contract.
type NodeGraphCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphTransactor is an auto generated write-only Go binding around an Ethereum contract.
type NodeGraphTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type NodeGraphFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type NodeGraphSession struct {
	Contract     *NodeGraph        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// NodeGraphCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type NodeGraphCallerSession struct {
	Contract *NodeGraphCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// NodeGraphTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type NodeGraphTransactorSession struct {
	Contract     *NodeGraphTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// NodeGraphRaw is an auto generated low-level Go binding around an Ethereum contract.
type NodeGraphRaw struct {
	Contract *NodeGraph // Generic contract binding to access the raw methods on
}

// NodeGraphCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type NodeGraphCallerRaw struct {
	Contract *NodeGraphCaller // Generic read-only contract binding to access the raw methods on
}

// NodeGraphTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type NodeGraphTransactorRaw struct {
	Contract *NodeGraphTransactor // Generic write-only contract binding to access the raw methods on
}

// NewNodeGraph creates a new instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraph(address common.Address, backend bind.ContractBackend) (*NodeGraph, error) {
	contract, err := bindNodeGraph(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &NodeGraph{NodeGraphCaller: NodeGraphCaller{contract: contract}, NodeGraphTransactor: NodeGraphTransactor{contract: contract}, NodeGraphFilterer: NodeGraphFilterer{contract: contract}}, nil
}

// NewNodeGraphCaller creates a new read-only instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraphCaller(address common.Address, caller bind.ContractCaller) (*NodeGraphCaller, error) {
	contract, err := bindNodeGraph(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &NodeGraphCaller{contract: contract}, nil
}

// NewNodeGraphTransactor creates a new write-only instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraphTransactor(address common.Address, transactor bind.ContractTransactor) (*NodeGraphTransactor, error) {
	contract, err := bindNodeGraph(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &NodeGraphTransactor{contract: contract}, nil
}

// NewNodeGraphFilterer creates a new log filterer instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraphFilterer(address common.Address, filterer bind.ContractFilterer) (*NodeGraphFilterer, error) {
	contract, err := bindNodeGraph(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &NodeGraphFilterer{contract: contract}, nil
}

// bindNodeGraph binds a generic wrapper to an already deployed contract.
func bindNodeGraph(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(NodeGraphABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeGraph *NodeGraphRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _NodeGraph.Contract.NodeGraphCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeGraph *NodeGraphRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeGraph.Contract.NodeGraphTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeGraph *NodeGraphRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeGraph.Contract.NodeGraphTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeGraph *NodeGraphCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _NodeGraph.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeGraph *NodeGraphTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeGraph.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeGraph *NodeGraphTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeGraph.Contract.contract.Transact(opts, method, params...)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_NodeGraph *NodeGraphCaller) GlobalInbox(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _NodeGraph.contract.Call(opts, out, "globalInbox")
	return *ret0, err
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_NodeGraph *NodeGraphSession) GlobalInbox() (common.Address, error) {
	return _NodeGraph.Contract.GlobalInbox(&_NodeGraph.CallOpts)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_NodeGraph *NodeGraphCallerSession) GlobalInbox() (common.Address, error) {
	return _NodeGraph.Contract.GlobalInbox(&_NodeGraph.CallOpts)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_NodeGraph *NodeGraphCaller) IsValidLeaf(opts *bind.CallOpts, leaf [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _NodeGraph.contract.Call(opts, out, "isValidLeaf", leaf)
	return *ret0, err
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_NodeGraph *NodeGraphSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _NodeGraph.Contract.IsValidLeaf(&_NodeGraph.CallOpts, leaf)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_NodeGraph *NodeGraphCallerSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _NodeGraph.Contract.IsValidLeaf(&_NodeGraph.CallOpts, leaf)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_NodeGraph *NodeGraphCaller) LatestConfirmed(opts *bind.CallOpts) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _NodeGraph.contract.Call(opts, out, "latestConfirmed")
	return *ret0, err
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_NodeGraph *NodeGraphSession) LatestConfirmed() ([32]byte, error) {
	return _NodeGraph.Contract.LatestConfirmed(&_NodeGraph.CallOpts)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_NodeGraph *NodeGraphCallerSession) LatestConfirmed() ([32]byte, error) {
	return _NodeGraph.Contract.LatestConfirmed(&_NodeGraph.CallOpts)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_NodeGraph *NodeGraphCaller) VmParams(opts *bind.CallOpts) (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	ret := new(struct {
		GracePeriodTicks        *big.Int
		ArbGasSpeedLimitPerTick *big.Int
		MaxExecutionSteps       uint64
		MaxBlockBoundsWidth     uint64
		MaxTimestampBoundsWidth uint64
	})
	out := ret
	err := _NodeGraph.contract.Call(opts, out, "vmParams")
	return *ret, err
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_NodeGraph *NodeGraphSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	return _NodeGraph.Contract.VmParams(&_NodeGraph.CallOpts)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps, uint64 maxBlockBoundsWidth, uint64 maxTimestampBoundsWidth)
func (_NodeGraph *NodeGraphCallerSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
	MaxBlockBoundsWidth     uint64
	MaxTimestampBoundsWidth uint64
}, error) {
	return _NodeGraph.Contract.VmParams(&_NodeGraph.CallOpts)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_NodeGraph *NodeGraphTransactor) PruneLeaves(opts *bind.TransactOpts, fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _NodeGraph.contract.Transact(opts, "pruneLeaves", fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_NodeGraph *NodeGraphSession) PruneLeaves(fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _NodeGraph.Contract.PruneLeaves(&_NodeGraph.TransactOpts, fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// PruneLeaves is a paid mutator transaction binding the contract method 0xfcfd8d3f.
//
// Solidity: function pruneLeaves(bytes32[] fromNodes, bytes32[] leafProofs, uint256[] leafProofLengths, bytes32[] latestConfProofs, uint256[] latestConfirmedProofLengths) returns()
func (_NodeGraph *NodeGraphTransactorSession) PruneLeaves(fromNodes [][32]byte, leafProofs [][32]byte, leafProofLengths []*big.Int, latestConfProofs [][32]byte, latestConfirmedProofLengths []*big.Int) (*types.Transaction, error) {
	return _NodeGraph.Contract.PruneLeaves(&_NodeGraph.TransactOpts, fromNodes, leafProofs, leafProofLengths, latestConfProofs, latestConfirmedProofLengths)
}

// NodeGraphRollupAssertedIterator is returned from FilterRollupAsserted and is used to iterate over the raw logs and unpacked data for RollupAsserted events raised by the NodeGraph contract.
type NodeGraphRollupAssertedIterator struct {
	Event *NodeGraphRollupAsserted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupAssertedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupAsserted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupAsserted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupAssertedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupAssertedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupAsserted represents a RollupAsserted event raised by the NodeGraph contract.
type NodeGraphRollupAsserted struct {
	Fields               [8][32]byte
	InboxCount           *big.Int
	ImportedMessageCount *big.Int
	TimeBounds           [4]*big.Int
	NumArbGas            uint64
	NumSteps             uint64
	DidInboxInsn         bool
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterRollupAsserted is a free log retrieval operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_NodeGraph *NodeGraphFilterer) FilterRollupAsserted(opts *bind.FilterOpts) (*NodeGraphRollupAssertedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupAssertedIterator{contract: _NodeGraph.contract, event: "RollupAsserted", logs: logs, sub: sub}, nil
}

// WatchRollupAsserted is a free log subscription operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_NodeGraph *NodeGraphFilterer) WatchRollupAsserted(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupAsserted) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupAsserted)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupAsserted is a log parse operation binding the contract event 0xccfde124674b691321bd032f0eb12e5193e66be4aae537ad8c63b824b85bbdfc.
//
// Solidity: event RollupAsserted(bytes32[8] fields, uint256 inboxCount, uint256 importedMessageCount, uint128[4] timeBounds, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_NodeGraph *NodeGraphFilterer) ParseRollupAsserted(log types.Log) (*NodeGraphRollupAsserted, error) {
	event := new(NodeGraphRollupAsserted)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphRollupConfirmedIterator is returned from FilterRollupConfirmed and is used to iterate over the raw logs and unpacked data for RollupConfirmed events raised by the NodeGraph contract.
type NodeGraphRollupConfirmedIterator struct {
	Event *NodeGraphRollupConfirmed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupConfirmedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupConfirmed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupConfirmed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupConfirmedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupConfirmedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupConfirmed represents a RollupConfirmed event raised by the NodeGraph contract.
type NodeGraphRollupConfirmed struct {
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupConfirmed is a free log retrieval operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_NodeGraph *NodeGraphFilterer) FilterRollupConfirmed(opts *bind.FilterOpts) (*NodeGraphRollupConfirmedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupConfirmedIterator{contract: _NodeGraph.contract, event: "RollupConfirmed", logs: logs, sub: sub}, nil
}

// WatchRollupConfirmed is a free log subscription operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_NodeGraph *NodeGraphFilterer) WatchRollupConfirmed(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupConfirmed) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupConfirmed)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupConfirmed is a log parse operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_NodeGraph *NodeGraphFilterer) ParseRollupConfirmed(log types.Log) (*NodeGraphRollupConfirmed, error) {
	event := new(NodeGraphRollupConfirmed)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphRollupCreatedIterator is returned from FilterRollupCreated and is used to iterate over the raw logs and unpacked data for RollupCreated events raised by the NodeGraph contract.
type NodeGraphRollupCreatedIterator struct {
	Event *NodeGraphRollupCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupCreated represents a RollupCreated event raised by the NodeGraph contract.
type NodeGraphRollupCreated struct {
	InitVMHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupCreated is a free log retrieval operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_NodeGraph *NodeGraphFilterer) FilterRollupCreated(opts *bind.FilterOpts) (*NodeGraphRollupCreatedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupCreatedIterator{contract: _NodeGraph.contract, event: "RollupCreated", logs: logs, sub: sub}, nil
}

// WatchRollupCreated is a free log subscription operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_NodeGraph *NodeGraphFilterer) WatchRollupCreated(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupCreated) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupCreated)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupCreated is a log parse operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_NodeGraph *NodeGraphFilterer) ParseRollupCreated(log types.Log) (*NodeGraphRollupCreated, error) {
	event := new(NodeGraphRollupCreated)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphRollupPrunedIterator is returned from FilterRollupPruned and is used to iterate over the raw logs and unpacked data for RollupPruned events raised by the NodeGraph contract.
type NodeGraphRollupPrunedIterator struct {
	Event *NodeGraphRollupPruned // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupPrunedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupPruned)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupPruned)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupPrunedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupPrunedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupPruned represents a RollupPruned event raised by the NodeGraph contract.
type NodeGraphRollupPruned struct {
	Leaf [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRollupPruned is a free log retrieval operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_NodeGraph *NodeGraphFilterer) FilterRollupPruned(opts *bind.FilterOpts) (*NodeGraphRollupPrunedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupPrunedIterator{contract: _NodeGraph.contract, event: "RollupPruned", logs: logs, sub: sub}, nil
}

// WatchRollupPruned is a free log subscription operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_NodeGraph *NodeGraphFilterer) WatchRollupPruned(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupPruned) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupPruned)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupPruned", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupPruned is a log parse operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_NodeGraph *NodeGraphFilterer) ParseRollupPruned(log types.Log) (*NodeGraphRollupPruned, error) {
	event := new(NodeGraphRollupPruned)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupPruned", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphUtilsABI is the input ABI used to generate the binding from.
const NodeGraphUtilsABI = "[]"

// NodeGraphUtilsBin is the compiled bytecode used for deploying new contracts.
var NodeGraphUtilsBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820a52b40ae7cd049dcd9a282725400dece257f8177bd960fb442e61ce1b76b6df364736f6c634300050f0032"

// DeployNodeGraphUtils deploys a new Ethereum contract, binding an instance of NodeGraphUtils to it.
func DeployNodeGraphUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *NodeGraphUtils, error) {
	parsed, err := abi.JSON(strings.NewReader(NodeGraphUtilsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(NodeGraphUtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &NodeGraphUtils{NodeGraphUtilsCaller: NodeGraphUtilsCaller{contract: contract}, NodeGraphUtilsTransactor: NodeGraphUtilsTransactor{contract: contract}, NodeGraphUtilsFilterer: NodeGraphUtilsFilterer{contract: contract}}, nil
}

// NodeGraphUtils is an auto generated Go binding around an Ethereum contract.
type NodeGraphUtils struct {
	NodeGraphUtilsCaller     // Read-only binding to the contract
	NodeGraphUtilsTransactor // Write-only binding to the contract
	NodeGraphUtilsFilterer   // Log filterer for contract events
}

// NodeGraphUtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type NodeGraphUtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphUtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type NodeGraphUtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphUtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type NodeGraphUtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphUtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type NodeGraphUtilsSession struct {
	Contract     *NodeGraphUtils   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// NodeGraphUtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type NodeGraphUtilsCallerSession struct {
	Contract *NodeGraphUtilsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// NodeGraphUtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type NodeGraphUtilsTransactorSession struct {
	Contract     *NodeGraphUtilsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// NodeGraphUtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type NodeGraphUtilsRaw struct {
	Contract *NodeGraphUtils // Generic contract binding to access the raw methods on
}

// NodeGraphUtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type NodeGraphUtilsCallerRaw struct {
	Contract *NodeGraphUtilsCaller // Generic read-only contract binding to access the raw methods on
}

// NodeGraphUtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type NodeGraphUtilsTransactorRaw struct {
	Contract *NodeGraphUtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewNodeGraphUtils creates a new instance of NodeGraphUtils, bound to a specific deployed contract.
func NewNodeGraphUtils(address common.Address, backend bind.ContractBackend) (*NodeGraphUtils, error) {
	contract, err := bindNodeGraphUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &NodeGraphUtils{NodeGraphUtilsCaller: NodeGraphUtilsCaller{contract: contract}, NodeGraphUtilsTransactor: NodeGraphUtilsTransactor{contract: contract}, NodeGraphUtilsFilterer: NodeGraphUtilsFilterer{contract: contract}}, nil
}

// NewNodeGraphUtilsCaller creates a new read-only instance of NodeGraphUtils, bound to a specific deployed contract.
func NewNodeGraphUtilsCaller(address common.Address, caller bind.ContractCaller) (*NodeGraphUtilsCaller, error) {
	contract, err := bindNodeGraphUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &NodeGraphUtilsCaller{contract: contract}, nil
}

// NewNodeGraphUtilsTransactor creates a new write-only instance of NodeGraphUtils, bound to a specific deployed contract.
func NewNodeGraphUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*NodeGraphUtilsTransactor, error) {
	contract, err := bindNodeGraphUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &NodeGraphUtilsTransactor{contract: contract}, nil
}

// NewNodeGraphUtilsFilterer creates a new log filterer instance of NodeGraphUtils, bound to a specific deployed contract.
func NewNodeGraphUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*NodeGraphUtilsFilterer, error) {
	contract, err := bindNodeGraphUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &NodeGraphUtilsFilterer{contract: contract}, nil
}

// bindNodeGraphUtils binds a generic wrapper to an already deployed contract.
func bindNodeGraphUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(NodeGraphUtilsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeGraphUtils *NodeGraphUtilsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _NodeGraphUtils.Contract.NodeGraphUtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeGraphUtils *NodeGraphUtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeGraphUtils.Contract.NodeGraphUtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeGraphUtils *NodeGraphUtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeGraphUtils.Contract.NodeGraphUtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeGraphUtils *NodeGraphUtilsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _NodeGraphUtils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeGraphUtils *NodeGraphUtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeGraphUtils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeGraphUtils *NodeGraphUtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeGraphUtils.Contract.contract.Transact(opts, method, params...)
}

// ProtocolABI is the input ABI used to generate the binding from.
const ProtocolABI = "[]"

// ProtocolBin is the compiled bytecode used for deploying new contracts.
var ProtocolBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820394193043a4aa777efd1395238c96d8bb055e65d8f449835e4663e5d6194359964736f6c634300050f0032"

// DeployProtocol deploys a new Ethereum contract, binding an instance of Protocol to it.
func DeployProtocol(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Protocol, error) {
	parsed, err := abi.JSON(strings.NewReader(ProtocolABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ProtocolBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Protocol{ProtocolCaller: ProtocolCaller{contract: contract}, ProtocolTransactor: ProtocolTransactor{contract: contract}, ProtocolFilterer: ProtocolFilterer{contract: contract}}, nil
}

// Protocol is an auto generated Go binding around an Ethereum contract.
type Protocol struct {
	ProtocolCaller     // Read-only binding to the contract
	ProtocolTransactor // Write-only binding to the contract
	ProtocolFilterer   // Log filterer for contract events
}

// ProtocolCaller is an auto generated read-only Go binding around an Ethereum contract.
type ProtocolCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ProtocolTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ProtocolTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ProtocolFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ProtocolFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ProtocolSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ProtocolSession struct {
	Contract     *Protocol         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ProtocolCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ProtocolCallerSession struct {
	Contract *ProtocolCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// ProtocolTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ProtocolTransactorSession struct {
	Contract     *ProtocolTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ProtocolRaw is an auto generated low-level Go binding around an Ethereum contract.
type ProtocolRaw struct {
	Contract *Protocol // Generic contract binding to access the raw methods on
}

// ProtocolCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ProtocolCallerRaw struct {
	Contract *ProtocolCaller // Generic read-only contract binding to access the raw methods on
}

// ProtocolTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ProtocolTransactorRaw struct {
	Contract *ProtocolTransactor // Generic write-only contract binding to access the raw methods on
}

// NewProtocol creates a new instance of Protocol, bound to a specific deployed contract.
func NewProtocol(address common.Address, backend bind.ContractBackend) (*Protocol, error) {
	contract, err := bindProtocol(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Protocol{ProtocolCaller: ProtocolCaller{contract: contract}, ProtocolTransactor: ProtocolTransactor{contract: contract}, ProtocolFilterer: ProtocolFilterer{contract: contract}}, nil
}

// NewProtocolCaller creates a new read-only instance of Protocol, bound to a specific deployed contract.
func NewProtocolCaller(address common.Address, caller bind.ContractCaller) (*ProtocolCaller, error) {
	contract, err := bindProtocol(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ProtocolCaller{contract: contract}, nil
}

// NewProtocolTransactor creates a new write-only instance of Protocol, bound to a specific deployed contract.
func NewProtocolTransactor(address common.Address, transactor bind.ContractTransactor) (*ProtocolTransactor, error) {
	contract, err := bindProtocol(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ProtocolTransactor{contract: contract}, nil
}

// NewProtocolFilterer creates a new log filterer instance of Protocol, bound to a specific deployed contract.
func NewProtocolFilterer(address common.Address, filterer bind.ContractFilterer) (*ProtocolFilterer, error) {
	contract, err := bindProtocol(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ProtocolFilterer{contract: contract}, nil
}

// bindProtocol binds a generic wrapper to an already deployed contract.
func bindProtocol(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ProtocolABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Protocol *ProtocolRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Protocol.Contract.ProtocolCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Protocol *ProtocolRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Protocol.Contract.ProtocolTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Protocol *ProtocolRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Protocol.Contract.ProtocolTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Protocol *ProtocolCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Protocol.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Protocol *ProtocolTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Protocol.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Protocol *ProtocolTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Protocol.Contract.contract.Transact(opts, method, params...)
}

// RollupTimeABI is the input ABI used to generate the binding from.
const RollupTimeABI = "[]"

// RollupTimeBin is the compiled bytecode used for deploying new contracts.
var RollupTimeBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820c104b2abeaa99278b05e5ee999cf1befae1e76998c6df565b4b0a6270c5d15e964736f6c634300050f0032"

// DeployRollupTime deploys a new Ethereum contract, binding an instance of RollupTime to it.
func DeployRollupTime(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *RollupTime, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupTimeABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(RollupTimeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &RollupTime{RollupTimeCaller: RollupTimeCaller{contract: contract}, RollupTimeTransactor: RollupTimeTransactor{contract: contract}, RollupTimeFilterer: RollupTimeFilterer{contract: contract}}, nil
}

// RollupTime is an auto generated Go binding around an Ethereum contract.
type RollupTime struct {
	RollupTimeCaller     // Read-only binding to the contract
	RollupTimeTransactor // Write-only binding to the contract
	RollupTimeFilterer   // Log filterer for contract events
}

// RollupTimeCaller is an auto generated read-only Go binding around an Ethereum contract.
type RollupTimeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupTimeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RollupTimeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupTimeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RollupTimeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupTimeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RollupTimeSession struct {
	Contract     *RollupTime       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RollupTimeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RollupTimeCallerSession struct {
	Contract *RollupTimeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// RollupTimeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RollupTimeTransactorSession struct {
	Contract     *RollupTimeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// RollupTimeRaw is an auto generated low-level Go binding around an Ethereum contract.
type RollupTimeRaw struct {
	Contract *RollupTime // Generic contract binding to access the raw methods on
}

// RollupTimeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RollupTimeCallerRaw struct {
	Contract *RollupTimeCaller // Generic read-only contract binding to access the raw methods on
}

// RollupTimeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RollupTimeTransactorRaw struct {
	Contract *RollupTimeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRollupTime creates a new instance of RollupTime, bound to a specific deployed contract.
func NewRollupTime(address common.Address, backend bind.ContractBackend) (*RollupTime, error) {
	contract, err := bindRollupTime(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &RollupTime{RollupTimeCaller: RollupTimeCaller{contract: contract}, RollupTimeTransactor: RollupTimeTransactor{contract: contract}, RollupTimeFilterer: RollupTimeFilterer{contract: contract}}, nil
}

// NewRollupTimeCaller creates a new read-only instance of RollupTime, bound to a specific deployed contract.
func NewRollupTimeCaller(address common.Address, caller bind.ContractCaller) (*RollupTimeCaller, error) {
	contract, err := bindRollupTime(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RollupTimeCaller{contract: contract}, nil
}

// NewRollupTimeTransactor creates a new write-only instance of RollupTime, bound to a specific deployed contract.
func NewRollupTimeTransactor(address common.Address, transactor bind.ContractTransactor) (*RollupTimeTransactor, error) {
	contract, err := bindRollupTime(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RollupTimeTransactor{contract: contract}, nil
}

// NewRollupTimeFilterer creates a new log filterer instance of RollupTime, bound to a specific deployed contract.
func NewRollupTimeFilterer(address common.Address, filterer bind.ContractFilterer) (*RollupTimeFilterer, error) {
	contract, err := bindRollupTime(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RollupTimeFilterer{contract: contract}, nil
}

// bindRollupTime binds a generic wrapper to an already deployed contract.
func bindRollupTime(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupTimeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupTime *RollupTimeRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupTime.Contract.RollupTimeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupTime *RollupTimeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupTime.Contract.RollupTimeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupTime *RollupTimeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupTime.Contract.RollupTimeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupTime *RollupTimeCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupTime.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupTime *RollupTimeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupTime.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupTime *RollupTimeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupTime.Contract.contract.Transact(opts, method, params...)
}

// RollupUtilsABI is the input ABI used to generate the binding from.
const RollupUtilsABI = "[]"

// RollupUtilsBin is the compiled bytecode used for deploying new contracts.
var RollupUtilsBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820d1b3a11214dbee5549978e564f916e08b7b85793990f275f93c9cf3342b317b164736f6c634300050f0032"

// DeployRollupUtils deploys a new Ethereum contract, binding an instance of RollupUtils to it.
func DeployRollupUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *RollupUtils, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupUtilsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(RollupUtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &RollupUtils{RollupUtilsCaller: RollupUtilsCaller{contract: contract}, RollupUtilsTransactor: RollupUtilsTransactor{contract: contract}, RollupUtilsFilterer: RollupUtilsFilterer{contract: contract}}, nil
}

// RollupUtils is an auto generated Go binding around an Ethereum contract.
type RollupUtils struct {
	RollupUtilsCaller     // Read-only binding to the contract
	RollupUtilsTransactor // Write-only binding to the contract
	RollupUtilsFilterer   // Log filterer for contract events
}

// RollupUtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type RollupUtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupUtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RollupUtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupUtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RollupUtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupUtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RollupUtilsSession struct {
	Contract     *RollupUtils      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RollupUtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RollupUtilsCallerSession struct {
	Contract *RollupUtilsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// RollupUtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RollupUtilsTransactorSession struct {
	Contract     *RollupUtilsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// RollupUtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type RollupUtilsRaw struct {
	Contract *RollupUtils // Generic contract binding to access the raw methods on
}

// RollupUtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RollupUtilsCallerRaw struct {
	Contract *RollupUtilsCaller // Generic read-only contract binding to access the raw methods on
}

// RollupUtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RollupUtilsTransactorRaw struct {
	Contract *RollupUtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRollupUtils creates a new instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtils(address common.Address, backend bind.ContractBackend) (*RollupUtils, error) {
	contract, err := bindRollupUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &RollupUtils{RollupUtilsCaller: RollupUtilsCaller{contract: contract}, RollupUtilsTransactor: RollupUtilsTransactor{contract: contract}, RollupUtilsFilterer: RollupUtilsFilterer{contract: contract}}, nil
}

// NewRollupUtilsCaller creates a new read-only instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtilsCaller(address common.Address, caller bind.ContractCaller) (*RollupUtilsCaller, error) {
	contract, err := bindRollupUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RollupUtilsCaller{contract: contract}, nil
}

// NewRollupUtilsTransactor creates a new write-only instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*RollupUtilsTransactor, error) {
	contract, err := bindRollupUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RollupUtilsTransactor{contract: contract}, nil
}

// NewRollupUtilsFilterer creates a new log filterer instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*RollupUtilsFilterer, error) {
	contract, err := bindRollupUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RollupUtilsFilterer{contract: contract}, nil
}

// bindRollupUtils binds a generic wrapper to an already deployed contract.
func bindRollupUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupUtilsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupUtils *RollupUtilsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupUtils.Contract.RollupUtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupUtils *RollupUtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupUtils.Contract.RollupUtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupUtils *RollupUtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupUtils.Contract.RollupUtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupUtils *RollupUtilsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupUtils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupUtils *RollupUtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupUtils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupUtils *RollupUtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupUtils.Contract.contract.Transact(opts, method, params...)
}

// SafeMathABI is the input ABI used to generate the binding from.
const SafeMathABI = "[]"

// SafeMathBin is the compiled bytecode used for deploying new contracts.
var SafeMathBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a723158201ca52c8cfd94848edb89c2f757752003702d51eace6d9e6123cdcc328cbf2aca64736f6c634300050f0032"

// DeploySafeMath deploys a new Ethereum contract, binding an instance of SafeMath to it.
func DeploySafeMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SafeMath, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SafeMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// SafeMath is an auto generated Go binding around an Ethereum contract.
type SafeMath struct {
	SafeMathCaller     // Read-only binding to the contract
	SafeMathTransactor // Write-only binding to the contract
	SafeMathFilterer   // Log filterer for contract events
}

// SafeMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type SafeMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeMathSession struct {
	Contract     *SafeMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeMathCallerSession struct {
	Contract *SafeMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// SafeMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeMathTransactorSession struct {
	Contract     *SafeMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SafeMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type SafeMathRaw struct {
	Contract *SafeMath // Generic contract binding to access the raw methods on
}

// SafeMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeMathCallerRaw struct {
	Contract *SafeMathCaller // Generic read-only contract binding to access the raw methods on
}

// SafeMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeMathTransactorRaw struct {
	Contract *SafeMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSafeMath creates a new instance of SafeMath, bound to a specific deployed contract.
func NewSafeMath(address common.Address, backend bind.ContractBackend) (*SafeMath, error) {
	contract, err := bindSafeMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// NewSafeMathCaller creates a new read-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathCaller(address common.Address, caller bind.ContractCaller) (*SafeMathCaller, error) {
	contract, err := bindSafeMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathCaller{contract: contract}, nil
}

// NewSafeMathTransactor creates a new write-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathTransactor(address common.Address, transactor bind.ContractTransactor) (*SafeMathTransactor, error) {
	contract, err := bindSafeMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathTransactor{contract: contract}, nil
}

// NewSafeMathFilterer creates a new log filterer instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathFilterer(address common.Address, filterer bind.ContractFilterer) (*SafeMathFilterer, error) {
	contract, err := bindSafeMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeMathFilterer{contract: contract}, nil
}

// bindSafeMath binds a generic wrapper to an already deployed contract.
func bindSafeMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.SafeMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transact(opts, method, params...)
}

// StakingABI is the input ABI used to generate the binding from.
const StakingABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"}],\"name\":\"RollupChallengeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asserter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"}],\"name\":\"RollupChallengeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"toNodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeMoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"RollupStakeRefunded\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeFactory\",\"outputs\":[{\"internalType\":\"contractIChallengeFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakeRequired\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakerAddress\",\"type\":\"address\"}],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resolveChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"asserterAddress\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"challengerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"prevNode\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"stakerNodeTypes\",\"type\":\"uint256[2]\"},{\"internalType\":\"bytes32[2]\",\"name\":\"vmProtoHashes\",\"type\":\"bytes32[2]\"},{\"internalType\":\"bytes32[]\",\"name\":\"asserterProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"challengerProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"asserterNodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"challengerDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"challengerPeriodTicks\",\"type\":\"uint128\"}],\"name\":\"startChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// StakingFuncSigs maps the 4-byte function signature to its string representation.
var StakingFuncSigs = map[string]string{
	"5dbaf68b": "challengeFactory()",
	"d16c305d": "getStakeRequired()",
	"6177fd18": "isStaked(address)",
	"6bc3cd22": "resolveChallenge(address,address,uint256)",
	"bac5963f": "startChallenge(address,address,bytes32,uint256,uint256[2],bytes32[2],bytes32[],bytes32[],bytes32,bytes32,uint128)",
}

// StakingBin is the compiled bytecode used for deploying new contracts.
var StakingBin = "0x608060405234801561001057600080fd5b50610c0e806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80635dbaf68b1461005c5780636177fd18146100805780636bc3cd22146100ba578063bac5963f146100f2578063d16c305d146102a8575b600080fd5b6100646102cc565b604080516001600160a01b039092168252519081900360200190f35b6100a66004803603602081101561009657600080fd5b50356001600160a01b03166102db565b604080519115158252519081900360200190f35b6100f0600480360360608110156100d057600080fd5b506001600160a01b038135811691602081013590911690604001356102f8565b005b6100f060048036036101a081101561010957600080fd5b6040805180820182526001600160a01b0384358116946020810135909116938382013593606083013593918301929160c08301916080840190600290839083908082843760009201919091525050604080518082018252929594938181019392509060029083908390808284376000920191909152509194939260208101925035905064010000000081111561019e57600080fd5b8201836020820111156101b057600080fd5b803590602001918460208302840111640100000000831117156101d257600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929594936020810193503591505064010000000081111561022257600080fd5b82018360208201111561023457600080fd5b8035906020019184602083028401116401000000008311171561025657600080fd5b91908080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525092955050823593505050602081013590604001356001600160801b0316610491565b6102b06108c3565b604080516001600160801b039092168252519081900360200190f35b6000546001600160a01b031681565b6001600160a01b0316600090815260026020526040902054151590565b33600090815260046020908152604091829020548251808401909352600f83526e2922a9afa1a420a62fa9a2a72222a960891b9183019190915260ff166103bd5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561038257818101518382015260200161036a565b50505050905090810190601f1680156103af5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b50336000908152600460205260408120805460ff191690556103de846108d2565b6001546040519192506001600160a01b0386169160026001600160801b039283160490911680156108fc02916000818181858888f19350505050158015610429573d6000803e3d6000fd5b5060018101805460ff60801b1916905561044283610963565b604080513381526001600160a01b03808716602083015285168183015290517f468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f299181900360600190a150505050565b600061049c8c6108d2565b905060006104a98c6108d2565b60018301549091508a906104c5906001600160801b03166109a4565b106040518060400160405280600d81526020016c53544b315f444541444c494e4560981b815250906105385760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b5060018101548a90610552906001600160801b03166109a4565b106040518060400160405280600d81526020016c53544b325f444541444c494e4560981b815250906105c55760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b50600182015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff16156106455760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b50600181015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff16156106c55760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b506020808a01518a5160408051808201909152600a8152692a2ca822afa7a92222a960b11b938101939093521161073d5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b50815461076561075f8d8d898e600060200201518e60005b60200201516109ab565b89610a13565b146040518060400160405280600c81526020016b20a9a9a2a92a2fa82927a7a360a11b815250906107d75760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b5080546108086108028d8d6107f5896001600160801b038a16610a2a565b60208f01518e6001610755565b88610a13565b146040518060400160405280600a81526020016921a420a62fa82927a7a360b11b815250906108785760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b5060018281018054600160801b60ff60801b199182168117909255918301805490921617905560208901516108b4908e908e9086908890610a56565b50505050505050505050505050565b6001546001600160801b031690565b6001600160a01b038116600090815260026020908152604080832080548251808401909352600a83526924a72b2fa9aa20a5a2a960b11b938301939093529161095c5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561038257818101518382015260200161036a565b5092915050565b6001600160a01b03166000908152600260205260408120908155600101805470ffffffffffffffffffffffffffffffffff1916905560038054600019019055565b6103e80290565b6040805160208082018490528183018790526060820186905260808083018690528351808403909101815260a08301845280519082012060c0830189905260e08084019190915283518084039091018152610100909201909252805191012095945050505050565b6000610a23838360008551610b71565b9392505050565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b600080546040805163432ed0e160e11b81526001600160a01b03898116600483015288811660248301526001600160801b038816604483015260648201879052608482018690529151919092169163865da1c29160a480830192602092919082900301818787803b158015610aca57600080fd5b505af1158015610ade573d6000803e3d6000fd5b505050506040513d6020811015610af457600080fd5b50516001600160a01b03808216600081815260046020908152604091829020805460ff1916600117905581518b85168152938a16908401528281018690526060830191909152519192507f6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f919081900360800190a1505050505050565b600084835b83811015610bcf5781868281518110610b8b57fe5b602002602001015160405160200180838152602001828152602001925050506040516020818303038152906040528051906020012091508080600101915050610b76565b509594505050505056fea265627a7a723158203825343eee4bf7695a16531d6dbd0598e9bd2adbad8281f94fa36da892c2668564736f6c634300050f0032"

// DeployStaking deploys a new Ethereum contract, binding an instance of Staking to it.
func DeployStaking(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Staking, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(StakingBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Staking{StakingCaller: StakingCaller{contract: contract}, StakingTransactor: StakingTransactor{contract: contract}, StakingFilterer: StakingFilterer{contract: contract}}, nil
}

// Staking is an auto generated Go binding around an Ethereum contract.
type Staking struct {
	StakingCaller     // Read-only binding to the contract
	StakingTransactor // Write-only binding to the contract
	StakingFilterer   // Log filterer for contract events
}

// StakingCaller is an auto generated read-only Go binding around an Ethereum contract.
type StakingCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StakingTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StakingFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StakingSession struct {
	Contract     *Staking          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StakingCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StakingCallerSession struct {
	Contract *StakingCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// StakingTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StakingTransactorSession struct {
	Contract     *StakingTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// StakingRaw is an auto generated low-level Go binding around an Ethereum contract.
type StakingRaw struct {
	Contract *Staking // Generic contract binding to access the raw methods on
}

// StakingCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StakingCallerRaw struct {
	Contract *StakingCaller // Generic read-only contract binding to access the raw methods on
}

// StakingTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StakingTransactorRaw struct {
	Contract *StakingTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStaking creates a new instance of Staking, bound to a specific deployed contract.
func NewStaking(address common.Address, backend bind.ContractBackend) (*Staking, error) {
	contract, err := bindStaking(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Staking{StakingCaller: StakingCaller{contract: contract}, StakingTransactor: StakingTransactor{contract: contract}, StakingFilterer: StakingFilterer{contract: contract}}, nil
}

// NewStakingCaller creates a new read-only instance of Staking, bound to a specific deployed contract.
func NewStakingCaller(address common.Address, caller bind.ContractCaller) (*StakingCaller, error) {
	contract, err := bindStaking(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StakingCaller{contract: contract}, nil
}

// NewStakingTransactor creates a new write-only instance of Staking, bound to a specific deployed contract.
func NewStakingTransactor(address common.Address, transactor bind.ContractTransactor) (*StakingTransactor, error) {
	contract, err := bindStaking(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StakingTransactor{contract: contract}, nil
}

// NewStakingFilterer creates a new log filterer instance of Staking, bound to a specific deployed contract.
func NewStakingFilterer(address common.Address, filterer bind.ContractFilterer) (*StakingFilterer, error) {
	contract, err := bindStaking(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StakingFilterer{contract: contract}, nil
}

// bindStaking binds a generic wrapper to an already deployed contract.
func bindStaking(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staking *StakingRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Staking.Contract.StakingCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staking *StakingRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.Contract.StakingTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staking *StakingRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staking.Contract.StakingTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staking *StakingCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Staking.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staking *StakingTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staking *StakingTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staking.Contract.contract.Transact(opts, method, params...)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_Staking *StakingCaller) ChallengeFactory(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "challengeFactory")
	return *ret0, err
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_Staking *StakingSession) ChallengeFactory() (common.Address, error) {
	return _Staking.Contract.ChallengeFactory(&_Staking.CallOpts)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_Staking *StakingCallerSession) ChallengeFactory() (common.Address, error) {
	return _Staking.Contract.ChallengeFactory(&_Staking.CallOpts)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_Staking *StakingCaller) GetStakeRequired(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "getStakeRequired")
	return *ret0, err
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_Staking *StakingSession) GetStakeRequired() (*big.Int, error) {
	return _Staking.Contract.GetStakeRequired(&_Staking.CallOpts)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_Staking *StakingCallerSession) GetStakeRequired() (*big.Int, error) {
	return _Staking.Contract.GetStakeRequired(&_Staking.CallOpts)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_Staking *StakingCaller) IsStaked(opts *bind.CallOpts, _stakerAddress common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "isStaked", _stakerAddress)
	return *ret0, err
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_Staking *StakingSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _Staking.Contract.IsStaked(&_Staking.CallOpts, _stakerAddress)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_Staking *StakingCallerSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _Staking.Contract.IsStaked(&_Staking.CallOpts, _stakerAddress)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_Staking *StakingTransactor) ResolveChallenge(opts *bind.TransactOpts, winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "resolveChallenge", winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_Staking *StakingSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.ResolveChallenge(&_Staking.TransactOpts, winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_Staking *StakingTransactorSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.ResolveChallenge(&_Staking.TransactOpts, winner, loser, arg2)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_Staking *StakingTransactor) StartChallenge(opts *bind.TransactOpts, asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "startChallenge", asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_Staking *StakingSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.StartChallenge(&_Staking.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_Staking *StakingTransactorSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.StartChallenge(&_Staking.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StakingRollupChallengeCompletedIterator is returned from FilterRollupChallengeCompleted and is used to iterate over the raw logs and unpacked data for RollupChallengeCompleted events raised by the Staking contract.
type StakingRollupChallengeCompletedIterator struct {
	Event *StakingRollupChallengeCompleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupChallengeCompletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupChallengeCompleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupChallengeCompleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupChallengeCompletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupChallengeCompletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupChallengeCompleted represents a RollupChallengeCompleted event raised by the Staking contract.
type StakingRollupChallengeCompleted struct {
	ChallengeContract common.Address
	Winner            common.Address
	Loser             common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeCompleted is a free log retrieval operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_Staking *StakingFilterer) FilterRollupChallengeCompleted(opts *bind.FilterOpts) (*StakingRollupChallengeCompletedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return &StakingRollupChallengeCompletedIterator{contract: _Staking.contract, event: "RollupChallengeCompleted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeCompleted is a free log subscription operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_Staking *StakingFilterer) WatchRollupChallengeCompleted(opts *bind.WatchOpts, sink chan<- *StakingRollupChallengeCompleted) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupChallengeCompleted)
				if err := _Staking.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeCompleted is a log parse operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_Staking *StakingFilterer) ParseRollupChallengeCompleted(log types.Log) (*StakingRollupChallengeCompleted, error) {
	event := new(StakingRollupChallengeCompleted)
	if err := _Staking.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupChallengeStartedIterator is returned from FilterRollupChallengeStarted and is used to iterate over the raw logs and unpacked data for RollupChallengeStarted events raised by the Staking contract.
type StakingRollupChallengeStartedIterator struct {
	Event *StakingRollupChallengeStarted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupChallengeStartedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupChallengeStarted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupChallengeStarted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupChallengeStartedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupChallengeStartedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupChallengeStarted represents a RollupChallengeStarted event raised by the Staking contract.
type StakingRollupChallengeStarted struct {
	Asserter          common.Address
	Challenger        common.Address
	ChallengeType     *big.Int
	ChallengeContract common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeStarted is a free log retrieval operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_Staking *StakingFilterer) FilterRollupChallengeStarted(opts *bind.FilterOpts) (*StakingRollupChallengeStartedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return &StakingRollupChallengeStartedIterator{contract: _Staking.contract, event: "RollupChallengeStarted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeStarted is a free log subscription operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_Staking *StakingFilterer) WatchRollupChallengeStarted(opts *bind.WatchOpts, sink chan<- *StakingRollupChallengeStarted) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupChallengeStarted)
				if err := _Staking.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeStarted is a log parse operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_Staking *StakingFilterer) ParseRollupChallengeStarted(log types.Log) (*StakingRollupChallengeStarted, error) {
	event := new(StakingRollupChallengeStarted)
	if err := _Staking.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupStakeCreatedIterator is returned from FilterRollupStakeCreated and is used to iterate over the raw logs and unpacked data for RollupStakeCreated events raised by the Staking contract.
type StakingRollupStakeCreatedIterator struct {
	Event *StakingRollupStakeCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupStakeCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupStakeCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupStakeCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupStakeCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupStakeCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupStakeCreated represents a RollupStakeCreated event raised by the Staking contract.
type StakingRollupStakeCreated struct {
	Staker   common.Address
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeCreated is a free log retrieval operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_Staking *StakingFilterer) FilterRollupStakeCreated(opts *bind.FilterOpts) (*StakingRollupStakeCreatedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return &StakingRollupStakeCreatedIterator{contract: _Staking.contract, event: "RollupStakeCreated", logs: logs, sub: sub}, nil
}

// WatchRollupStakeCreated is a free log subscription operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_Staking *StakingFilterer) WatchRollupStakeCreated(opts *bind.WatchOpts, sink chan<- *StakingRollupStakeCreated) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupStakeCreated)
				if err := _Staking.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeCreated is a log parse operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_Staking *StakingFilterer) ParseRollupStakeCreated(log types.Log) (*StakingRollupStakeCreated, error) {
	event := new(StakingRollupStakeCreated)
	if err := _Staking.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupStakeMovedIterator is returned from FilterRollupStakeMoved and is used to iterate over the raw logs and unpacked data for RollupStakeMoved events raised by the Staking contract.
type StakingRollupStakeMovedIterator struct {
	Event *StakingRollupStakeMoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupStakeMovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupStakeMoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupStakeMoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupStakeMovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupStakeMovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupStakeMoved represents a RollupStakeMoved event raised by the Staking contract.
type StakingRollupStakeMoved struct {
	Staker     common.Address
	ToNodeHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeMoved is a free log retrieval operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_Staking *StakingFilterer) FilterRollupStakeMoved(opts *bind.FilterOpts) (*StakingRollupStakeMovedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return &StakingRollupStakeMovedIterator{contract: _Staking.contract, event: "RollupStakeMoved", logs: logs, sub: sub}, nil
}

// WatchRollupStakeMoved is a free log subscription operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_Staking *StakingFilterer) WatchRollupStakeMoved(opts *bind.WatchOpts, sink chan<- *StakingRollupStakeMoved) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupStakeMoved)
				if err := _Staking.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeMoved is a log parse operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_Staking *StakingFilterer) ParseRollupStakeMoved(log types.Log) (*StakingRollupStakeMoved, error) {
	event := new(StakingRollupStakeMoved)
	if err := _Staking.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupStakeRefundedIterator is returned from FilterRollupStakeRefunded and is used to iterate over the raw logs and unpacked data for RollupStakeRefunded events raised by the Staking contract.
type StakingRollupStakeRefundedIterator struct {
	Event *StakingRollupStakeRefunded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupStakeRefundedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupStakeRefunded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupStakeRefunded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupStakeRefundedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupStakeRefundedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupStakeRefunded represents a RollupStakeRefunded event raised by the Staking contract.
type StakingRollupStakeRefunded struct {
	Staker common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeRefunded is a free log retrieval operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_Staking *StakingFilterer) FilterRollupStakeRefunded(opts *bind.FilterOpts) (*StakingRollupStakeRefundedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return &StakingRollupStakeRefundedIterator{contract: _Staking.contract, event: "RollupStakeRefunded", logs: logs, sub: sub}, nil
}

// WatchRollupStakeRefunded is a free log subscription operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_Staking *StakingFilterer) WatchRollupStakeRefunded(opts *bind.WatchOpts, sink chan<- *StakingRollupStakeRefunded) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupStakeRefunded)
				if err := _Staking.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeRefunded is a log parse operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_Staking *StakingFilterer) ParseRollupStakeRefunded(log types.Log) (*StakingRollupStakeRefunded, error) {
	event := new(StakingRollupStakeRefunded)
	if err := _Staking.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// VMABI is the input ABI used to generate the binding from.
const VMABI = "[]"

// VMBin is the compiled bytecode used for deploying new contracts.
var VMBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820e25089421607c096245d7a6e20dc182b907a294c5553a72738e5a75b835dca3364736f6c634300050f0032"

// DeployVM deploys a new Ethereum contract, binding an instance of VM to it.
func DeployVM(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *VM, error) {
	parsed, err := abi.JSON(strings.NewReader(VMABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(VMBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &VM{VMCaller: VMCaller{contract: contract}, VMTransactor: VMTransactor{contract: contract}, VMFilterer: VMFilterer{contract: contract}}, nil
}

// VM is an auto generated Go binding around an Ethereum contract.
type VM struct {
	VMCaller     // Read-only binding to the contract
	VMTransactor // Write-only binding to the contract
	VMFilterer   // Log filterer for contract events
}

// VMCaller is an auto generated read-only Go binding around an Ethereum contract.
type VMCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VMTransactor is an auto generated write-only Go binding around an Ethereum contract.
type VMTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VMFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type VMFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VMSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type VMSession struct {
	Contract     *VM               // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// VMCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type VMCallerSession struct {
	Contract *VMCaller     // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// VMTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type VMTransactorSession struct {
	Contract     *VMTransactor     // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// VMRaw is an auto generated low-level Go binding around an Ethereum contract.
type VMRaw struct {
	Contract *VM // Generic contract binding to access the raw methods on
}

// VMCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type VMCallerRaw struct {
	Contract *VMCaller // Generic read-only contract binding to access the raw methods on
}

// VMTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type VMTransactorRaw struct {
	Contract *VMTransactor // Generic write-only contract binding to access the raw methods on
}

// NewVM creates a new instance of VM, bound to a specific deployed contract.
func NewVM(address common.Address, backend bind.ContractBackend) (*VM, error) {
	contract, err := bindVM(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &VM{VMCaller: VMCaller{contract: contract}, VMTransactor: VMTransactor{contract: contract}, VMFilterer: VMFilterer{contract: contract}}, nil
}

// NewVMCaller creates a new read-only instance of VM, bound to a specific deployed contract.
func NewVMCaller(address common.Address, caller bind.ContractCaller) (*VMCaller, error) {
	contract, err := bindVM(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &VMCaller{contract: contract}, nil
}

// NewVMTransactor creates a new write-only instance of VM, bound to a specific deployed contract.
func NewVMTransactor(address common.Address, transactor bind.ContractTransactor) (*VMTransactor, error) {
	contract, err := bindVM(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &VMTransactor{contract: contract}, nil
}

// NewVMFilterer creates a new log filterer instance of VM, bound to a specific deployed contract.
func NewVMFilterer(address common.Address, filterer bind.ContractFilterer) (*VMFilterer, error) {
	contract, err := bindVM(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &VMFilterer{contract: contract}, nil
}

// bindVM binds a generic wrapper to an already deployed contract.
func bindVM(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(VMABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_VM *VMRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _VM.Contract.VMCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_VM *VMRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _VM.Contract.VMTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_VM *VMRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _VM.Contract.VMTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_VM *VMCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _VM.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_VM *VMTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _VM.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_VM *VMTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _VM.Contract.contract.Transact(opts, method, params...)
}

// ValueABI is the input ABI used to generate the binding from.
const ValueABI = "[]"

// ValueBin is the compiled bytecode used for deploying new contracts.
var ValueBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820a1a1c0c60e169357bb80e951ac1cb57368ef18899e17b41422edaf115ce97ae764736f6c634300050f0032"

// DeployValue deploys a new Ethereum contract, binding an instance of Value to it.
func DeployValue(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Value, error) {
	parsed, err := abi.JSON(strings.NewReader(ValueABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ValueBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Value{ValueCaller: ValueCaller{contract: contract}, ValueTransactor: ValueTransactor{contract: contract}, ValueFilterer: ValueFilterer{contract: contract}}, nil
}

// Value is an auto generated Go binding around an Ethereum contract.
type Value struct {
	ValueCaller     // Read-only binding to the contract
	ValueTransactor // Write-only binding to the contract
	ValueFilterer   // Log filterer for contract events
}

// ValueCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValueCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValueTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValueTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValueFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValueFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValueSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValueSession struct {
	Contract     *Value            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ValueCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValueCallerSession struct {
	Contract *ValueCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ValueTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValueTransactorSession struct {
	Contract     *ValueTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ValueRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValueRaw struct {
	Contract *Value // Generic contract binding to access the raw methods on
}

// ValueCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValueCallerRaw struct {
	Contract *ValueCaller // Generic read-only contract binding to access the raw methods on
}

// ValueTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValueTransactorRaw struct {
	Contract *ValueTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValue creates a new instance of Value, bound to a specific deployed contract.
func NewValue(address common.Address, backend bind.ContractBackend) (*Value, error) {
	contract, err := bindValue(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Value{ValueCaller: ValueCaller{contract: contract}, ValueTransactor: ValueTransactor{contract: contract}, ValueFilterer: ValueFilterer{contract: contract}}, nil
}

// NewValueCaller creates a new read-only instance of Value, bound to a specific deployed contract.
func NewValueCaller(address common.Address, caller bind.ContractCaller) (*ValueCaller, error) {
	contract, err := bindValue(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValueCaller{contract: contract}, nil
}

// NewValueTransactor creates a new write-only instance of Value, bound to a specific deployed contract.
func NewValueTransactor(address common.Address, transactor bind.ContractTransactor) (*ValueTransactor, error) {
	contract, err := bindValue(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValueTransactor{contract: contract}, nil
}

// NewValueFilterer creates a new log filterer instance of Value, bound to a specific deployed contract.
func NewValueFilterer(address common.Address, filterer bind.ContractFilterer) (*ValueFilterer, error) {
	contract, err := bindValue(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValueFilterer{contract: contract}, nil
}

// bindValue binds a generic wrapper to an already deployed contract.
func bindValue(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValueABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Value *ValueRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Value.Contract.ValueCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Value *ValueRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Value.Contract.ValueTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Value *ValueRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Value.Contract.ValueTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Value *ValueCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Value.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Value *ValueTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Value.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Value *ValueTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Value.Contract.contract.Transact(opts, method, params...)
}
